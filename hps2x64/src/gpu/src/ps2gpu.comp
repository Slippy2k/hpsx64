R"(
#version 450 core

#define COMMAND_LIST_SIZE	( 1 << 16 )

#define PIXEL_LIST_SIZE		( 1 << 21 )
#define PIXEL_LIST_MASK		( PIXEL_LIST_SIZE - 1 )

// this needs to be set here and in PS2_GPU.cpp
#define PRECOMPUTE_LIST_SIZE	( 1 << 16 )
#define PRECOMPUTE_LIST_MASK	( PRECOMPUTE_LIST_SIZE - 1 )


#define DRAW_TEXTURE_VECTOR

#define DRAW_SCREEN_VECTOR
#define DRAW_SCREEN_VECTOR_NEW
#define DRAW_SCREEN_VECTOR_NEW2


#define ENABLE_PIXELIN_BUFFER


#define USE_MULTI_PIXEL_MOVE


#define PRECALC_COMMON_VARS

#define PRECALC_SPRITE_VARS
//#define CALC_SPRITE_VARS
#define LOAD_SPRITE_VARS

//#define CALC_RECTANGLE_VARS
#define LOAD_RECTANGLE_VARS

#define DRAW_RECTANGLE_MULTI
#define DRAW_SPRITE_MULTI
#define DRAW_TRIANGLE_TEXTURE_MULTI
#define DRAW_TRIANGLE_COLOR_MULTI

#define USE_RECTANGLE_MULTI_PIXEL
#define USE_RECTANGLE_MULTI_ZPIXEL
#define USE_RECTANGLE_MULTI_PIXEL_STORE
#define USE_RECTANGLE_MULTI_ZPIXEL_STORE


#define USE_SPRITE_MULTI_PIXEL
#define USE_SPRITE_MULTI_ZPIXEL
#define USE_SPRITE_MULTI_PIXEL_STORE
#define USE_SPRITE_MULTI_ZPIXEL_STORE
#define USE_SPRITE_NEW_TEXPIXEL


#define PRECALC_TRIANGLE_VARS

//#define CALC_TRIANGLE_COLOR_VARS
//#define CALC_TRIANGLE_TEXTURE_VARS

#define LOAD_TRIANGLE_COLOR_VARS
#define LOAD_TRIANGLE_TEXTURE_VARS

#define USE_TRIANGLE_MULTI_PIXEL
#define USE_TRIANGLE_MULTI_ZPIXEL
#define USE_TRIANGLE_MULTI_PIXEL_STORE
#define USE_TRIANGLE_MULTI_ZPIXEL_STORE
#define USE_TRIANGLE_NEW_TEXPIXEL

#define USE_LOCAL_CLUT
//#define USE_PRIVATE_CLUT

layout (local_size_x = 16, local_size_y = 16) in;



layout (std430, binding = 0) buffer sCmd {
	// the pre-compute buffer
	int data [ 128 * PRECOMPUTE_LIST_SIZE ];
};
layout (std430, binding = 0) buffer sCmd2 {
	// the pre-compute buffer
	ivec2 data2 [ ( 128 * PRECOMPUTE_LIST_SIZE ) >> 1 ];
};
layout (std430, binding = 0) buffer sCmd4 {
	// the pre-compute buffer
	ivec4 data4 [ ( 128 * PRECOMPUTE_LIST_SIZE ) >> 2 ];
};



layout (std430, binding = 1) buffer Cmd {
	// the input commands to draw
	uint inputdata [ 64 * COMMAND_LIST_SIZE ];
};
layout (std430, binding = 1) buffer Cmd2 {
	uvec2 inputdata2 [ ( 64 * COMMAND_LIST_SIZE ) >> 1 ];
};
layout (std430, binding = 1) buffer Cmd4 {
	uvec4 inputdata4 [ ( 64 * COMMAND_LIST_SIZE ) >> 2 ];
};


layout (std430, binding = 3) buffer FrameBuf {
// the shader representation of vram
// on the ps2 this should be 4MB
// but then times 2 for the shaders = 8MB
uint VRAM [ ( ( 1 << 22 ) >> 2 ) << 1 ];
};
layout (std430, binding = 3) buffer FrameBuf2 {
uvec2 VRAM2 [ ( ( ( 1 << 22 ) >> 2 ) << 1 ) >> 1 ];
};
layout (std430, binding = 3) buffer FrameBuf4 {
uvec4 VRAM4 [ ( ( ( 1 << 22 ) >> 2 ) << 1 ) >> 2 ];
};



layout (std430, binding = 4) buffer ShadowFrameBuf {
// the shader representation of vram
uint sVRAM [ ( ( 1 << 22 ) >> 2 ) << 1 ];
};
layout (std430, binding = 4) buffer ShadowFrameBuf2 {
uvec2 sVRAM2 [ ( ( ( 1 << 22 ) >> 2 ) << 1 ) >> 1 ];
};
layout (std430, binding = 4) buffer ShadowFrameBuf4 {
uvec4 sVRAM4 [ ( ( ( 1 << 22 ) >> 2 ) << 1 ) >> 2 ];
};



layout (std430, binding = 2) buffer ScreenBuf {
// the display window
uint pixelbuffer32 [ 1024 * 1024 ];
};
layout (std430, binding = 2) buffer ScreenBuf2 {
// the display window
uvec2 pixel2buffer32 [ 1024 * 1024 ];
};
layout (std430, binding = 2) buffer ScreenBuf4 {
// the display window
uvec4 pixel4buffer32 [ 1024 * 1024 ];
};


layout (std430, binding = 11) restrict buffer InputPixels {
// the display window
uint PixelInput32 [ PIXEL_LIST_SIZE ];
};


layout (binding = 5,rgba8) restrict writeonly uniform image2D destTex;




layout (std430, binding = 6) restrict buffer LUTBUFX {
// the display window
int LUT_XOFFSET [ 32 * 4096 ];
};

layout (std430, binding = 7) restrict buffer LUTBUFY {
// the display window
int LUT_YOFFSET [ 32 * 128 ];
};








layout (std430, binding = 8) restrict buffer LUTBUFCLUT {
// the display window
uint cLOCAL_CLUT [ 256 * 2 ];
};


layout (std430, binding = 10) restrict buffer oCBPX {
// the display window
int cCBPX [ 2 ];
};
layout (std430, binding = 10) restrict buffer oCBPX2 {
// the display window
ivec2 cCBPX2;
};


shared uint LOCAL_CLUT [ 256 * 2 ];
shared ivec2 CBPX2;



#define ENABLE_PIXELBUF_INTERLACING	


const int c_iFrameBuffer_DisplayWidth = 640;
const int c_iFrameBuffer_DisplayHeight = 960;

const int c_iScreen_MaxWidth = 1024;
const int c_iScreen_MaxHeight = 1024;


//shared int LUT_YNAND [ 32 ];


const int LUT_YNAND[] = { ~0x1f, ~0x3f, 0, 0, ~0x3f, 0, 0, 0,
							0, ~0x3f, ~0x7f, 0, 0, ~0x1f, 0, 0,
							0, 0, ~0x1f, 0, 0, 0, ~0x1f, 0,
							~0x1f, ~0x3f, 0, 0, 0, ~0x3f, 0, 0 };


//int LUT_XNAND[] = { ~0x3f, ~0x3f, 0, 0, ~0x3f, 0, 0, 0, 
//							0, ~0x7f, ~0x7f, 0, 0, ~0x3f, 0, 0,
//							0, 0, ~0x3f, 0, 0, 0, ~0x3f, 0,
//							~0x3f, ~0x3f, 0, 0, 0, ~0x3f, 0, 0 };


//int LUT_XSHIFT[] = { 5, 6, 0, 0, 6, 0, 0, 0,
//							0, 6, 7, 0, 0, 5, 0, 0,
//							0, 0, 5, 0, 0, 0, 5, 0,
//							5, 6, 0, 0, 0, 6, 0, 0 };






const int c_MaxPolygonWidth = 1023;
const int c_MaxPolygonHeight = 511;


const ivec4 vZero = ivec4( 0 );



#define intdivf(op1, op2, fp1, fp2, fpout) (int(( ( float( (op1) ) / float( 1 << (fp1) ) ) / ( float( (op2) ) / float( 1 << (fp2) ) ) ) * float(1 << (fpout))))
#define intdivd(op1, op2, fp1, fp2, fpout) (int(( ( double( (op1) ) / double( 1 << (fp1) ) ) / ( double( (op2) ) / double( 1 << (fp2) ) ) ) * double(1 << (fpout))))

#define intdivf2(op1, op2, fp1, fp2, fpout) (int( ( float( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))


#define intdivfv2(op1, op2, fp1, fp2, fpout) (ivec2( ( vec2( (op1) ) / vec2( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv3(op1, op2, fp1, fp2, fpout) (ivec3( ( vec3( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv4(op1, op2, fp1, fp2, fpout) (ivec4( ( vec4( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))



shared int xinc;
shared int yinc;
shared int xxinc;

shared int group_x, group_y;
shared int group_xcount, group_ycount;
shared int group_xinc, group_yinc;
shared int group_xshift, group_yshift;
shared int group_xmask, group_ymask;

shared int group_vxinc;
shared int group_vxmask;

shared int group_xinc_shift;
shared int group_yinc_shift;
shared int group_vxinc_shift;





//shared int SrcStartX, SrcStartY, DstStartX, DstStartY, Height, Width, SrcXRun, DstXRun, Width1, Width2;

//shared int BS, Count;

//shared uint Comm;
//shared int SharedYMax, xximagepixelstart;

//shared uint GPU_CTRL_Read;
//shared int DisplayRange_X1;
//shared int DisplayRange_X2;
//shared int DisplayRange_Y1;
//shared int DisplayRange_Y2;
//shared int ScreenArea_TopLeftX;
//shared int ScreenArea_TopLeftY;
//shared int bEnableScanline;
//shared int Y_Pixel;

// need to know visible range of screen for NTSC and for PAL (each should be different)
// NTSC visible y range is usually from 16-256 (0x10-0x100) (height=240)
// PAL visible y range is usually from 35-291 (0x23-0x123) (height=256)
// NTSC visible x range is.. I don't know. start with from about gpu cycle#544 to about gpu cycle#3232 (must use gpu cycles since res changes)
//shared int VisibleArea_StartX, VisibleArea_EndX, VisibleArea_StartY, VisibleArea_EndY, VisibleArea_Width, VisibleArea_Height;
// this allows you to calculate horizontal pixels
//shared int GPU_CyclesPerPixel;
// need to know where to draw the actual image at
//shared int Draw_StartX, Draw_StartY, Draw_EndX, Draw_EndY, Draw_Width, Draw_Height;

//shared int Source_Height;
//shared int TopBorder_Height, BottomBorder_Height, LeftBorder_Width, RightBorder_Width;
//shared int current_width, current_height, current_size, current_xmax, current_ymax;

//shared uint GPU_CTRL_Read_ISINTER;
//shared uint GPU_CTRL_Read_HEIGHT;
//shared uint GPU_CTRL_Read_WIDTH;
//shared uint GPU_CTRL_Read_DEN;
//shared uint GPU_CTRL_Read_ISRGB24;
//shared uint GPU_CTRL_Read_VIDEO;



void draw_texture ( int xsize, int ysize )
{
	const float c_fmaxcolor = 1.0f / 255.0f;


	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );

	ivec2 pos;
	ivec2 pos2;
	uvec4 rgba;
	uint pixel;
	vec4 frgba;

	uvec4 va, vr, vg, vb;
	uvec4 vp;

	mat4 mrgba;

	// don't know if all the threads have completed all the other tasks yet
	//barrier ();

	//rgba.a = 1;
	for ( pos.y = ( yid << group_yshift ) + group_y; pos.y < ysize; pos.y += group_yinc )
	{
#ifdef DRAW_TEXTURE_VECTOR
		for ( pos.x = ( xid << (group_xshift+2) ) + group_x; pos.x < xsize; pos.x += (group_xinc<<2) )
#else
		for ( pos.x = ( xid << group_xshift ) + group_x; pos.x < xsize; pos.x += group_xinc )
#endif
		{
#ifdef DRAW_TEXTURE_VECTOR
			vp = pixel4buffer32 [ ( pos.x + ( pos.y * xsize ) ) >> 2 ];
#else
			pixel = pixelbuffer32 [ pos.x + ( pos.y * xsize ) ];
#endif

			//rgba[0] = ( pixel >> 16 ) & 0xff;
			//rgba[1] = ( pixel >> 8 ) & 0xff;
			//rgba[2] = ( pixel >> 0 ) & 0xff;
			//rgba[3] = 0;
			//rgba[0] = 0xff;	// red
			//rgba[1] = 0xff;	// green
			//rgba[2] = 0x00;	// blue
			//rgba[3] = 0x00;	// alpha

			//frgba.b = float( ( pixel >> 16 ) & 0xff ) / 255.0;
			//frgba.g = float( ( pixel >> 8 ) & 0xff ) / 255.0;
			//frgba.r = float( ( pixel >> 0 ) & 0xff ) / 255.0;
			//frgba.a = 1.0;

#ifdef DRAW_TEXTURE_VECTOR
			mrgba[2] = vec4( ( vp >> 16 ) & 0xff );
			mrgba[1] = vec4( ( vp >> 8 ) & 0xff );
			mrgba[0] = vec4( vp & 0xff );

			mrgba = transpose( mrgba ) * c_fmaxcolor;

			pos2 = pos;
			imageStore( destTex, pos2, mrgba[0] );
			pos2.x++;
			imageStore( destTex, pos2, mrgba[1] );
			pos2.x++;
			imageStore( destTex, pos2, mrgba[2] );
			pos2.x++;
			imageStore( destTex, pos2, mrgba[3] );
#else

			rgba.b = pixel >> 16;
			rgba.g = pixel >> 8;
			rgba.r = pixel;

			rgba &= 0xff;

			frgba = vec4( rgba ) * c_fmaxcolor;

			imageStore( destTex, pos, frgba );
#endif

		}
	}
}

void draw_screen( uint uIndex )
{

	int xxid = int( gl_LocalInvocationIndex );
	
	//const int c_iVisibleArea_StartX_Cycle = 584;
	//const int c_iVisibleArea_EndX_Cycle = 3192;
	//const int c_iVisibleArea_StartY_Pixel_NTSC = 15;
	//const int c_iVisibleArea_EndY_Pixel_NTSC = 257;
	//const int c_iVisibleArea_StartY_Pixel_PAL = 34;
	//const int c_iVisibleArea_EndY_Pixel_PAL = 292;

	//const int c_iVisibleArea_StartY [] = { c_iVisibleArea_StartY_Pixel_NTSC, c_iVisibleArea_StartY_Pixel_PAL };
	//const int c_iVisibleArea_EndY [] = { c_iVisibleArea_EndY_Pixel_NTSC, c_iVisibleArea_EndY_Pixel_PAL };	
	

	int x, y;
	
	//u32* buf_ptr;
	//u32 *buf_ptr32;
	//u16 *buf_ptr16;
	
	//u32* buf_ptr_2;
	//u32 *buf_ptr32_2;
	//u16 *buf_ptr16_2;
	
	int draw_buffer_offset32;
	int draw_width, draw_height;
	int start_x, start_y;
	int Index = 0;

	int draw_buffer_offset_2;
	int draw_width_2, draw_height_2;
	int start_x_2, start_y_2;
	
	uint Pixel16, Pixel32;
	uint Pixel32_0, Pixel32_1;
	//u32 PixelFormat;
	
	//u64 DISPFBX, DISPLAYX;
	//u64 DISPFB1, DISPLAY1;
	//u64 DISPFB2, DISPLAY2;
	uint DISPFBX_0, DISPLAYX_0;
	uint DISPFB1_0, DISPLAY1_0;
	uint DISPFB2_0, DISPLAY2_0;
	uint DISPFBX_1, DISPLAYX_1;
	uint DISPFB1_1, DISPLAY1_1;
	uint DISPFB2_1, DISPLAY2_1;
	
	uint DISPFBX_FBP, DISPFBX_FBW, DISPLAYX_DH, DISPFBX_DBX, DISPFBX_DBY;
	uint DISPFB1_FBP, DISPFB1_FBW, DISPLAY1_DH, DISPFB1_DBX, DISPFB1_DBY;
	uint DISPFB2_FBP, DISPFB2_FBW, DISPLAY2_DH, DISPFB2_DBX, DISPFB2_DBY;
	uint DISPFB1_PSM, DISPFB2_PSM;
	uint lScanline;
	
	uint PMODE;
	uint PMODE_MMOD, PMODE_AMOD, PMODE_SLBG, PMODE_ALP;
	

	uint DISPFBX_PSM, SMODE2_FFMD, SMODE2_INTER;
	uint SMODE2;


	//bool bEnableBlend;

	int ipixelbuffer32;
	int xoffset32, yoffset32, offset32;
	int PixelFormat;
	int FPSM;

	ivec4 vxoffset32, vyoffset32, voffset32;
	ivec4 vIdx, ivIndex;
	ivec4 vx, vy, vy2;
	ivec4 vMask;
	uvec4 vPixel0, vPixel1;

	int iCount;
	int iStride;

	// don't know yet if blending is needed
	//bEnableBlend = false;
	
	uIndex <<= 6;

	PMODE = inputdata [ uIndex + 0 ];

	
	
	PMODE_MMOD = ( PMODE >> 5 ) & 1;
	PMODE_AMOD = ( PMODE >> 6 ) & 1;
	PMODE_SLBG = ( PMODE >> 7 ) & 1;
	PMODE_ALP = ( PMODE >> 8 ) & 0xff;
	
	
	
	lScanline = inputdata [ uIndex + ( 13 << 1 ) + 0 ];

	DISPFBX_0 = inputdata [ uIndex + ( 11 << 1 ) + 0 ];
	DISPLAYX_0 = inputdata [ uIndex + ( 12 << 1 ) + 0 ];

	DISPFBX_1 = inputdata [ uIndex + ( 11 << 1 ) + 1 ];
	DISPLAYX_1 = inputdata [ uIndex + ( 12 << 1 ) + 1 ];

	DISPFB1_0 = inputdata [ uIndex + ( 1 << 1 ) + 0 ];
	DISPFB2_0 = inputdata [ uIndex + ( 2 << 1 ) + 0 ];

	DISPFB1_1 = inputdata [ uIndex + ( 1 << 1 ) + 1 ];
	DISPFB2_1 = inputdata [ uIndex + ( 2 << 1 ) + 1 ];

	DISPLAY1_0 = inputdata [ uIndex + ( 3 << 1 ) + 0 ];
	DISPLAY2_0 = inputdata [ uIndex + ( 4 << 1 ) + 0 ];

	DISPLAY1_1 = inputdata [ uIndex + ( 3 << 1 ) + 1 ];
	DISPLAY2_1 = inputdata [ uIndex + ( 4 << 1 ) + 1 ];

	SMODE2 = inputdata [ uIndex + ( 5 << 1 ) + 0 ];

	SMODE2_FFMD = SMODE2 & 2;
	SMODE2_INTER = SMODE2 & 1;
	
	//DISPFBX_FBP = ( DISPFBX_0 >> 0 ) & 0x1ff;
	//DISPFBX_FBW = ( DISPFBX_0 >> 9 ) & 0x3f;

	//DISPFBX_PSM = ( DISPFBX_0 >> 15 ) & 0x1f;

	//DISPFBX_DBX = ( DISPFBX >> 32 ) & 0x7ff;
	//DISPFBX_DBY = ( DISPFBX >> 43 ) & 0x7ff;
	//DISPLAYX_DH = ( DISPLAYX >> 44 ) & 0x7ff;
	//DISPFBX_DBX = ( DISPFBX_1 >> 0 ) & 0x7ff;
	//DISPFBX_DBY = ( DISPFBX_1 >> 11 ) & 0x7ff;
	//DISPLAYX_DH = ( DISPLAYX_1 >> 12 ) & 0x7ff;

	
	//draw_buffer_offset32 = int( DISPFBX_FBP << 11 );
	
	//draw_width = int( DISPFBX_FBW << 6 );
	//draw_height = int( DISPLAYX_DH + 1 );
	//start_x = int( DISPFBX_DBX );
	//start_y = int( DISPFBX_DBY );
	


	DISPFB1_FBP = ( DISPFB1_0 >> 0 ) & 0x1ff;
	DISPFB1_FBW = ( DISPFB1_0 >> 9 ) & 0x3f;
	DISPFB1_PSM = ( DISPFB1_0 >> 15 ) & 0x1f;

	//DISPFB1_DBX = ( DISPFB1 >> 32 ) & 0x7ff;
	//DISPFB1_DBY = ( DISPFB1 >> 43 ) & 0x7ff;
	//DISPLAY1_DH = ( DISPLAY1 >> 44 ) & 0x7ff;
	DISPFB1_DBX = ( DISPFB1_1 >> 0 ) & 0x7ff;
	DISPFB1_DBY = ( DISPFB1_1 >> 11 ) & 0x7ff;
	DISPLAY1_DH = ( DISPLAY1_1 >> 12 ) & 0x7ff;


	DISPFB2_FBP = ( DISPFB2_0 >> 0 ) & 0x1ff;
	DISPFB2_FBW = ( DISPFB2_0 >> 9 ) & 0x3f;
	DISPFB2_PSM = ( DISPFB2_0 >> 15 ) & 0x1f;

	//DISPFB2_DBX = ( DISPFB2 >> 32 ) & 0x7ff;
	//DISPFB2_DBY = ( DISPFB2 >> 43 ) & 0x7ff;
	//DISPLAY2_DH = ( DISPLAY2 >> 44 ) & 0x7ff;
	DISPFB2_DBX = ( DISPFB2_1 >> 0 ) & 0x7ff;
	DISPFB2_DBY = ( DISPFB2_1 >> 11 ) & 0x7ff;
	DISPLAY2_DH = ( DISPLAY2_1 >> 12 ) & 0x7ff;

	// make sure that framebuffer has some width and height to it before drawing it
	if ( ( ( PMODE & 1 ) != 0 ) && ( DISPFB1_FBW != 0 ) && ( DISPLAY1_DH != 0 ) )
	{

		// display 1 //
		
		draw_buffer_offset32 = int( DISPFB1_FBP ) << 11;
		
		//buf_ptr = & ( RAM32 [ draw_buffer_offset ] );
		
		draw_width = int( DISPFB1_FBW ) << 6;
		draw_height = int( DISPLAY1_DH ) + 1;
		start_x = int( DISPFB1_DBX );
		start_y = int( DISPFB1_DBY );
		
		//buf_ptr32 = buf_ptr;
		//buf_ptr16 = (u16*) buf_ptr;
		
		PixelFormat = int( DISPFB1_PSM );
		
	}
	else if ( ( PMODE & 2 ) != 0 )
	{
		// display 2 //
		
		draw_buffer_offset32 = int( DISPFB2_FBP ) << 11;
		
		//buf_ptr = & ( RAM32 [ draw_buffer_offset ] );
		
		draw_width = int( DISPFB2_FBW ) << 6;
		draw_height = int( DISPLAY2_DH ) + 1;
		start_x = int( DISPFB2_DBX );
		start_y = int( DISPFB2_DBY );
		
		//buf_ptr32 = buf_ptr;
		//buf_ptr16 = (u16*) buf_ptr;
		
		PixelFormat = int( DISPFB2_PSM );
		
	}
	else
	{
		return;
	}

	
	
	// draw height can only be a maximum of 1024
	draw_height = ( ( draw_height > c_iScreen_MaxHeight ) ? c_iFrameBuffer_DisplayHeight : draw_height );
	
	// draw width can only be a maximum of 1024
	draw_width = ( ( draw_width > c_iScreen_MaxWidth ) ? c_iFrameBuffer_DisplayWidth : draw_width );


	// start on first line in pixel buffer
	ipixelbuffer32 = 0;

	// the offset is two times further because of the data arrangement in shader
	draw_buffer_offset32 <<= 1;
	
#ifdef ENABLE_PIXELBUF_INTERLACING
	// if set to read every line, then half draw height for now
	// *todo* need to take into account whether interlaced or not
	// comment this out to show correct screen at top for now
	//if ( GPURegs0.SMODE2.FFMD ) draw_height >>= 1;
	// check if this is set to read every line
	if ( ( SMODE2_FFMD != 0 ) && ( SMODE2_INTER != 0 ) )
	{
		// only draw half the draw height for now
		draw_height >>= 1;
		
		// set to read every line, so need to skip lines when writing to pixel buffer for interlacing
		if ( ( lScanline & 1 ) != 0 )
		{
			//Index += draw_width;
			ipixelbuffer32 += draw_width;
		}
	}
#endif

	
	
	// draw starting from correct position
	//buf_ptr = buf_ptr [ start_x + ( start_y * draw_width ) ];
	
	// testing
	//start_x = 0;
	//start_y = 0;


	// needs to synchronize gpu core before proceeding
	barrier ();


	// pad on the bottom with zeros if needed for now
#ifdef DRAW_SCREEN_VECTOR_NEW

	iCount = draw_width * start_y;
	iCount >>= 2;
	Index = ( ipixelbuffer32 >> 2 ) + xxid;
	for ( x = xxid; x < iCount; x += xxinc )
	{
		pixel4buffer32 [ Index ] = ivec4( 0 );
		Index += xxinc;
	}

	//y = start_y;
	ipixelbuffer32 += iCount;

#else
	y = 0;
	while ( y < start_y )
	{
#ifdef DRAW_SCREEN_VECTOR
		Index = ipixelbuffer32 + (xxid<<2);
		for ( x = (xxid<<2); x < draw_width; x += (xxinc<<2) )
		{
			//pixelbuffer32 [ Index ] = 0;
			pixel4buffer32 [ Index >> 2 ] = vZero;
			Index += (xxinc<<2);
		}
#else
		Index = ipixelbuffer32 + xxid;
		//for ( x = 0; x < draw_width; x++ )
		for ( x = xxid; x < draw_width; x += xxinc )
		{
			//PixelBuffer [ Index++ ] = 0;
			pixelbuffer32 [ Index ] = 0;
			Index += xxinc;
		}
#endif
		
		y++;
		ipixelbuffer32 += draw_width;
	} // end while ( y < start_y )

#endif

			
#ifdef DRAW_SCREEN_VECTOR_NEW2

#ifdef ENABLE_PIXELBUF_INTERLACING
			// if reading every other line, only copy every other line to pixel buffer
			iStride = draw_width;
			if ( ( SMODE2_FFMD != 0 ) && ( SMODE2_INTER != 0 ) )
			{
				//ipixelbuffer32 += draw_width;
				iStride = draw_width << 1;
			}
#endif


	iCount = ( draw_height - start_y ) * draw_width;
	iCount = max( iCount, 0 );
	if ( PixelFormat < 2 )
	{
		for ( ivIndex = ( xxid << 2 ) + ivec4( 0, 1, 2, 3 ); ivIndex.w < iCount; ivIndex += xxinc << 2 )
		{
			vx = ivIndex % draw_width;
			vy = ivIndex / draw_width;

			vy2 = ( draw_height - 1 ) - vy;

			// anything before the start x gets blacked out
			vMask = ~( ( vx - start_x ) >> 31 );

			//yoffset32 = LUT_YOFFSET [ ( y & 0x1f ) ];
			vIdx = vy2 & 0x1f;
			//vyoffset32 = ivec4( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ], LUT_YOFFSET [ vIdx.z ], LUT_YOFFSET [ vIdx.w ] );
			vyoffset32.x = LUT_YOFFSET [ vIdx.x ];
			vyoffset32 += ( vy2 & ~0x1f ) * ( draw_width );

			//xoffset32 = LUT_XOFFSET [ ( x & 0x0fff ) ];
			vIdx = vx & 0x0fff;
			//vxoffset32 = ivec4( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ], LUT_XOFFSET [ vIdx.z ], LUT_XOFFSET [ vIdx.w ] );
			vxoffset32.x = LUT_XOFFSET [ vIdx.x ];
			voffset32 = vyoffset32 + ( vxoffset32 );
			voffset32 <<= 1;
			voffset32 += ( draw_buffer_offset32 );

			//Pixel32_0 = VRAM [ offset32 ] & 0xffff;
			//Pixel32_1 = VRAM [ offset32 + 1 ];
			//Pixel32 = Pixel32_0 | ( Pixel32_1 << 16 );

			// load pixels
			//vPixel0.xy = VRAM2 [ voffset32.x >> 1 ];
			//vPixel0.zw = VRAM2 [ voffset32.y >> 1 ];
			//vPixel1.xy = VRAM2 [ voffset32.z >> 1 ];
			//vPixel1.zw = VRAM2 [ voffset32.w >> 1 ];
			vPixel0 = VRAM4 [ ( voffset32.x >> 2 ) + 0 ];
			vPixel1 = VRAM4 [ ( voffset32.x >> 2 ) + 2 ];

			// combine
			vPixel0.xy = bitfieldInsert( vPixel0.xz, vPixel0.yw, 16, 16 );
			vPixel0.zw = bitfieldInsert( vPixel1.xz, vPixel1.yw, 16, 16 );

			// mask
			vPixel0 &= vMask;

			Index = ipixelbuffer32 + vx.x + ( vy.x * iStride );

			// store
			pixel4buffer32 [ Index >> 2 ] = vPixel0;
			
			//_GPU->PixelBuffer [ Index++ ] = Pixel32;
			//pixelbuffer32 [ Index ] = Pixel32;
			//Index += xxinc;
		}
	}
	else
	{

	}

#else
	
	//if ( DISPFBX_PSM < 2 )
	if ( PixelFormat < 2 )
	{
		// 24/32-bit pixels in frame buffer //
		
		// copy the pixels into pixel buffer
		for ( y = draw_height - 1; y >= start_y; y-- )
		{
			// get the y-offset for row
			yoffset32 = LUT_YOFFSET [ ( y & 0x1f ) ];
			yoffset32 += ( y & ~0x1f ) * ( draw_width );

			Index = ipixelbuffer32 + xxid;
			for ( x = start_x + xxid; x < draw_width; x += xxinc )
			{
				// calculate xoffset
				xoffset32 = LUT_XOFFSET [ ( x & 0x0fff ) ];
				offset32 = yoffset32 + ( xoffset32 );
				offset32 <<= 1;
				offset32 += ( draw_buffer_offset32 );


				//Pixel32 = buf_ptr32 [ CvtAddrPix32( x, y, draw_width ) ];
				Pixel32_0 = VRAM [ offset32 ] & 0xffff;
				Pixel32_1 = VRAM [ offset32 + 1 ];
				Pixel32 = Pixel32_0 | ( Pixel32_1 << 16 );
				
				//_GPU->PixelBuffer [ Index++ ] = Pixel32;
				pixelbuffer32 [ Index ] = Pixel32;
				Index += xxinc;
			}
			
			// pad on the right with zeros if needed for now
			//x = 0;
			//while ( x < start_x )
			while ( x < ( start_x + draw_width ) )
			{
				//_GPU->PixelBuffer [ Index++ ] = 0;
				pixelbuffer32 [ Index ] = 0;

				//x++;
				x += xxinc;
				Index += xxinc;
			}

			// goto next line
			ipixelbuffer32 += draw_width;
			
#ifdef ENABLE_PIXELBUF_INTERLACING
			// if reading every other line, only copy every other line to pixel buffer
			if ( ( SMODE2_FFMD != 0 ) && ( SMODE2_INTER != 0 ) )
			{
				//Index += draw_width;
				ipixelbuffer32 += draw_width;
			}
#endif

		}
	}
	else
	{
		// assume 16-bit pixels for frame buffer for now //
		
		FPSM = ( PixelFormat >> 1 );
		
		//for ( y = start_y + ( draw_height - 1 ); y >= start_y; y-- )
		for ( y = draw_height - 1; y >= start_y; y-- )
		{
			// get the y-offset for row
			yoffset32 = LUT_YOFFSET [ ( FPSM << 7 ) | ( y & 0x3f ) ];
			yoffset32 += ( y & ~0x3f ) * ( draw_width );

			Index = ipixelbuffer32 + xxid;
			//for ( x = start_x; x < draw_width; x++ )
			for ( x = start_x + xxid; x < draw_width; x += xxinc )
			{
				//switch( PixelFormat )
				//{
				//	case 2:
				//		Pixel16 = buf_ptr16 [ CvtAddrPix16( x, y, draw_width ) ];
				//		break;
				//		
				//	case 0xa:
				//		Pixel16 = buf_ptr16 [ CvtAddrPix16S( x, y, draw_width ) ];
				//		break;
				//}

				// calculate xoffset
				xoffset32 = LUT_XOFFSET [ ( FPSM << 12 ) | ( x & 0x0fff ) ];
				offset32 = yoffset32 + ( xoffset32 );
				//offset32 <<= 1;
				offset32 += ( draw_buffer_offset32 );

				Pixel32_0 = VRAM [ offset32 ] & 0xffff;

				Pixel32 = ( ( Pixel32_0 & 0x1f ) << 3 ) | ( ( ( Pixel32_0 >> 5 ) & 0x1f ) << ( 8 + 3 ) ) | ( ( ( Pixel32_0 >> 10 ) & 0x1f ) << ( 16 + 3 ) );

				//_GPU->PixelBuffer [ Index++ ] = Pixel32;
				pixelbuffer32 [ Index ] = Pixel32;
				Index += xxinc;
			}
			
			// pad on the right with zeros if needed for now
			//x = 0;
			//while ( x < start_x )
			while ( x < ( start_x + draw_width ) )
			{
				//_GPU->PixelBuffer [ Index++ ] = 0;
				pixelbuffer32 [ Index ] = 0;

				//x++;
				x += xxinc;
				Index += xxinc;
			}
			
			// goto next line
			ipixelbuffer32 += draw_width;
			
#ifdef ENABLE_PIXELBUF_INTERLACING	
			// if reading every other line, only copy every other line to pixel buffer
			if ( ( SMODE2_FFMD != 0 ) && ( SMODE2_INTER != 0 ) )
			{
				//Index += draw_width;
				ipixelbuffer32 += draw_width;
			}
#endif

		}
		
	}
	

#endif


	
#ifdef ENABLE_PIXELBUF_INTERLACING	
	// for now, if interlaced, need to put the draw_height back
	if ( ( SMODE2_FFMD != 0 ) && ( SMODE2_INTER != 0 ) )
	{
		// only draw half the draw height for now
		draw_height <<= 1;
		
	}
#endif
	
	
		
	// *** output of pixel buffer to screen *** //


	// needs to synchronize gpu core before proceeding
	barrier ();

	//draw_texture ( VisibleArea_Width, VisibleArea_Height );
	draw_texture ( draw_width, draw_height );

	// that's going to be the end of the run, so no need to synchronize after that
	return;
}





void precompute_data ()
{
	//const int iDataCount = ( 1 << 16 );
	//const int iDataElementSize = 128;
	//const int iDataShift = 7;

	int xxid = int( gl_LocalInvocationIndex );

	uint uIdx;
	uint uIndex;

	uint Comm;

	// common object vars //

	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;

	uint PRIM;
	int FRAME;
	uint FBMSK;

	uint FST, ABE, FGE, PABE;
	uint FOGCOL;
	int FCR, FCG, FCB;

	int FBP;
	int FBW;
	int FPSM;

	int FrameBufferStartOffset32;
	int FrameBufferWidth_Pixels;

	uint TEST, ATE, ATST, AREF, AFAIL, DATE, DATM, ZTE, ZTST;
	int AFAIL_FBMASK, AFAIL_ZBMASK, ZTST_LESS, ZTST_GREATER, ZTST_EQUAL;
	int ATST_LESS, ATST_EQUAL, ATST_GREATER;
	bvec4 bvATST_LESS, bvATST_EQUAL, bvATST_GREATER;
	uvec4 uvAFAIL_PIXEL, uvAFAIL_ZPIXEL;

	uint ALPHA;
	uint ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX;
	//uint ALPHA_A_SELECT, ALPHA_B_SELECT, ALPHA_C_SELECT, ALPHA_D_SELECT;
	//uint ALPHA_A_AND, ALPHA_B_AND, ALPHA_C_AND, ALPHA_D_AND, ALPHA_C_OR;
	//uvec4 vALPHA_A_PIXEL, vALPHA_B_PIXEL, vALPHA_C_PIXEL, vALPHA_D_PIXEL;
	//uvec4 vAREF;

	int ZBUF;
	int ZBP;
	int ZPSM;
	int ZMSK;

	int ZBufferStartOffset32;

	int DRAWPSM, ZBUFPSM;

	uint FBA;

	int CLAMP_0, CLAMP_1;
	int WMS, WMT;
	int MINU, MAXU, MINV, MAXV;
	int TexY_And, TexY_Or, TexY_Min, TexY_Max;
	int TexX_And, TexX_Or, TexX_Min, TexX_Max;

	int AEM;
	int TEXA_0, TEXA_1;

	int TEX0_0, TEX0_1;
	int TBP0, TBW, TPSM, TW, TH;
	int TEXPSM;
	int TexWidth, TexHeight;
	int TexWidth_Mask, TexHeight_Mask;
	int TCC, TFX;
	int CBP, CPSM, CSM, CSA, CLD;
	int CLUTStartOffset32;

	int TextureBufferStartOffset32;
	int TextureBufferWidth_Pixels;

	int iAnd1, iShift1, iShift2, iAnd3, iShift3;


	int COLCLAMP;

	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint bgr32;
	int bgra, bgrr, bgrg, bgrb;

	ivec3 vx, vy, vu, vv;

	uvec4 vz;

	int z0, f0, rf0;
	vec3 vfs, vft;

	ivec2 dxdx;
	//int dudx;
	int dvdy;
	int Temp;
	int w;

	int LeftMostX, RightMostX, TopMostY, BottomMostY;
	int t0, t1, denominator;

	// triangle vars //

	ivec2 vdx;
	ivec2 vdxdy;

	ivec4 vr, vg, vb, va;
	int vdr, vdg, vdb, vda;

	int vdrdy, vdgdy, vdbdy, vdady;

	int drdx, dgdx, dbdx, dadx;
	double dzdx;
	double vdz;
	double vdzdy;

	uvec2 vdz2, vdzdy2, dzdx2;

	int dudx, dvdx, dfdx;
	float dsdx, dtdx, dqdx;

	int vdu, vdv, vdf;
	float vds, vdt, vdq;

	int vdudy, vdvdy, vdfdy;
	float vdsdy, vdtdy, vdqdy;

	//ivec3 vu, vv;
	ivec3 vf;
	vec3 vs, vt, vq;


	ivec4 vrgba0, vrgba1, vrgba2;
	ivec3 vuvf0, vuvf1, vuvf2;
	vec3 vstq0, vstq1, vstq2;

	ivec4 drgbadx;
	ivec3 duvfdx;
	vec3 dstqdx;

	ivec4 vdrgbady;
	ivec3 vduvfdy;
	vec3 vdstqdy;

	ivec4 vdrgba;
	ivec3 vduvf;
	vec3 vdstq;

	uvec4 Coord;

	int iATOffset, iATMask;
	int iZTOffset;

	int bDraw;


	// loop through data

	do
	{
		uIndex = ( xxid & PRECOMPUTE_LIST_MASK ) << 6;
		uIdx = ( xxid & PRECOMPUTE_LIST_MASK ) << 7;

#ifdef PRECALC_COMMON_VARS

		// pre compute common data //

		PRIM = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		FST = ( PRIM >> 8 ) & 1;
		ABE = ( PRIM >> 6 ) & 1;
		FGE = ( PRIM >> 5 ) & 1;


		// pixel set //

		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ];
		FBA = ( FBA & 1 ) << 31;

		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		DrawArea_OffsetX = int( inputdata [ uIndex + ( 0 << 1 ) + 0 ] ) & 0xffff;
		DrawArea_OffsetY = int( inputdata [ uIndex + ( 0 << 1 ) + 1 ] ) & 0xffff;

		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		DrawArea_TopLeftY &= 0x7ff;


	bDraw = 1;

	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	

	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}


		// frame buffer //

		FRAME = int( inputdata [ uIndex + ( 2 << 1 ) + 0 ] );
		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];

		FBP = FRAME & 0x1ff;
		FBW = ( FRAME >> 16 ) & 0x3f;
		FPSM = ( FRAME >> 24 ) & 0x3f;

		// the offset is two times further because of the data arrangement in shader
		FrameBufferStartOffset32 = FBP << 11;
		FrameBufferStartOffset32 <<= 1;

		FrameBufferWidth_Pixels = FBW << 6;

		DRAWPSM = FPSM >> 1;


		// z-buffer //

		ZBUF = int( inputdata [ uIndex + ( 3 << 1 ) + 0 ] );
		ZBP = ZBUF & 0x1ff;
		ZPSM = ( ZBUF >> 24 ) & 0xf;
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) & 1;

		ZBufferStartOffset32 = ZBP << 11;
		ZBufferStartOffset32 <<= 1;

		// add on the missing bits for the zpsm
		ZPSM |= 0x30;

		ZBUFPSM = ZPSM >> 1;


	// pixel test //

	// pixel test
	TEST = inputdata [ uIndex + ( 5 << 1 ) + 0 ];


	// destination alpha test
	DATE = ( ( TEST >> 14 ) & 1 ) << 31;
	DATM = ( ( TEST >> 15 ) & 1 ) << 31;
	
	// depth test
	ZTE = ( TEST >> 16 ) & 1;
	ZTST = ( TEST >> 17 ) & 0x3;

	// alpha test
	ATE = TEST & 1;
	ATST = ( TEST >> 1 ) & 0x7;
	AREF = ( TEST >> 4 ) & 0xff;
	AFAIL = ( TEST >> 12 ) & 0x3;

	// initialize to RGB only on non-RGBA32 format
	AFAIL_FBMASK = -1;
	AFAIL_ZBMASK = -1;

	ATST_LESS = -1;
	ATST_EQUAL = -1;
	ATST_GREATER = -1;
	iATMask = -1;
	iATOffset = -2;
	if ( ATE != 0 )
	{
		// alpha test enabled //

		switch ( ATST )
		{
			// never pass
			case 0:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				iATOffset = 2;
				iATMask = -1;
				break;

			// always pass
			case 1:
				ATE = 0;
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				iATOffset = -2;
				iATMask = -1;
				break;

			// less
			case 2:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				iATOffset = 0;
				iATMask = -1;
				break;

			// less or equal
			case 3:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				iATOffset = -1;
				iATMask = -1;
				break;

			// equal
			case 4:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				iATOffset = -1;
				iATMask = 1;
				break;

			// greater or equal
			case 5:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				iATOffset = -0x80000000;
				iATMask = -1;
				break;

			// greater
			case 6:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				iATOffset = 0x7fffffff;
				iATMask = -1;
				break;

			// not equal
			case 7:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				iATOffset = 0x7fffffff;
				iATMask = 1;
				break;
		}

		switch ( AFAIL )
		{
			// keep/hold
			case 0:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = 0;
				break;

			// only update FB
			case 1:
				AFAIL_FBMASK = -1;
				AFAIL_ZBMASK = 0;
				break;

			// only update ZB
			case 2:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = -1;
				break;

			// only update rgb
			case 3:
				// only if format is RGBA32
				if ( FPSM == 0 )
				{
					AFAIL_FBMASK = 0x00ffffff;
					AFAIL_ZBMASK = 0;
				}
				break;
		}
	}

	// depth test
	ZTST_LESS = -1;
	ZTST_GREATER = -1;
	ZTST_EQUAL = -1;
	iZTOffset = 2;
	if ( ZTE != 0 )
	{
		// depth test enabled //

		switch( ZTST )
		{
			// never
			case 0:
				bDraw = 0;
				ZTST_LESS = 0;
				ZTST_GREATER = 0;
				ZTST_EQUAL = 0;
				iZTOffset = -2;
				break;

			// always
			case 1:
				ZTE = 0;
				ZTST_LESS = -1;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				iZTOffset = 2;
				break;

			// greater or equal
			case 2:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				iZTOffset = 1;
				break;

			// greater
			case 3:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = 0;
				iZTOffset = 0;
				break;
		}
	}


	// alpha blending //

	// blending per pixel
	PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;


	ALPHA = inputdata [ uIndex + ( 4 << 1 ) + 0 ];

	// no alpha blending if disabled
	ALPHA &= -ABE;

	ALPHA_A = ( ALPHA >> 0 ) & 0x3;
	ALPHA_B = ( ALPHA >> 2 ) & 0x3;
	ALPHA_C = ( ALPHA >> 4 ) & 0x3;
	ALPHA_D = ( ALPHA >> 6 ) & 0x3;
	ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;

	if ( ( ( ALPHA_A == ALPHA_B ) || ( ALPHA_FIX == 0 ) ) && ( ALPHA_D == 0 ) )
	{
		ABE = 0;
	}

	if ( ( ALPHA_A == 0 ) && ( ALPHA_B > 1 ) && ( ALPHA_FIX == 0x80 ) && ( ALPHA_D > 1 ) )
	{
		ABE = 0;
	}



	// texture buffer //

	// get the texture variabls
	TEX0_0 = int( inputdata [ uIndex + ( 7 << 1 ) + 0 ] );
	TEX0_1 = int( inputdata [ uIndex + ( 7 << 1 ) + 1 ] );

	TBP0 = ( TEX0_0 >> 0 ) & 0x3fff;

	TextureBufferStartOffset32 = ( TBP0 << 6 );
	TextureBufferStartOffset32 <<= 1;

	TBW = ( TEX0_0 >> 14 ) & 0x3f;

	TextureBufferWidth_Pixels = TBW << 6;

	TPSM = ( TEX0_0 >> 20 ) & 0x3f;

	TEXPSM = TPSM >> 1;

	TW = ( TEX0_0 >> 26 ) & 0xf;
	TH = ( ( TEX0_0 >> 30 ) & 0x3 ) | ( ( TEX0_1 & 0x3 ) << 2 );

	TexWidth = 1 << TW;
	TexHeight = 1 << TH;
	TexWidth_Mask = TexWidth - 1;
	TexHeight_Mask = TexHeight - 1;

	TCC = ( TEX0_1 >> 2 ) & 0x1;
	TFX = ( TEX0_1 >> 3 ) & 0x3;


	// color lookup table pixel format variables //

		//CBP = ( TEX0_1 >> 5 ) & 0x3fff;

		//CLUTStartOffset32 = ( CBP << 6 );
		//CLUTStartOffset32 <<= 1;

	CPSM = ( TEX0_1 >> 19 ) & 0xf;
	CSM = ( TEX0_1 >> 23 ) & 0x1;
	CSA = ( TEX0_1 >> 24 ) & 0x1f;
	CLD = ( TEX0_1 >> 29 ) & 0x7;

	
	// CLUT setup //
	
	if ( CSM == 0 )
	{
		// CSM1 //
		
		if ( ( CPSM & 0x2 ) != 0 )
		{
			// 4-bit pixels - 16 colors
			// 16-bit pixels in CLUT //
			CSA &= 0x1f;
		}
		else
		{
			// 32-bit pixels in CLUT //
			CSA &= 0xf;
		}
		
	}
	else
	{
		// CSM2 //
		
		// when these pixels load into temporary clut, they should be at index 0
		CSA = 0;
	}
	
	CSA <<= 4;
	//ptr_clut16 = & ( InternalCLUT [ CLUTOffset ] );

	// TEXA //

	TEXA_0 = int( inputdata [ uIndex + ( 6 << 1 ) + 0 ] );
	TEXA_1 = int( inputdata [ uIndex + ( 6 << 1 ) + 1 ] );

	AEM = ( TEXA_0 >> 15 ) & 1;
	AEM -= 1;
	TEXA_0 <<= 24;
	TEXA_1 <<= 24;




	// texture clamp //

	CLAMP_0 = int( inputdata [ uIndex + ( 14 << 1 ) + 0 ] );
	CLAMP_1 = int( inputdata [ uIndex + ( 14 << 1 ) + 1 ] );

	WMS = ( CLAMP_0 >> 0 ) & 0x3;
	WMT = ( CLAMP_0 >> 2 ) & 0x3;

	MINU = ( CLAMP_0 >> 4 ) & 0x3ff;
	MAXU = ( CLAMP_0 >> 14 ) & 0x3ff;

	MINV = ( ( CLAMP_0 >> 24 ) & 0xff ) | ( ( CLAMP_1 & 0x3 ) << 8 );
	MAXV = ( CLAMP_1 >> 2 ) & 0x3ff;

	switch ( WMT )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexY_And = TexHeight_Mask;
			
			TexY_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexY_Min = 0;
			TexY_Max = TexHeight_Mask;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexY_Min = MINV;
			TexY_Max = MAXV;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexY_And = MINV & TexHeight_Mask;
			TexY_Or = MAXV & TexHeight_Mask;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
	}

	
	switch ( WMS )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexX_And = TexWidth_Mask;
			
			TexX_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexX_Min = 0;
			TexX_Max = TexWidth_Mask;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexX_Min = MINU;
			TexX_Max = MAXU;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexX_And = MINU & TexWidth_Mask;
			TexX_Or = MAXU & TexWidth_Mask;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
	}


	// texture processing values //

	// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
	// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
	// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
	// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
	// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
	switch ( TPSM )
	{
		// PSMCT32
		// PSMCT24
		// PSMZ32
		// PSMZ24
		case 0x0:
		case 0x1:
		case 0x30:
		case 0x31:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = -1; iShift3 = 0;
			break;

		// PSMCT16
		// PSMCT16S
		// PSMZ16
		// PSMZ16S
		case 0x2:
		case 0xa:
		case 0x32:
		case 0x3a:
			iAnd1 = 0; iShift1 = 0; iShift2 = 1; iAnd3 = 0xffff; iShift3 = 0;
			break;

		// PSMT8
		case 0x13:
			iAnd1 = 1; iShift1 = 3; iShift2 = 2; iAnd3 = 0xff; iShift3 = 0;
			break;

		// PSMT4
		case 0x14:
			iAnd1 = 3; iShift1 = 2; iShift2 = 3; iAnd3 = 0xf; iShift3 = 0;
			break;

		// PSMT8H
		case 0x1b:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xff; iShift3 = 24;
			break;

		// PSMT4HL
		case 0x24:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 24;
			break;

		// PSMT4HH
		case 0x2c:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 28;
			break;
	}




	// texture fogging //

	FOGCOL = inputdata [ uIndex + ( 15 << 1 ) + 1 ];
	FCB = int( FOGCOL >> 0 ) & 0xff;
	FCG = int( FOGCOL >> 8 ) & 0xff;
	FCR = int( FOGCOL >> 16 ) & 0xff;

	// prepare f0, rf0
	// needs to be done before calculating dx
	//f0 = ( f0 >> 24 ) & 0xff;
	//rf0 = 0xff - f0;

		
	// store common object settings //

	// general:
	// bDraw
	// StartY, EndY
	// DRAWPSM, ZBUFPSM, FPSM, ZPSM
	// ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX
	// AREF, ATST_LESS, ATST_GREATER, ATST_EQUAL
	// AFAIL_FBMASK, AFAIL_ZBMASK
	// ZTST_LESS, ZTST_GREATER, ZTST_EQUAL
	// FBA, FBMSK, ZMSK, ABE, PABE
	// ZBufferStartOffset32, FrameBufferStartOffset32, FrameBufferWidth_Pixels
	// texture related:
	// iShift1, iShift2, iShift3, iAnd1, iAnd3
	// TexX_Min, TexX_Max, TexX_And, TexX_Or, TexY_Min, TexY_Max, TexY_And, TexY_Or
	// FGE, FCR, FCG, FCB
	// TEXPSM, TPSM, CPSM, TFX, TCC
	// AEM, TEXA_0, TEXA_1
	// TextureBufferStartOffset32, TextureBufferWidth_Pixels
	// sprite:
	// StartX, EndX, z0, w, u0, v0, f0, rf0, dudx, dvdy


		//data [ uIdx + 1 ] = COLCLAMP;
		//data [ uIdx + 2 ] = int( PABE );
		//data [ uIdx + 3 ] = int( FBA );
		data [ uIdx + 1 ] = FPSM;
		data [ uIdx + 2 ] = ZPSM;
		data [ uIdx + 3 ] = DRAWPSM;
		data [ uIdx + 4 ] = ZBUFPSM;
		data [ uIdx + 5 ] = FrameBufferStartOffset32;
		data [ uIdx + 6 ] = FrameBufferWidth_Pixels;
		data [ uIdx + 7 ] = ZBufferStartOffset32;
		//data [ uIdx + 11 ] = int( FBMSK );
		//data [ uIdx + 12 ] = ZMSK;
		data [ uIdx + 8 ] = AFAIL_FBMASK;
		data [ uIdx + 9 ] = AFAIL_ZBMASK;
		//data [ uIdx + 11 ] = int( ALPHA_FIX );
		data [ uIdx + 10 ] = int( ALPHA_A );
		data [ uIdx + 11 ] = int( ALPHA_B );
		data [ uIdx + 12 ] = int( ALPHA_C );
		data [ uIdx + 13 ] = int( ALPHA_D );
		data [ uIdx + 14 ] = int( AREF );

		//data [ uIdx + 15 ] = ATST_LESS;
		//data [ uIdx + 16 ] = ATST_GREATER;
		//data [ uIdx + 17 ] = ATST_EQUAL;
		data [ uIdx + 15 ] = iATMask;
		data [ uIdx + 16 ] = iATOffset;

		data [ uIdx + 18 ] = ZTST_LESS;
		data [ uIdx + 19 ] = ZTST_GREATER;
		data [ uIdx + 20 ] = ZTST_EQUAL;
		data [ uIdx + 21 ] = int( FGE );
		data [ uIdx + 22 ] = int( DATE );
		data [ uIdx + 23 ] = int( DATM );
		data [ uIdx + 24 ] = int( ABE );

		data [ uIdx + 95 ] = int( ZTE );
		data [ uIdx + 123 ] = int( ATE );

		// store common texture settings //

		data [ uIdx + 25 ] = TexX_Min;
		data [ uIdx + 26 ] = TexX_Max;
		data [ uIdx + 27 ] = TexX_And;
		data [ uIdx + 28 ] = TexX_Or;
		data [ uIdx + 29 ] = TexY_Min;
		data [ uIdx + 30 ] = TexY_Max;
		data [ uIdx + 31 ] = TexY_And;
		data [ uIdx + 32 ] = TexY_Or;
		data [ uIdx + 33 ] = TPSM;
		data [ uIdx + 34 ] = TEXPSM;
		data [ uIdx + 35 ] = TFX;
		data [ uIdx + 36 ] = TCC;
		data [ uIdx + 37 ] = CPSM;
		data [ uIdx + 38 ] = CSA;
		data [ uIdx + 39 ] = AEM;
		data [ uIdx + 40 ] = TEXA_0;
		data [ uIdx + 41 ] = TEXA_1;
		data [ uIdx + 42 ] = TextureBufferStartOffset32;
		data [ uIdx + 43 ] = TextureBufferWidth_Pixels;
		data [ uIdx + 44 ] = FCR;
		data [ uIdx + 45 ] = FCG;
		data [ uIdx + 46 ] = FCB;
		data [ uIdx + 47 ] = iShift1;
		data [ uIdx + 48 ] = iShift2;
		data [ uIdx + 49 ] = iShift3;
		data [ uIdx + 50 ] = iAnd1;
		data [ uIdx + 51 ] = iAnd3;

		data [ uIdx + 127 ] = int( FST );

#endif

		// handle rectange/sprite //

		if ( ( ( PRIM & 7 ) == 0 ) || ( ( PRIM & 7 ) == 6 ) )
		{
			// 2d object //

#ifdef PRECALC_SPRITE_VARS

			// get rgba from coord1 (last color value entered)
			bgr32 = inputdata [ uIndex + ( 25 << 1 ) + 0 ];

			// split into rgba
			//uvbgr32 = uvec4( bgr32 );
			bgra = int( bgr32 >> 24 ) & 0xff;
			bgrr = int( bgr32 >> 16 ) & 0xff;
			bgrg = int( bgr32 >> 8 ) & 0xff;
			bgrb = int( bgr32 >> 0 ) & 0xff;

			if ( TFX == 0 )
			{
				if ( TCC == 0 )
				{
					if ( ( bgr32 & 0x00ffffff ) == 0x00808080 )
					{
						TFX = 1;
					}
				}
				else
				{
					if ( ( bgr32 & 0xffffffff ) == 0x80808080 )
					{
						TFX = 1;
					}
				}
			}
			else
			{
				if ( ( bgr32 & 0xffffffff ) == 0x00808080 )
				{
					TFX = 1;
				}
			}

			// update TFX
			data [ uIdx + 35 ] = TFX;

			// coords //
			
			// get x0,y0 from coord1 (first coord entered)
			// x0,y0 are unsigned

			// get x1,y1 from coord0

			vx.y = int( inputdata [ uIndex + ( 20 << 1 ) + 0 ] );
			vx.x = int( inputdata [ uIndex + ( 24 << 1 ) + 0 ] );
			vy = ( vx >> 16 ) & 0xffff;
			vx &= 0xffff;


			// get z from coord1
			z0 = int( inputdata [ uIndex + ( 24 << 1 ) + 1 ] );
			f0 = int( inputdata [ uIndex + ( 27 << 1 ) + 0 ] );

			
			// get top left corner of sprite and bottom right corner of sprite
			vx -= DrawArea_OffsetX;
			vy -= DrawArea_OffsetY;


			// prepare f0, rf0
			f0 = ( f0 >> 24 ) & 0xff;
			rf0 = 0xff - f0;

			if ( FGE == 0 )
			{
				f0 = 0x100;
				rf0 = 0;
			}

			// need to do swap/scissor after texwidth/texheight //

			if ( FST != 0 )
			{
				// get u,v
				// coord0

				// coord1

				vu.y = int( inputdata [ uIndex + ( 22 << 1 ) + 0 ] );
				vu.x = int( inputdata [ uIndex + ( 26 << 1 ) + 0 ] );
				vv = ( vu >> 16 ) & 0x3fff;
				vu &= 0x3fff;
				
			}
			else
			{

				// put s,t coords into 10.4 fixed point
				// note: tex width/height should probably be minus one

				vu.y = int( inputdata [ uIndex + ( 22 << 1 ) + 0 ] );
				vv.y = int( inputdata [ uIndex + ( 22 << 1 ) + 1 ] );
				vu.x = int( inputdata [ uIndex + ( 26 << 1 ) + 0 ] );
				vv.x = int( inputdata [ uIndex + ( 26 << 1 ) + 1 ] );

				vfs = intBitsToFloat( vu );
				vft = intBitsToFloat( vv );

				vu.xy = ivec2( vfs.xy * float( TexWidth ) * 16.0f );
				vv.xy = ivec2( vft.xy * float( TexHeight ) * 16.0f );
			}


			// order coords so they go top to bottom and left to right
			if ( vx.y < vx.x )
			{
				// swap x,u coords
				vx.xy = vx.yx;
				vu.xy = vu.yx;
			}
			
			if ( vy.y < vy.x )
			{
				// swap y,v coords
				vy.xy = vy.yx;
				vv.xy = vv.yx;
			}


			// scissor test //
			
			StartX = ( vx.x + 0xf ) >> 4;
			EndX = ( vx.y - 1 ) >> 4;
			StartY = ( vy.x + 0xf ) >> 4;
			EndY = ( vy.y - 1 ) >> 4;


			// draw test //


			// check if sprite is within draw area
			if ( ( EndX < DrawArea_TopLeftX ) || ( StartX > DrawArea_BottomRightX ) || ( EndY < DrawArea_TopLeftY ) || ( StartY > DrawArea_BottomRightY ) )
			{
				bDraw = 0;
			}

			if ( ( vy.y < vy.x ) || ( vx.y < vx.x ) )
			{
				bDraw = 0;
			}


			// dx/dy values //

			

			dxdx = intdivfv2( ivec2( vu.y - vu.x, vv.y - vv.x), ivec2( vx.y - vx.x, vy.y - vy.x ), 4, 4, 16 );
			dudx = dxdx.x;
			dvdy = dxdx.y;


			vu <<= 12;
			vv <<= 12;

			// y clip/start //

			Temp = ( StartY << 4 ) - vy.x;

			if ( StartY < DrawArea_TopLeftY )
			{
				Temp += ( DrawArea_TopLeftY - StartY ) << 4;
				StartY = DrawArea_TopLeftY;
			}
			
			vv.x += ( dvdy >> 4 ) * Temp;
			//vv.x += ( dxdx.y >> 4 ) * Temp;
			
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY;
			}


			// x clip/start //
			
			Temp = ( StartX << 4 ) - vx.x;
			
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - StartX ) << 4;
				StartX = DrawArea_TopLeftX;
			}
			
			vu.x += ( dudx >> 4 ) * Temp;
			//vu.x += ( dxdx.x >> 4 ) * Temp;
			
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX;
			}


			// sprite:
			// StartX, EndX, z0, w, u0, v0, f0, rf0, dudx, dvdy

			w = EndX - StartX + 1;

			data [ uIdx + 0 ] = bDraw;

			data [ uIdx + 57 ] = StartY;
			data [ uIdx + 58 ] = EndY;
			data [ uIdx + 59 ] = StartX;
			data [ uIdx + 60 ] = EndX;
			data [ uIdx + 61 ] = w;
			data [ uIdx + 62 ] = z0;
			data [ uIdx + 63 ] = f0;
			data [ uIdx + 64 ] = rf0;
			data [ uIdx + 65 ] = vu.x;
			data [ uIdx + 66 ] = vv.x;
			data [ uIdx + 67 ] = dudx;
			data [ uIdx + 68 ] = dvdy;
			data [ uIdx + 69 ] = int( bgr32 );
			data [ uIdx + 70 ] = bgra;
			data [ uIdx + 71 ] = bgrr;
			data [ uIdx + 72 ] = bgrg;
			data [ uIdx + 73 ] = bgrb;

			data [ uIdx + 74 ] = int( ABE );

			//data [ uIdx + 75 ] = iATMask;
			//data [ uIdx + 76 ] = iATOffset;

#endif
		}
		else if ( ( PRIM & 7 ) <= 2 )
		{
			// line //

		}
		else if ( ( PRIM & 7 ) <= 5 )
		{
			// triangle //

#ifdef PRECALC_TRIANGLE_VARS

			// triangle coords //

			Coord.x = uIndex + ( 20 << 1 );
			Coord.y = uIndex + ( 24 << 1 );
			Coord.z = uIndex + ( 28 << 1 );

			// if mono triangle, then copy coord2 to all the colors
			if ( ( PRIM & 0x8 ) == 0 )
			{
				//inputdata [ Coord.x + 2 ] = inputdata [ Coord.z + 2 ];
				//inputdata [ Coord.y + 2 ] = inputdata [ Coord.z + 2 ];
				bgr32 = inputdata [ Coord.z + 2 ];
			}



			///////////////////////////////////
			// put top coordinates in x0,y0
			if ( inputdata [ Coord.y ] < inputdata [ Coord.x ] )
			{
				//Swap ( Coord0, Coord1 );
				Coord.xyz = Coord.yxz;
			}
			
			if ( inputdata [ Coord.z ] < inputdata [ Coord.x ] )
			{
				//Swap ( Coord2, Coord0 );
				Coord.xyz = Coord.zyx;
			}
			
			///////////////////////////////////////
			// put middle coordinates in x1,y1
			if ( inputdata [ Coord.z ] < inputdata [ Coord.y ] )
			{
				//Swap ( Coord2, Coord1 );
				Coord.xyz = Coord.xzy;
			}
			
			// get x,y

			vx.x = int( inputdata [ Coord.x ] );
			vx.y = int( inputdata [ Coord.y ] );
			vx.z = int( inputdata [ Coord.z ] );

			vy = ( vx >> 16 ) & 0xffff;
			vx &= 0xffff;
			
			// get z
			vz.x = inputdata [ Coord.x + 1 ];
			vz.y = inputdata [ Coord.y + 1 ];
			vz.z = inputdata [ Coord.z + 1 ];

			//***todo*** unsure of F is in upper or lower value ??
			vf.x = int( inputdata [ Coord.x + 6 ] );
			vf.y = int( inputdata [ Coord.y + 6 ] );
			vf.z = int( inputdata [ Coord.z + 6 ] );

			// shift fog value down
			vf = ( vf >> 24 ) & 0xff;

			// get r,g,b,a
			va.x = int ( inputdata [ Coord.x + 2 ] );
			va.y = int ( inputdata [ Coord.y + 2 ] );
			va.z = int ( inputdata [ Coord.z + 2 ] );

			// if mono triangle, then all the colors are the same
			if ( ( PRIM & 0x8 ) == 0 )
			{
				va = ivec4( bgr32 );

				// and can optimize texture function
				if ( TFX == 0 )
				{
					if ( TCC == 0 )
					{
						if ( ( bgr32 & 0x00ffffff ) == 0x00808080 )
						{
							TFX = 1;
						}
					}
					else
					{
						if ( ( bgr32 & 0xffffffff ) == 0x80808080 )
						{
							TFX = 1;
						}
					}
				}
				else
				{
					if ( ( bgr32 & 0xffffffff ) == 0x00808080 )
					{
						TFX = 1;
					}
				}

				// update TFX
				data [ uIdx + 35 ] = TFX;
			}

			vb = ( va >> 0 ) & 0xff;
			vg = ( va >> 8 ) & 0xff;
			vr = ( va >> 16 ) & 0xff;
			va = ( va >> 24 ) & 0xff;




			//////////////////////////////////////////
			// get coordinates on screen
			// *note* this is different from PS1, where you would add the offsets..
			
			vx -= DrawArea_OffsetX;
			vy -= DrawArea_OffsetY;


			// get the left/right most x
			LeftMostX = ( ( vx.x < vx.y ) ? vx.x : vx.y );
			LeftMostX = ( ( vx.z < LeftMostX ) ? vx.z : LeftMostX );
			RightMostX = ( ( vx.x > vx.y ) ? vx.x : vx.y );
			RightMostX = ( ( vx.z > RightMostX ) ? vx.z : RightMostX );
			
			LeftMostX >>= 4;
			RightMostX >>= 4;
			TopMostY = vy.x >> 4;
			BottomMostY = vy.z >> 4;


			// draw test //


			// check if sprite is within draw area
			if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) )
			{
				bDraw = 0;
			}




			if ( FST != 0 )
			{

				// get u,v
				// coord0
				vu.x = int( inputdata [ Coord.x + 4 ] );
				vu.y = int( inputdata [ Coord.y + 4 ] );
				vu.z = int( inputdata [ Coord.z + 4 ] );

				vv = ( vu >> 16 ) & 0x3fff;
				vu &= 0x3fff;
				
			}
			else
			{
				// *** TODO *** //

				// put s,t coords into 10.4 fixed point
				// note: tex width/height should probably be minus one
				vu.x = int( inputdata [ Coord.x + 4 ] );
				vu.y = int( inputdata [ Coord.y + 4 ] );
				vu.z = int( inputdata [ Coord.z + 4 ] );

				vv.x = int( inputdata [ Coord.x + 5 ] );
				vv.y = int( inputdata [ Coord.y + 5 ] );
				vv.z = int( inputdata [ Coord.z + 5 ] );

				vs = intBitsToFloat ( vu );
				vt = intBitsToFloat ( vv );

				// multiply by tex width/height
				vs *= float( TexWidth );
				vt *= float( TexHeight );

				vu.x = int( inputdata [ Coord.x + 3 ] );
				vu.y = int( inputdata [ Coord.y + 3 ] );
				vu.z = int( inputdata [ Coord.z + 3 ] );

				vq = intBitsToFloat ( vu );

			}

			// put the coords vertical

			vrgba0 = ivec4 ( vr.x, vg.x, vb.x, va.x );
			vrgba1 = ivec4 ( vr.y, vg.y, vb.y, va.y );
			vrgba2 = ivec4 ( vr.z, vg.z, vb.z, va.z );

			vstq0 = vec3 ( vs.x, vt.x, vq.x );
			vstq1 = vec3 ( vs.y, vt.y, vq.y );
			vstq2 = vec3 ( vs.z, vt.z, vq.z );

			vuvf0 = ivec3 ( vu.x, vv.x, vf.x << 4 );
			vuvf1 = ivec3 ( vu.y, vv.y, vf.y << 4 );
			vuvf2 = ivec3 ( vu.z, vv.z, vf.z << 4 );


			//t0 = vy[1] - vy[2];
			//t1 = vy[0] - vy[2];
			//denominator = ( ( vx[0] - vx[2] ) * t0 ) - ( ( vx[1] - vx[2] ) * t1 );
			t0 = vy.y - vy.z;
			t1 = vy.x - vy.z;
			denominator = ( ( vx.x - vx.z ) * t0 ) - ( ( vx.y - vx.z ) * t1 );
			
			// check if x1 is on left or right //
			
			// calculate across
			if ( denominator != 0 )
			{
				
				// result here should be in x.24 fixed point for now

				// colors //

				//drdx = ( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ) << 12 ) / denominator;
				//dgdx = ( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ) << 12 ) / denominator;
				//dbdx = ( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ) << 12 ) / denominator;
				//dadx = ( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ) << 12 ) / denominator;
				//drdx = intdivf2( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ), denominator, 4, 8, 16 );
				//dgdx = intdivf2( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ), denominator, 4, 8, 16 );
				//dbdx = intdivf2( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ), denominator, 4, 8, 16 );
				//dadx = intdivf2( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ), denominator, 4, 8, 16 );

				drgbadx = intdivfv4( ( ( ( vrgba0 - vrgba2 ) * t0 ) - ( ( vrgba1 - vrgba2 ) * t1 ) ), denominator, 4, 8, 16 );



				// u/v texture coords //

				//dudx = ( ( ( ( vu[0] - vu[2] ) * t0 ) - ( ( vu[1] - vu[2] ) * t1 ) ) << 8 ) / denominator;
				//dvdx = ( ( ( ( vv[0] - vv[2] ) * t0 ) - ( ( vv[1] - vv[2] ) * t1 ) ) << 8 ) / denominator;
				//dudx = intdivf2( ( ( ( vu[0] - vu[2] ) * t0 ) - ( ( vu[1] - vu[2] ) * t1 ) ), denominator, 8, 8, 16 );
				//dvdx = intdivf2( ( ( ( vv[0] - vv[2] ) * t0 ) - ( ( vv[1] - vv[2] ) * t1 ) ), denominator, 8, 8, 16 );

				// fog //

				//dfdx = ( ( ( ( vf[0] - vf[2] ) * t0 ) - ( ( vf[1] - vf[2] ) * t1 ) ) << 12 ) / denominator;
				//dfdx = intdivf2( ( ( ( vf[0] - vf[2] ) * t0 ) - ( ( vf[1] - vf[2] ) * t1 ) ), denominator, 4, 8, 16 );

				duvfdx = intdivfv3( ( ( ( vuvf0 - vuvf2 ) * t0 ) - ( ( vuvf1 - vuvf2 ) * t1 ) ), denominator, 8, 8, 16 );


				// s/t/q texture coords //

				//dsdx = ( ( ( vs[0] - vs[2] ) * ( float( t0 )/16.0 ) ) - ( ( vs[1] - vs[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
				//dtdx = ( ( ( vt[0] - vt[2] ) * ( float( t0 )/16.0 ) ) - ( ( vt[1] - vt[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
				//dqdx = ( ( ( vq[0] - vq[2] ) * ( float( t0 )/16.0 ) ) - ( ( vq[1] - vq[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
				//dsdx = ( ( ( ( vs[0] - vs[2] ) * ( float( t0 ) ) ) - ( ( vs[1] - vs[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;
				//dtdx = ( ( ( ( vt[0] - vt[2] ) * ( float( t0 ) ) ) - ( ( vt[1] - vt[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;
				//dqdx = ( ( ( ( vq[0] - vq[2] ) * ( float( t0 ) ) ) - ( ( vq[1] - vq[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;

				dstqdx = ( ( ( ( vstq0 - vstq2 ) * ( float( t0 ) ) ) - ( ( vstq1 - vstq2 ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;


				// z-value //

				// ***todo*** need to use a double here
				//dzdx = ( ( ( ( (s64) ( z0 - z2 ) ) * t0 ) - ( ( (s64) ( z1 - z2 ) ) * t1 ) ) << 27 ) / denominator;
				//dzdx = ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 )/16.0 ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 )/16.0 ) ) ) / ( double( denominator )/256.0 );
				dzdx = ( ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 ) ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 ) ) ) ) / ( double( denominator ) ) ) * 16.0;


				drdx = drgbadx.r;
				dgdx = drgbadx.g;
				dbdx = drgbadx.b;
				dadx = drgbadx.a;
				dudx = duvfdx.x;
				dvdx = duvfdx.y;
				dfdx = duvfdx.z;
				dsdx = dstqdx.x;
				dtdx = dstqdx.y;
				dqdx = dstqdx.z;
			}
			
			
			/////////////////////////////////////////////////
			// draw top part of triangle
			
			
			

			if ( ( vy.y - vy.x ) != 0 )
			{
				// triangle is pointed on top //

				// need to set the x0 index unconditionally
				//vdx [ X0Index ] = ( vx[0] << 12 );
				vdx.xy = vx.xx << 12;
				
				
				vdr = vr.x << 16;
				vdg = vg.x << 16;
				vdb = vb.x << 16;
				vda = va.x << 16;

				vdu = vu.x << 12;
				vdv = vv.x << 12;
				vdf = vf.x << 16;

				vds = vs.x;
				vdt = vt.x;
				vdq = vq.x;
				

				//vdrgba = vrgba0 << 16;
				//vduvf = vuvf0 << 12;
				//vdstq = vstq0;

				vdz = double( vz[0] );


				if ( denominator < 0 )
				{
					//vdxdy [ 0 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
					//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
					vdxdy.xy = intdivfv2( vx.yz - vx.xx, vy.yz - vy.xx, 4, 4, 16 );

					
					vdrdy = intdivf2(( vr.y - vr.x ), ( vy.y - vy.x ), 0, 4, 16 );
					vdgdy = intdivf2(( vg.y - vg.x ), ( vy.y - vy.x ), 0, 4, 16 );
					vdbdy = intdivf2(( vb.y - vb.x ), ( vy.y - vy.x ), 0, 4, 16 );
					vdady = intdivf2(( va.y - va.x ), ( vy.y - vy.x ), 0, 4, 16 );

					vdudy = intdivf2(( vu.y - vu.x ), ( vy.y - vy.x ), 4, 4, 16 );
					vdvdy = intdivf2(( vv.y - vv.x ), ( vy.y - vy.x ), 4, 4, 16 );
					vdfdy = intdivf2(( vf.y - vf.x ), ( vy.y - vy.x ), 0, 4, 16 );

					vdsdy = ( ( vs.y - vs.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
					vdtdy = ( ( vt.y - vt.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
					vdqdy = ( ( vq.y - vq.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
					

					//vdrgbady = intdivfv4( vrgba1 - vrgba0, vy.y - vy.x, 0, 4, 16 );
					//vduvfdy = intdivfv3( vuvf1 - vuvf0, vy.y - vy.x, 4, 4, 16 );
					//vdstqdy = ( ( vstq1 - vstq0 ) / ( float( vy.y - vy.x ) ) ) * 16.0f;

					vdzdy = ( ( double(vz[1]) - double(vz[0]) ) / ( double( vy[1] - vy[0] ) ) ) * 16.0;
				}
				else
				{
					//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
					//vdxdy [ 1 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
					vdxdy.xy = intdivfv2( vx.zy - vx.xx, vy.zy - vy.xx, 4, 4, 16 );

					
					vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
					vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
					vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
					vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

					vdudy = intdivf2(( vu.z - vu.x ), ( vy.z - vy.x ), 4, 4, 16 );
					vdvdy = intdivf2(( vv.z - vv.x ), ( vy.z - vy.x ), 4, 4, 16 );
					vdfdy = intdivf2(( vf.z - vf.x ), ( vy.z - vy.x ), 0, 4, 16 );

					vdsdy = ( ( vs.z - vs.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
					vdtdy = ( ( vt.z - vt.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
					vdqdy = ( ( vq.z - vq.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
					

					//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );
					//vduvfdy = intdivfv3( vuvf2 - vuvf0, vy.z - vy.x, 4, 4, 16 );
					//vdstqdy = ( ( vstq2 - vstq0 ) / ( float( vy.z - vy.x ) ) ) * 16.0f;

					vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
				}
				

			}
			else
			{
				// Triangle is flat on top //


				if ( denominator < 0 )
				{
					// x1 is on left //
					vdx.xy = vx.yx << 12;
					
					
					vdr = vr.y << 16;
					vdg = vg.y << 16;
					vdb = vb.y << 16;
					vda = va.y << 16;

					vdu = vu.y << 12;
					vdv = vv.y << 12;
					vdf = vf.y << 16;

					vds = vs.y;
					vdt = vt.y;
					vdq = vq.y;
					

					//vdrgba = vrgba1 << 16;
					//vduvf = vuvf1 << 12;
					//vdstq = vstq1;

					vdz = double( vz[1] );

					if ( ( vy.z - vy.y ) != 0 )
					{
						//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
						//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
						vdxdy.xy = intdivfv2( vx.zz - vx.yx, vy.zz - vy.yx, 4, 4, 16 );
						
						
						vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
						vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
						vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
						vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

						vdudy = intdivf2(( vu.z - vu.y ), ( vy.z - vy.y ), 4, 4, 16 );
						vdvdy = intdivf2(( vv.z - vv.y ), ( vy.z - vy.y ), 4, 4, 16 );
						vdfdy = intdivf2(( vf.z - vf.y ), ( vy.z - vy.y ), 0, 4, 16 );

						vdsdy = ( ( vs.z - vs.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
						vdtdy = ( ( vt.z - vt.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
						vdqdy = ( ( vq.z - vq.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
						

						//vdrgbady = intdivfv4( vrgba2 - vrgba1, vy.z - vy.y, 0, 4, 16 );
						//vduvfdy = intdivfv3( vuvf2 - vuvf1, vy.z - vy.y, 4, 4, 16 );
						//vdstqdy = ( ( vstq2 - vstq1 ) / ( float( vy.z - vy.y ) ) ) * 16.0f;

						vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;
					}
				}
				else
				{
					// x1 is on right //
					vdx.xy = vx.xy << 12;
					
					
					vdr = vr.x << 16;
					vdg = vg.x << 16;
					vdb = vb.x << 16;
					vda = va.x << 16;

					vdu = vu.x << 12;
					vdv = vv.x << 12;
					vdf = vf.x << 16;

					vds = vs.x;
					vdt = vt.x;
					vdq = vq.x;
					

					//vdrgba = vrgba0 << 16;
					//vduvf = vuvf0 << 12;
					//vdstq = vstq0;

					vdz = double( vz[0] );

					if ( ( vy.z - vy.y ) != 0 )
					{
						//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
						//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
						vdxdy.xy = intdivfv2( vx.zz - vx.xy, vy.zz - vy.xy, 4, 4, 16 );
						
						
						vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
						vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
						vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
						vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

						vdudy = intdivf2(( vu.z - vu.x ), ( vy.z - vy.x ), 4, 4, 16 );
						vdvdy = intdivf2(( vv.z - vv.x ), ( vy.z - vy.x ), 4, 4, 16 );
						vdfdy = intdivf2(( vf.z - vf.x ), ( vy.z - vy.x ), 0, 4, 16 );

						vdsdy = ( ( vs.z - vs.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
						vdtdy = ( ( vt.z - vt.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
						vdqdy = ( ( vq.z - vq.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
						

						//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );
						//vduvfdy = intdivfv3( vuvf2 - vuvf0, vy.z - vy.x, 4, 4, 16 );
						//vdstqdy = ( ( vstq2 - vstq0 ) / ( float( vy.z - vy.x ) ) ) * 16.0f;

						vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
					}
				}
				
			}



			// left point is included if points are equal
			StartY = ( vy.x + 0xf ) >> 4;
			EndY = ( vy.y - 1 ) >> 4;


			Temp = ( StartY << 4 ) - vy.x;

			if ( StartY < DrawArea_TopLeftY )
			{
				if ( EndY < DrawArea_TopLeftY )
				{
					Temp += ( EndY - StartY + 1 ) << 4;
					StartY = EndY + 1;
				}
				else
				{
					Temp += ( DrawArea_TopLeftY - StartY ) << 4;
					StartY = DrawArea_TopLeftY;
				}
			}
			
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY;
			}

			
			// dxdy is in .16, Temp is in .4, and x is in .16
			//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
			//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
			vdx += ( vdxdy >> 4 ) * Temp;
			
			
			vdr += ( vdrdy >> 4 ) * Temp;
			vdg += ( vdgdy >> 4 ) * Temp;
			vdb += ( vdbdy >> 4 ) * Temp;
			vda += ( vdady >> 4 ) * Temp;

			vdu += ( vdudy >> 4 ) * Temp;
			vdv += ( vdvdy >> 4 ) * Temp;

			vdf += ( vdfdy >> 4 ) * Temp;

			vds += ( vdsdy ) * ( float( Temp )/16.0f );
			vdt += ( vdtdy ) * ( float( Temp )/16.0f );
			vdq += ( vdqdy ) * ( float( Temp )/16.0f );
			

			//vdrgba += ( vdrgbady >> 4 ) * Temp;
			//vduvf += ( vduvfdy >> 4 ) * Temp;
			//vdstq += ( vdstqdy ) * ( float( Temp )/16.0f );

			// *** todo *** should be a double
			vdz += ( vdzdy ) * ( double( Temp )/16.0 );

			// triangle vars //

			data [ uIdx + 0 ] = bDraw;

			data [ uIdx + 52 ] = drdx;
			data [ uIdx + 53 ] = dgdx;
			data [ uIdx + 54 ] = dbdx;
			data [ uIdx + 55 ] = dadx;

			// split double and store
			dzdx2 = unpackDouble2x32( dzdx );

			data [ uIdx + 56 ] = dudx;
			data [ uIdx + 57 ] = dvdx;
			data [ uIdx + 58 ] = dfdx;

			data [ uIdx + 59 ] = int( dzdx2[0] );

			data [ uIdx + 60 ] = floatBitsToInt( dsdx );
			data [ uIdx + 61 ] = floatBitsToInt( dtdx );
			data [ uIdx + 62 ] = floatBitsToInt( dqdx );

			data [ uIdx + 63 ] = int( dzdx2[1] );


			// first set //

			data [ uIdx + 64 ] = StartY;
			data [ uIdx + 65 ] = EndY;

			data [ uIdx + 66 ] = vdx.x;
			data [ uIdx + 67 ] = vdx.y;

			data [ uIdx + 68 ] = vdr;
			data [ uIdx + 69 ] = vdg;
			data [ uIdx + 70 ] = vdb;
			data [ uIdx + 71 ] = vda;

			// split double and store
			vdz2 = unpackDouble2x32( vdz );

			data [ uIdx + 72 ] = vdu;
			data [ uIdx + 73 ] = vdv;
			data [ uIdx + 74 ] = vdf;

			data [ uIdx + 75 ] = int( vdz2[0] );

			data [ uIdx + 76 ] = floatBitsToInt( vds );
			data [ uIdx + 77 ] = floatBitsToInt( vdt );
			data [ uIdx + 78 ] = floatBitsToInt( vdq );

			data [ uIdx + 79 ] = int( vdz2[1] );


			data [ uIdx + 80 ] = vdxdy.x;
			data [ uIdx + 81 ] = vdxdy.y;

			// split double and store
			vdzdy2 = unpackDouble2x32( vdzdy );
			data [ uIdx + 82 ] = int( vdzdy2[0] );
			data [ uIdx + 83 ] = int( vdzdy2[1] );

			data [ uIdx + 84 ] = vdrdy;
			data [ uIdx + 85 ] = vdgdy;
			data [ uIdx + 86 ] = vdbdy;
			data [ uIdx + 87 ] = vdady;

			data [ uIdx + 88 ] = vdudy;
			data [ uIdx + 89 ] = vdvdy;
			data [ uIdx + 90 ] = vdfdy;

			data [ uIdx + 92 ] = floatBitsToInt( vdsdy );
			data [ uIdx + 93 ] = floatBitsToInt( vdtdy );
			data [ uIdx + 94 ] = floatBitsToInt( vdqdy );



			if ( denominator < 0 )
			{
				vdx.x = vx.y << 12;
				vdx.y = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.y >> 4 ) );
				
				vdr = vr.y << 16;
				vdg = vg.y << 16;
				vdb = vb.y << 16;
				vda = va.y << 16;

				vdu = vu.y << 12;
				vdv = vv.y << 12;

				vdf = vf.y << 16;

				vds = vs.y;
				vdt = vt.y;
				vdq = vq.y;

				vdz = double( vz[1] );

				
				if ( ( vy.z - vy.y ) != 0 )
				{
					// triangle is pointed on the bottom //
					vdxdy.x = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
					
					vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
					vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
					vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
					vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

					vdudy = intdivf2(( vu.z - vu.y ), ( vy.z - vy.y ), 4, 4, 16 );
					vdvdy = intdivf2(( vv.z - vv.y ), ( vy.z - vy.y ), 4, 4, 16 );

					vdfdy = intdivf2(( vf.z - vf.y ), ( vy.z - vy.y ), 0, 4, 16 );

					vdsdy = ( ( vs.z - vs.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
					vdtdy = ( ( vt.z - vt.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
					vdqdy = ( ( vq.z - vq.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;

					vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;

				}
				
			}
			else
			{
				vdx.y = vx.y << 12;
				vdx.x = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.x >> 4 ) );
				
				vdr = ( vr.x << 16 ) + ( ( vy.y - vy.x ) * ( vdrdy >> 4 ) );
				vdg = ( vg.x << 16 ) + ( ( vy.y - vy.x ) * ( vdgdy >> 4 ) );
				vdb = ( vb.x << 16 ) + ( ( vy.y - vy.x ) * ( vdbdy >> 4 ) );
				vda = ( va.x << 16 ) + ( ( vy.y - vy.x ) * ( vdady >> 4 ) );

				vdu = ( vu.x << 12 ) + ( ( vy.y - vy.x ) * ( vdudy >> 4 ) );
				vdv = ( vv.x << 12 ) + ( ( vy.y - vy.x ) * ( vdvdy >> 4 ) );

				vdf = ( vf.x << 16 ) + ( ( vy.y - vy.x ) * ( vdfdy >> 4 ) );

				vds = vs.x + ( (float( vy.y - vy.x )/16.0f) * vdsdy );
				vdt = vt.x + ( (float( vy.y - vy.x )/16.0f) * vdtdy );
				vdq = vq.x + ( (float( vy.y - vy.x )/16.0f) * vdqdy );

				vdz = double(vz[0]) + ( (double( vy.y - vy.x )/16.0) * vdzdy );

				if ( ( vy.z - vy.y ) != 0 )
				{
					// triangle is pointed on the bottom //
					vdxdy.y = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
				}
			}


			// left point is included if points are equal
			StartY = ( vy.y + 0xf ) >> 4;
			EndY = ( vy.z - 1 ) >> 4;


			Temp = ( StartY << 4 ) - vy.y;


			if ( StartY < DrawArea_TopLeftY )
			{
				if ( EndY < DrawArea_TopLeftY )
				{
					Temp += ( EndY - StartY + 1 ) << 4;
					StartY = EndY + 1;
				}
				else
				{
					Temp += ( DrawArea_TopLeftY - StartY ) << 4;
					StartY = DrawArea_TopLeftY;
				}
			}
			
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY;
			}

			
			// dxdy is in .16, Temp is in .4, and x is in .16
			//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
			//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
			vdx += ( vdxdy >> 4 ) * Temp;
			
			vdr += ( vdrdy >> 4 ) * Temp;
			vdg += ( vdgdy >> 4 ) * Temp;
			vdb += ( vdbdy >> 4 ) * Temp;
			vda += ( vdady >> 4 ) * Temp;

			vdu += ( vdudy >> 4 ) * Temp;
			vdv += ( vdvdy >> 4 ) * Temp;

			vdf += ( vdfdy >> 4 ) * Temp;

			vds += ( vdsdy ) * ( float( Temp )/16.0f );
			vdt += ( vdtdy ) * ( float( Temp )/16.0f );
			vdq += ( vdqdy ) * ( float( Temp )/16.0f );

			// *** todo *** should be a double
			vdz += ( vdzdy ) * ( double( Temp )/16.0 );


			// second set //

			data [ uIdx + 96 ] = StartY;
			data [ uIdx + 97 ] = EndY;

			data [ uIdx + 98 ] = vdx.x;
			data [ uIdx + 99 ] = vdx.y;

			data [ uIdx + 100 ] = vdr;
			data [ uIdx + 101 ] = vdg;
			data [ uIdx + 102 ] = vdb;
			data [ uIdx + 103 ] = vda;

			// split double and store
			vdz2 = unpackDouble2x32( vdz );

			data [ uIdx + 104 ] = vdu;
			data [ uIdx + 105 ] = vdv;
			data [ uIdx + 106 ] = vdf;

			data [ uIdx + 107 ] = int( vdz2[0] );

			data [ uIdx + 108 ] = floatBitsToInt( vds );
			data [ uIdx + 109 ] = floatBitsToInt( vdt );
			data [ uIdx + 110 ] = floatBitsToInt( vdq );

			data [ uIdx + 111 ] = int( vdz2[1] );


			data [ uIdx + 112 ] = vdxdy.x;
			data [ uIdx + 113 ] = vdxdy.y;

			// split double and store
			vdzdy2 = unpackDouble2x32( vdzdy );
			data [ uIdx + 114 ] = int( vdzdy2[0] );
			data [ uIdx + 115 ] = int( vdzdy2[1] );

			data [ uIdx + 116 ] = vdrdy;
			data [ uIdx + 117 ] = vdgdy;
			data [ uIdx + 118 ] = vdbdy;
			data [ uIdx + 119 ] = vdady;

			data [ uIdx + 120 ] = vdudy;
			data [ uIdx + 121 ] = vdvdy;
			data [ uIdx + 122 ] = vdfdy;

			data [ uIdx + 124 ] = floatBitsToInt( vdsdy );
			data [ uIdx + 125 ] = floatBitsToInt( vdtdy );
			data [ uIdx + 126 ] = floatBitsToInt( vdqdy );


#endif

		}



		// strictly for 3d objects //
	// -----------------------------------------------




	// -------------------------------------------




	// ---------------------------------------------

		


// -------------------------------------------------------
		
		//uIndex += ( xxinc << 6 );
		//uIdx += ( xxinc << 7 );

		xxid += xxinc;

	} while ( ( ( inputdata [ uIndex + ( 15 << 1 ) + 0 ] >> 24 ) != 0xff ) && ( xxid < PRECOMPUTE_LIST_SIZE ) );

	barrier ();
}






//void GPU::WriteInternalCLUT ( TEX0_t TEX02 )
void WriteInternalCLUT ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int lCLD, CLUTBufBase32, PixelFormat, CLUTPixelFormat, CLUTOffset, CLUTStoreMode;
	int clut_width, clut_x, clut_y;
	int lPixelCount, lPixelSize;
	
	int x, y;
	
	int lIndex;
	uint bgr;

	int offset32, xoffset32, yoffset32, yoffset32_xor;
	int TEX0_0, TEX0_1, TEXCLUT, TPSM, CBP, CPSM, CSM, CSA, CLD, CBW, COU, COV;
	int CBPX0, CBPX1;
	int CLUTPSM;
	
	//u16 *ptr_clut16;
	//u32 *ptr_clut32;
	

	uIndex <<= 6;

	TEX0_0 = int( inputdata[ uIndex + 0 ] );
	TEX0_1 = int( inputdata[ uIndex + 1 ] );

	TEXCLUT = int( inputdata[ uIndex + 2 ] );

	TPSM = ( TEX0_0 >> 20 ) & 0x3f;
	
	CBP = ( TEX0_1 >> 5 ) & 0x3fff;
	CPSM = ( TEX0_1 >> 19 ) & 0xf;
	CSM = ( TEX0_1 >> 23 ) & 0x1;
	CSA = ( TEX0_1 >> 24 ) & 0x1f;
	CLD = ( TEX0_1 >> 29 ) & 0x7;

	CBW = ( TEXCLUT >> 0 ) & 0x3f;
	COU = ( TEXCLUT >> 6 ) & 0x3f;
	COV = ( TEXCLUT >> 12 ) & 0x3ff;
	
	// check if psm is an indexed color format that requires CLUT
	//if ( ( ( TEX02.PSM >> 4 ) == 0 ) || ( ( TEX02.PSM >> 4 ) == 0x3 ) )
	if ( ( ( TPSM >> 4 ) == 0 ) || ( ( TPSM >> 4 ) == 0x3 ) )
	{
		// this is not an indexed pixel format so has nothing to do with CLUT
		return;
	}
	
	

	
	

	// ***TODO*** send palette to internal CLUT
	
	//TEX0_t *TEX0 = &GPURegsGp.TEX0_1;
	



	CBPX0 = CBPX2[0];
	CBPX1 = CBPX2[1];

	// check cld
	switch ( CLD )
	{
		case 0:
			// do not load into temp CLUT //
			return;
			break;
			
		case 1:
			// always load //
			break;
			
		case 2:
			// load and copy CBP to CBP0 //
			//CBP0 = CBP;
			CBPX0 = CBP;
			break;
			
		case 3:
			// load and copy CBP to CBP1 //
			//CBP1 = CBP;
			CBPX1 = CBP;
			break;
			
		case 4:
			// load and copy CBP to CBP0 only if CBP<>CBP0 //
			if ( CBP == CBPX0 ) 
			{
				return;
			}
			else
			{
				CBPX0 = CBP;
			}
			break;
			
		case 5:
			// load and copy CBP to CBP1 only if CBP<>CBP1 //
			if ( CBP == CBPX1 )
			{
				return;
			}
			else
			{
				CBPX1 = CBP;
			}
			break;

	}	// end switch ( CLD )

	

	// clut offset ??
	CLUTOffset = CSA;

	// the clut offset is actually CSA times 16 pixels
	CLUTOffset <<= 4;
	
	
	// get base pointer to color lookup table (32-bit word address divided by 64)
	CLUTBufBase32 = CBP << 6;

	// adjust for shader (32-bit vs 16-bit)
	CLUTBufBase32 <<= 1;

	// get pointer into CLUT in local memory
	//ptr_clut32 = & ( RAM32 [ CLUTBufBase32 ] );
	//ptr_clut16 = (u16*)ptr_clut32;
	
	
#ifdef USE_LOCAL_CLUT

	barrier ();

#endif
	

	if ( xxid == 0 )
	{
		CBPX2[0] = CBPX0;
		CBPX2[1] = CBPX1;
	}
	
	// transfer pixels

	// the lookup tables use this shifted right one
	CLUTPSM = CPSM >> 1;

	// need to know if pixels are 4/8-bit
	if ( ( TPSM & 7 ) > 2 )
	{
		// will need to write into the internal CLUT
		
		// get the number of pixels to transfer
		if ( ( TPSM & 0x4 ) != 0 )
		{
			// 4-bit pixels - 16 colors
			lPixelCount = 16;
			
		}
		else
		{
			// 8-bit pixels - 256 colors
			lPixelCount = 256;
			
		}

		
	
		if ( CSM == 0 )
		{
			// CSM1 //
			//CLUT_LUT = ucCLUT_Lookup_CSM01_4bpp;
			//CLUT_LUT = (u16*) ucCLUT_Lookup_CSM01;
			
			// need to determine size of pixels to transfer into clut
			// need to know if pixels are 16 or 32 bit
			if ( ( CPSM & 0x2 ) != 0 )
			{
				// 16-bit pixels //
				
				//for ( lIndex = xxid; lIndex < lPixelCount; lIndex++ )
				for ( lIndex = xxid; lIndex < lPixelCount; lIndex += xxinc )
				{
					x = ( lIndex & 0x7 ) | ( ( lIndex & 0x10 ) >> 1 );
					y = ( ( lIndex >> 4 ) & 0xe ) | ( ( lIndex >> 3 ) & 1 );

					yoffset32_xor = LUT_YOFFSET [ ( y & 0x7f ) | ( CLUTPSM << 7 ) ];
					//yoffset32 = ( clut_y & LUT_YNAND[ CLUTPSM ] ) * ( clut_width );

					xoffset32 = LUT_XOFFSET [ ( CLUTPSM << 12 ) | ( x & 0x0fff ) ];
					xoffset32 ^= yoffset32_xor;
					//xoffset32 += yoffset32;

					//offset32 <<= ( CPSM ^ 1 ) & 1;

					//offset32 += CLUTBufBase32;
					offset32 = xoffset32 + CLUTBufBase32;


					bgr = VRAM [ offset32 ];
					
					// 512-entry 16-bit pixels
					LOCAL_CLUT [ ( CLUTOffset + lIndex ) & 511 ] = bgr & 0xffff;
				}

			}
			else
			{
				// 32-bit pixels //
				
				// only 4-bits of Offset are valid
				CLUTOffset &= 255;
				
				// transfer pixels
				//for ( lIndex = xxid; lIndex < lPixelCount; lIndex++ )
				for ( lIndex = xxid; lIndex < lPixelCount; lIndex += xxinc )
				{
					x = ( lIndex & 0x7 ) | ( ( lIndex & 0x10 ) >> 1 );
					y = ( ( lIndex >> 4 ) & 0xe ) | ( ( lIndex >> 3 ) & 1 );

					yoffset32_xor = LUT_YOFFSET [ ( y & 0x7f ) | ( CLUTPSM << 7 ) ];
					//yoffset32 = ( clut_y & LUT_YNAND[ CLUTPSM ] ) * ( clut_width );

					xoffset32 = LUT_XOFFSET [ ( CLUTPSM << 12 ) | ( x & 0x0fff ) ];
					xoffset32 ^= yoffset32_xor;
					//xoffset32 += yoffset32;

					xoffset32 <<= 1;

					//offset32 += CLUTBufBase32;
					offset32 = xoffset32 + CLUTBufBase32;


					bgr = VRAM [ offset32 ];

					// 512-entry 16-bit pixels
					LOCAL_CLUT [ ( CLUTOffset + lIndex ) & 511 ] = bgr & 0xffff;

					bgr = VRAM [ offset32 + 1 ];

					// the upper part of buffer gets the high bits
					//LOCAL_CLUT [ ( CLUTOffset + lIndex + 256 ) & 511 ] = ( bgr >> 16 );
					LOCAL_CLUT [ ( CLUTOffset + lIndex + 256 ) & 511 ] = bgr & 0xffff;
				}
			}
		}
		else
		{
			// CSM2 //
			//CLUT_LUT = (u16*) ucCLUT_Lookup_CSM02;
			
			// CBW is in units of pixels/64
			clut_width = CBW << 6;
			
			// COU is in units of pixels/16
			clut_x = COU << 4;
			
			// get clut y in units of pixels
			clut_y = COV;
			
			// in CSM2 mode, the size of the pixels is always 16-bit and can only specify PSMCT16 //
			
			
			// 16-bit pixels //


			yoffset32_xor = LUT_YOFFSET [ ( clut_y & 0x7f ) | ( CLUTPSM << 7 ) ];
			yoffset32 = ( clut_y & LUT_YNAND[ CLUTPSM ] ) * ( clut_width );

			//for ( lIndex = xxid; lIndex < lPixelCount; lIndex++ )
			for ( lIndex = xxid; lIndex < lPixelCount; lIndex += xxinc )
			{
				xoffset32 = LUT_XOFFSET [ ( CLUTPSM << 12 ) | ( ( clut_x + lIndex ) & 0x0fff ) ];
				xoffset32 ^= yoffset32_xor;
				xoffset32 += yoffset32;
				//offset32 <<= 1;
				
				//offset32 += CLUTBufBase32;
				offset32 = xoffset32 + CLUTBufBase32;
				
				//bgr = ptr_clut16 [ CvtAddrPix16 ( clut_x + lIndex, clut_y, clut_width ) ];
				bgr = VRAM [ offset32 ];

				// 512-entry 16-bit pixels
				LOCAL_CLUT [ ( CLUTOffset + lIndex ) & 511 ] = bgr & 0xffff;
			}
		}
		
	}

#ifdef USE_LOCAL_CLUT

	barrier ();

#endif

}







/*
void Draw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7: GetBGR24 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetXY1 ( Buffer [ 2 ] );
//10: GetXY2 ( Buffer [ 3 ] );



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	//u32 NumPixels;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		
				
		
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;

	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
			////////////////////////////////////
			// get slopes
			
		iy = ( y0 << 16 ) + 0x8000;
		

		if ( line_length != 0 )
		{
			
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			dy <<= 8;

		}	// end if ( line_length )

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				
				iy += dy * Temp;
				StartX = DrawArea_TopLeftX;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		//}
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going up, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}	// end if ( dy <= 0 )
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}
		}	// end if ( dy >= 0 )
		
		
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		
		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftY && Line <= DrawArea_BottomRightY )

			}	// end if ( yid == 0 )
			
			//iy += dy;
			//iy += dy * xxinc;

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		if ( line_length != 0 )
		{
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			dx <<= 8;
		}
		
		//StartY = y0;
		//EndY = y1;
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				
				ix += dx * Temp;
				StartY = DrawArea_TopLeftY;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
		//}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

	
		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftX && Line <= DrawArea_BottomRightX )

			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )
	

	return;
}
*/

/*
void Draw_Line_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;




	
	
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//bgr32 = inputdata [ uIndex + 7 ];
		//bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		//gx [ 0 ] = int( ( inputdata [ 8 ].x << 5 ) >> 5 );
		//gy [ 0 ] = int( ( inputdata [ 8 ].y << 5 ) >> 5 );
		//gx [ 1 ] = int( ( inputdata [ 10 ].x << 5 ) >> 5 );
		//gy [ 1 ] = int( ( inputdata [ 10 ].y << 5 ) >> 5 );
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		


		

		
		gbgr [ 0 ] = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
		gbgr [ 1 ] = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;
		
		

		// get rgb-values
		r0 = gbgr [ Coord0 ] & 0xff;
		r1 = gbgr [ Coord1 ] & 0xff;

		g0 = ( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = ( gbgr [ Coord1 ] >> 8 ) & 0xff;

		b0 = ( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = ( gbgr [ Coord1 ] >> 16 ) & 0xff;

		
	
	iR = ( r0 << 16 ) + 0x8000;
	iG = ( g0 << 16 ) + 0x8000;
	iB = ( b0 << 16 ) + 0x8000;
	
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
		//ix = x0;
		iy = ( y0 << 16 ) + 0x8000;
		//x_right = x_left;
		
		
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			//dx = ( ( x1 - x0 ) << 16 ) / line_length;
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dy <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				StartX = DrawArea_TopLeftX;
				
				iy += dy * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}

		}
		
		oR = iR;
		oG = iG;
		oB = iB;
				
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{

			//Line = iy >> 16;
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			iR = oR + (( ix - StartX ) * dr);
			iG = oG + (( ix - StartX ) * dg);
			iB = oB + (( ix - StartX ) * db);

			// can optimize this some other time
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - ix ) & group_xmask;
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( ix & 3 ) + ( ( Line & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( yid == 0 )
			
			//iy += dy;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		//if ( y1 - y0 )
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			//dy = ( ( y1 - y0 ) << 16 ) / line_length;,
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dx <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}
		
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
				
				ix += dx * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

		oR = iR;
		oG = iG;
		oB = iB;

		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			//Line = ix >> 16;
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;

			iR = oR + (( iy - StartY ) * dr);
			iG = oG + (( iy - StartY ) * dg);
			iB = oB + (( iy - StartY ) * db);
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - iy ) & group_ymask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( Line & 3 ) + ( ( iy & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( xid == 0 )
			
			//ix += dx;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}


	}
	
	
	return;
}
*/






/*
uint Draw_Pixel_68 ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

	

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR24 ( Buffer [ 0 ] );
//8:GetXY ( Buffer [ 1 ] );


	
	
	uint DestPixel;

	int iPtr;

uint bgr16;
uint bgr32;

int w, h, xmax, ymax, ymax2;
int x, y;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;

uint PixelMask, SetPixelMask;


	uint Comm;
	int bDraw;

	uint uIdx;

	uIndex <<= 4;

	do
	{

	// set local variables
	//if ( (xid + yid) == 0 )
	//{

	
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//StartX = data [ uIdx + 8 ];
		//EndX = data [ uIdx + 9 ];
		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		x = data [ uIdx + 25 ];
		y = data [ uIdx + 26 ];
	
	if ( bDraw == 1 )
	{
	// align the compute units with pixels
	xid = ( ( ( cxid << group_xshift ) + group_x ) - x ) & group_xmask;
	yid = ( ( ( cyid << group_yshift ) + group_y ) - y ) & group_ymask;


	//if ( xxid == 0 )
	if ( xid + yid == 0 )
	{
		/////////////////////////////////////////
		// Draw the pixel

		// make sure we are putting pixel within draw area
		//if ( x >= DrawArea_TopLeftX && y >= DrawArea_TopLeftY && x <= DrawArea_BottomRightX && y <= DrawArea_BottomRightY )
		//{
			//ptr16 = & ( VRAM [ x + ( y << 10 ) ] );
			iPtr = x + ( y << 10 );
			
			// read pixel from frame buffer if we need to check mask bit
			DestPixel = VRAM [ iPtr ];
			
			// semi-transparency
			if ( Command_ABE != 0 )
			{
				bgr16 = SemiTransparency16 ( DestPixel, bgr16, GPU_CTRL_Read_ABR );
			}
			
			// check if we should set mask bit when drawing
			bgr16 |= SetPixelMask;

			// draw pixel if we can draw to mask pixels or mask bit not set
			DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr16 : DestPixel;
			VRAM [ iPtr ] = DestPixel;
		//}
	}	// end if ( xid + yid == 0 )

	}	// end if ( bDraw == 1 )
	
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( Comm >= 0x68 && Comm <= 0x6b ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

	return uIndex;
}
*/


#ifdef DRAW_RECTANGLE_MULTI
uint Draw_Rectangle ( uint uIndex )
#else
void Draw_Rectangle ( uint uIndex )
#endif
{
	// constants //

	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );


	// variables //

	int xid, yid;


	uint Comm;
	int bDraw;

	uint uIdx;


	int iPtr;
	ivec4 vPtr;
	
	int Temp;
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	uint bgr32;
	int x, y, w, h;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	//int x0, y0, x1, y1;
	uint z0, z1;


	int StartX;
	int EndX;
	int StartY;
	int EndY;


	uint PRIM;
	int FRAME;
	uint FBMSK;

	uint FST, ABE, FGE, PABE;

	int FBP;
	int FBW;
	int FPSM;

	int FrameBufferStartOffset32;
	int FrameBufferWidth_Pixels;

	int yoffset32, zyoffset32;
	int yoffset32_xor, zyoffset32_xor;
	ivec4 vXOffset32, vZXOffset32;

	uint TEST, ATE, ATST, AREF, AFAIL, DATE, DATM, ZTE, ZTST;
	uint AFAIL_FBMASK, AFAIL_ZBMASK, ZTST_LESS, ZTST_GREATER, ZTST_EQUAL;
	bvec4 bvATST_LESS, bvATST_EQUAL, bvATST_GREATER;
	int ATST_LESS, ATST_EQUAL, ATST_GREATER;

	uvec4 uvAFAIL_PIXEL, uvAFAIL_ZPIXEL;

	uint ALPHA;
	uint ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX;
	uint ALPHA_A_SELECT, ALPHA_B_SELECT, ALPHA_C_SELECT, ALPHA_D_SELECT;
	uint ALPHA_A_AND, ALPHA_B_AND, ALPHA_C_AND, ALPHA_D_AND, ALPHA_C_OR;
	uvec4 vALPHA_A_PIXEL, vALPHA_B_PIXEL, vALPHA_C_PIXEL, vALPHA_D_PIXEL;
	uvec4 vAREF;

	uvec4 vPixelA, vPixelB, vPixelC, vPixelD;
	ivec4 iva, ivb, ivc, ivd;

	int ZBUF;
	int ZBP;
	int ZPSM;
	int ZMSK;

	int ZBufferStartOffset32;

	uint FBA;


	ivec4 vIdx;
	ivec4 vIdx32;
	ivec4 vxid;
	ivec4 vx_across;
	ivec4 vOffset;
	ivec4 vZOffset;

	uvec4 vDestPixel16, vDestPixel32, vDestPixel32_0, vDestPixel32_1;
	uvec4 vZDestPixel16, vZDestPixel32, vZDestPixel32_0, vZDestPixel32_1;
	uvec4 vZDestPixel24_1;
	uvec4 vPixel32, vZPixel32;
	uvec4 vPixel24, vZPixel24;
	uvec4 vPixel32_0, vPixel32_1, vZPixel32_0, vZPixel32_1;
	uvec4 vPixel32_2;
	uvec4 vPixel16;
	uvec4 vMask, vMask32;
	ivec4 vPixelShift;

	uvec4 vDPixelX, vZPixelX;

	bvec4 bvALPHA_A_SELECT, bvALPHA_B_SELECT, bvALPHA_C_SELECT, bvALPHA_D_SELECT;
	ivec4 ivAlphaA, ivAlphaB, ivAlphaC, ivAlphaD;
	ivec4 ivRedA, ivRedB, ivRedC, ivRedD;
	ivec4 ivGreenA, ivGreenB, ivGreenC, ivGreenD;
	ivec4 ivBlueA, ivBlueB, ivBlueC, ivBlueD;

	//ivec4 ivATSelect, ivDASelect, ivZSelect;
	uvec4 uvATSelect, uvDASelect, uvZSelect;

	bvec4 bvZTST_LESS, bvZTST_GREATER, bvZTST_EQUAL;
	bvec4 bvTestMask;
	bvec4 bvEnable;
	uvec4 uvEnable;
	uvec4 uvZTST_EQUAL, uvZTST_GREATER;

	uvec4 vTestPixel32;

	int DRAWPSM, ZBUFPSM;

	ivec4 vav, vrv, vgv, vbv;
	ivec4 vaf, vrf, vgf, vbf;
	ivec4 vat, vrt, vgt, vbt;
	ivec4 va, vm;

	uvec4 uvbgr32;

	ivec2 vx, vy;

	int COLCLAMP;

	int DYNAND, ZYNAND;
	uvec4 uvALPHA_FIX;

	int iATOffset, iATMask;

	//uvec4 uvAlphaSelect [ 4 ];


	// *** setup *** //

		uIdx = uIndex << 7;
		uIndex <<= 6;

	
#ifdef DRAW_RECTANGLE_MULTI
	do
	{
#endif


#ifdef CALC_RECTANGLE_VARS

		// prim //

		PRIM = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		FST = ( PRIM >> 8 ) & 1;
		ABE = ( PRIM >> 6 ) & 1;
		FGE = ( PRIM >> 5 ) & 1;


		// pixel set //

		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ];
		FBA = ( FBA & 1 ) << 31;

		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		// fragment color //

		// get rgba from coord1 (last color value entered)
		bgr32 = inputdata [ uIndex + ( 25 << 1 ) + 0 ];

		// split into rgba
		uvbgr32 = uvec4( bgr32 );
		//vaf = ivec4( uvbgr32 >> 24 ) & 0xff;
		//vrf = ivec4( uvbgr32 >> 16 ) & 0xff;
		//vgf = ivec4( uvbgr32 >> 8 ) & 0xff;
		//vbf = ivec4( uvbgr32 >> 0 ) & 0xff;


		// coords //
		
		// get x0,y0 from coord1 (first coord entered)
		// x0,y0 are unsigned
		//x0 = int( inputdata [ uIndex + ( 24 << 1 ) + 0 ] );
		//y0 = ( x0 >> 16 ) & 0xffff;
		//x0 &= 0xffff;

		// get x1,y1 from coord0
		//x1 = int( inputdata [ uIndex + ( 20 << 1 ) + 0 ] );
		//y1 = ( x1 >> 16 ) & 0xffff;
		//x1 &= 0xffff;

		vx.y = int( inputdata [ uIndex + ( 20 << 1 ) + 0 ] );
		vx.x = int( inputdata [ uIndex + ( 24 << 1 ) + 0 ] );
		vy = ( vx >> 16 ) & 0xffff;
		vx &= 0xffff;

		// get z from coord1
		z0 = inputdata [ uIndex + ( 24 << 1 ) + 1 ];
		//f0 = int( inputdata [ uIndex + ( 27 << 1 ) + 1 ] );

		
		DrawArea_OffsetX = int( inputdata [ uIndex + ( 0 << 1 ) + 0 ] ) & 0xffff;
		DrawArea_OffsetY = int( inputdata [ uIndex + ( 0 << 1 ) + 1 ] ) & 0xffff;

		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		DrawArea_TopLeftY &= 0x7ff;

		
		// get top left corner of sprite and bottom right corner of sprite
		//x0 -= DrawArea_OffsetX;
		//y0 -= DrawArea_OffsetY;
		//x1 -= DrawArea_OffsetX;
		//y1 -= DrawArea_OffsetY;
		vx -= DrawArea_OffsetX;
		vy -= DrawArea_OffsetY;


	// order coords so they go top to bottom and left to right
	if ( vx.y < vx.x )
	{
		// swap x,u coords
		vx.xy = vx.yx;
	}
	
	if ( vy.y < vy.x )
	{
		// swap y,v coords
		vy.xy = vy.yx;
	}


		// scissor test //
		
		StartX = ( vx.x + 0xf ) >> 4;
		EndX = ( vx.y - 1 ) >> 4;
		StartY = ( vy.x + 0xf ) >> 4;
		EndY = ( vy.y - 1 ) >> 4;


		if ( StartY < DrawArea_TopLeftY )
		{
			StartY = DrawArea_TopLeftY;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY;
		}
		
		if ( StartX < DrawArea_TopLeftX )
		{
			StartX = DrawArea_TopLeftX;
		}
		
		if ( EndX > DrawArea_BottomRightX )
		{
			EndX = DrawArea_BottomRightX;
		}



		// frame buffer //

		FRAME = int( inputdata [ uIndex + ( 2 << 1 ) + 0 ] );
		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];

		FBP = FRAME & 0x1ff;
		FBW = ( FRAME >> 16 ) & 0x3f;
		FPSM = ( FRAME >> 24 ) & 0x3f;

		// the offset is two times further because of the data arrangement in shader
		FrameBufferStartOffset32 = FBP << 11;
		FrameBufferStartOffset32 <<= 1;

		FrameBufferWidth_Pixels = FBW << 6;

		DRAWPSM = FPSM >> 1;


		// z-buffer //

		ZBUF = int( inputdata [ uIndex + ( 3 << 1 ) + 0 ] );
		ZBP = ZBUF & 0x1ff;
		ZPSM = ( ZBUF >> 24 ) & 0xf;
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) & 1;

		ZBufferStartOffset32 = ZBP << 11;
		ZBufferStartOffset32 <<= 1;

		// add on the missing bits for the zpsm
		ZPSM |= 0x30;

		ZBUFPSM = ZPSM >> 1;


	// pixel test //

	// pixel test
	TEST = inputdata [ uIndex + ( 5 << 1 ) + 0 ];


	// destination alpha test
	DATE = ( ( TEST >> 14 ) & 1 ) << 31;
	DATM = ( ( TEST >> 15 ) & 1 ) << 31;
	
	// depth test
	ZTE = ( TEST >> 16 ) & 1;
	ZTST = ( TEST >> 17 ) & 0x3;

	// alpha test
	ATE = TEST & 1;
	ATST = ( TEST >> 1 ) & 0x7;
	AREF = ( TEST >> 4 ) & 0xff;
	AFAIL = ( TEST >> 12 ) & 0x3;

	// initialize to RGB only on non-RGBA32 format
	AFAIL_FBMASK = -1;
	AFAIL_ZBMASK = -1;

	ATST_LESS = -1;
	ATST_EQUAL = -1;
	ATST_GREATER = -1;
	if ( ATE != 0 )
	{
		// alpha test enabled //

		switch ( ATST )
		{
			// never pass
			case 0:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// always pass
			case 1:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// less
			case 2:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// less or equal
			case 3:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// equal
			case 4:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// greater or equal
			case 5:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// greater
			case 6:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;

			// not equal
			case 7:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;
		}

		switch ( AFAIL )
		{
			// keep/hold
			case 0:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = 0;
				break;

			// only update FB
			case 1:
				AFAIL_FBMASK = -1;
				AFAIL_ZBMASK = 0;
				break;

			// only update ZB
			case 2:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = -1;
				break;

			// only update rgb
			case 3:
				// only if format is RGBA32
				if ( FPSM == 0 )
				{
					AFAIL_FBMASK = 0x00ffffff;
					AFAIL_ZBMASK = 0;
				}
				break;
		}
	}

	// depth test
	ZTST_LESS = -1;
	ZTST_GREATER = -1;
	ZTST_EQUAL = -1;
	if ( ZTE != 0 )
	{
		// depth test enabled //

		switch( ZTST )
		{
			// never
			case 0:
				ZTST_LESS = 0;
				ZTST_GREATER = 0;
				ZTST_EQUAL = 0;
				break;

			// always
			case 1:
				ZTST_LESS = -1;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater or equal
			case 2:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater
			case 3:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = 0;
				break;
		}
	}


	// alpha blending //

	// blending per pixel
	PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;


	ALPHA = inputdata [ uIndex + ( 4 << 1 ) + 0 ];

	// no alpha blending if disabled
	ALPHA &= -ABE;

	ALPHA_A = ( ALPHA >> 0 ) & 0x3;
	ALPHA_B = ( ALPHA >> 2 ) & 0x3;
	ALPHA_C = ( ALPHA >> 4 ) & 0x3;
	ALPHA_D = ( ALPHA >> 6 ) & 0x3;
	ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;



	// draw test //

	bDraw = 1;


	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	

	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( EndX < DrawArea_TopLeftX || StartX > DrawArea_BottomRightX || EndY < DrawArea_TopLeftY || StartY > DrawArea_BottomRightY ) bDraw = 0; //return;

	if ( ( vy.y < vy.x ) || ( vx.y < vx.x ) )
	{
		bDraw = 0;
	}


	// dx/dy values //
	// none



	// y clip/start //

	Temp = ( StartY << 4 ) - vy.x;

	if ( StartY < DrawArea_TopLeftY )
	{
		Temp += ( DrawArea_TopLeftY - StartY ) << 4;
		StartY = DrawArea_TopLeftY;
	}
	
	if ( EndY > DrawArea_BottomRightY )
	{
		EndY = DrawArea_BottomRightY;
	}


	// x clip/start //
	
	Temp = ( StartX << 4 ) - vx.x;
	
	if ( StartX < DrawArea_TopLeftX )
	{
		Temp += ( DrawArea_TopLeftX - StartX ) << 4;
		StartX = DrawArea_TopLeftX;
	}
	
	if ( EndX > DrawArea_BottomRightX )
	{
		EndX = DrawArea_BottomRightX;
	}

	w = EndX - StartX + 1;

#endif


#ifdef LOAD_RECTANGLE_VARS
	bDraw = data [ uIdx + 0 ];
#endif

	if ( bDraw == 1 )
	{

#ifdef LOAD_RECTANGLE_VARS

		// load common vars //

		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) << 31;
		PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;
		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ] << 31;
		ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;
		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		//uvAlphaSelect [ 2 ] = ivec4( ALPHA_FIX );
		//uvAlphaSelect [ 3 ] = vZero;

		//COLCLAMP = data [ uIdx + 1 ];
		//PABE = data [ uIdx + 2 ];
		//FBA = data [ uIdx + 3 ];

		FPSM = data [ uIdx + 1 ];
		ZPSM = data [ uIdx + 2 ];
		DRAWPSM = data [ uIdx + 3 ];
		ZBUFPSM = data [ uIdx + 4 ];
		FrameBufferStartOffset32 = data [ uIdx + 5 ];
		FrameBufferWidth_Pixels = data [ uIdx + 6 ];
		ZBufferStartOffset32 = data [ uIdx + 7 ];
		
		//FBMSK = data [ uIdx + 8 ];
		//ZMSK = data [ uIdx + 9 ];
		
		AFAIL_FBMASK = data [ uIdx + 8 ];
		AFAIL_ZBMASK = data [ uIdx + 9 ];

		//ALPHA_FIX = data [ uIdx + 10 ];

		ALPHA_A = data [ uIdx + 10 ];
		ALPHA_B = data [ uIdx + 11 ];
		ALPHA_C = data [ uIdx + 12 ];
		ALPHA_D = data [ uIdx + 13 ];
		AREF = data [ uIdx + 14 ];
		ATST_LESS = data [ uIdx + 15 ];
		ATST_GREATER = data [ uIdx + 16 ];
		ATST_EQUAL = data [ uIdx + 17 ];
		ZTST_LESS = data [ uIdx + 18 ];
		ZTST_GREATER = data [ uIdx + 19 ];
		ZTST_EQUAL = data [ uIdx + 20 ];
		FGE = data [ uIdx + 21 ];
		DATE = data [ uIdx + 22 ];
		DATM = data [ uIdx + 23 ];
		ABE = data [ uIdx + 24 ];


		ZTE = data [ uIdx + 95 ];
		ATE = data [ uIdx + 123 ];

		// load rectangle vars //

		StartY = data [ uIdx + 57 ];
		EndY = data [ uIdx + 58 ];
		StartX = data [ uIdx + 59 ];
		EndX = data [ uIdx + 60 ];
		w = data [ uIdx + 61 ];
		z0 = uint( data [ uIdx + 62 ] );
		//f0 = data [ uIdx + 63 ];
		//rf0 = data [ uIdx + 64 ];
		//vu.x = data [ uIdx + 65 ];
		//vv.x = data [ uIdx + 66 ];
		//dudx = data [ uIdx + 67 ];
		//dvdy = data [ uIdx + 68 ];
		bgr32 = data [ uIdx + 69 ];
		//data [ uIdx + 70 ] = bgra;
		//data [ uIdx + 71 ] = bgrr;
		//data [ uIdx + 72 ] = bgrg;
		//data [ uIdx + 73 ] = bgrb;

		//vaf = ivec4( data [ uIdx + 70 ] );
		//vrf = ivec4( data [ uIdx + 71 ] );
		//vgf = ivec4( data [ uIdx + 72 ] );
		//vbf = ivec4( data [ uIdx + 73 ] );

		iATMask = data [ uIdx + 15 ];
		iATOffset = data [ uIdx + 16 ];

		uvbgr32 = uvec4( bgr32 );

#endif


	ivec2 vyoffset_xor;
	ivec2 vyoffset;
	ivec2 vdzpsm7;
	ivec2 vdzpsm12;
	ivec2 vdzpsm;
	ivec2 vdznand;
	ivec2 vstartoffset;

	DYNAND = LUT_YNAND[ DRAWPSM ];
	ZYNAND = LUT_YNAND[ ZBUFPSM ];
	//TYNAND = LUT_YNAND[ TEXPSM ];


	vdzpsm.x = ( DRAWPSM & 1 ) ^ 1;
	vdzpsm.y = ( ZBUFPSM & 1 ) ^ 1;

	vdzpsm7.x = DRAWPSM << 7;
	vdzpsm7.y = ZBUFPSM << 7;

	vdzpsm12.x = DRAWPSM << 12;
	vdzpsm12.y = ZBUFPSM << 12;

	vdznand.x = LUT_YNAND[ DRAWPSM ];
	vdznand.y = LUT_YNAND[ ZBUFPSM ];

	vstartoffset.x = FrameBufferStartOffset32;
	vstartoffset.y = ZBufferStartOffset32;


	vAREF = uvec4( AREF );
	uvALPHA_FIX = uvec4( ALPHA_FIX );

	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
	//vxid = ( vxid.w >= 0 ) ? vxid : ( vxid + group_vxinc );
	vxid = vxid + group_vxinc * ( ( vxid.w >> 31 ) & 1 );


	

	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		vIdx.xy = vdzpsm7.xy | ( Line & 0x3f );
		vyoffset_xor = ivec2( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ] );
		vyoffset = ( Line & vdznand ) * FrameBufferWidth_Pixels;

		/*
		// get the y-offset for row
		yoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( DRAWPSM << 7 ) ];
		yoffset32 = ( Line & LUT_YNAND[ DRAWPSM ] ) * ( FrameBufferWidth_Pixels );

		zyoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( ZBUFPSM << 7 ) ];
		zyoffset32 = ( Line & LUT_YNAND[ ZBUFPSM ] ) * ( FrameBufferWidth_Pixels );
		*/
		
		// draw horizontal line
		//for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
		for ( vx_across = vxid; vx_across.x < w; vx_across += group_vxinc )
		{
			// get pointer to pixel based on frame buffer pixel format (4-bit aligned offset) //

			// get the pixels to be drawn
			//bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
			usubBorrow( uvec4( vx_across ), uvec4( w ), uvEnable );

			// z value is z0
			vZPixel32 = uvec4( z0 );

			// calculate xoffset
			//vIdx = ( vx_across + StartX );
			vIdx.xy = ( ( vx_across.x + StartX ) & 0xfff ) | vdzpsm12.xy;
			vXOffset32.xy = ivec2( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ] );
			vXOffset32.xy ^= vyoffset_xor.xy;
			vOffset.xy = vXOffset32.xy + vyoffset.xy;
			vOffset.xy <<= vdzpsm.xy;
			vOffset.xy += vstartoffset.xy;

			vZOffset[0] = vOffset.y;


			// x-bit pixels //

			vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];

			// combine
			//vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			//vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );
			vDestPixel32.xy = bitfieldInsert( vDestPixel32_0.xz, vDestPixel32_0.yw, 16, 16 );
			vDestPixel32.zw = bitfieldInsert( vDestPixel32_1.xz, vDestPixel32_1.yw, 16, 16 );

			vDPixelX = vDestPixel32;

			// extract
			vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				//vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
				vDestPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vDestPixel32, 3, 5 ), bitfieldExtract( vDestPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vDestPixel32, 10, 5 ), 19, 5 ), bitfieldExtract( vDestPixel32, 15, 1 ), 31, 1 );
			}


			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );


			// x-bit zpixels //

			vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];

			// combine
			//vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			//vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );
			vZDestPixel32.xy = bitfieldInsert( vZDestPixel32_0.xz, vZDestPixel32_0.yw, 16, 16 );
			vZDestPixel32.zw = bitfieldInsert( vZDestPixel32_1.xz, vZDestPixel32_1.yw, 16, 16 );

			vZPixelX = vZDestPixel32;

			// extract
			vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );



			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );


			// load pixel to draw //

			vPixel32 = uvbgr32;



//#ifdef ENABLE_ALPHA_BLEND

		if ( ABE == 1 )
		{
			// alpha blend //


			// A pixel //

			// select
			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( uvec4( ALPHA_FIX ) & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );


			//uvAlphaSelect [ 0 ] = vPixel32;
			//uvAlphaSelect [ 1 ] = vDestPixel32;

			//vPixelA = uvAlphaSelect [ ALPHA_A ];
			//vPixelB = uvAlphaSelect [ ALPHA_B ];
			//vPixelC = uvAlphaSelect [ ALPHA_C ];
			//vPixelD = uvAlphaSelect [ ALPHA_D ];


			// perform alpha blend calculation //

			// get alpha
			//ivc = ivec4( vPixelC >> 24 ) & 0xff;
			ivc = ivec4( bitfieldExtract( vPixelC, 24, 8 ) );

			// do r
			//iva = ivec4( vPixelA >> 16 ) & 0xff;
			//ivb = ivec4( vPixelB >> 16 ) & 0xff;
			//ivd = ivec4( vPixelD >> 16 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 16, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 16, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 16, 8 ) );

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			//iva = ivec4( vPixelA >> 8 ) & 0xff;
			//ivb = ivec4( vPixelB >> 8 ) & 0xff;
			//ivd = ivec4( vPixelD >> 8 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 8, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 8, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 8, 8 ) );

			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			//iva = ivec4( vPixelA >> 0 ) & 0xff;
			//ivb = ivec4( vPixelB >> 0 ) & 0xff;
			//ivd = ivec4( vPixelD >> 0 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 0, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 0, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 0, 8 ) );

			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			//vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
			vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vPixel32, vrv, 16, 8 ), vgv, 8, 8 ), vbv, 0, 8 );


			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );

		}

//#endif

			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle

//#ifdef ENABLE_SRCALPHA_TEST
			// alpha test //

			vTestPixel32 = vPixel32 >> 24;


			// should now be safe for FBA AND FBMSK //
			// set FBA
			vPixel32 |= FBA;

			// FBMSK
			vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );

		//if ( ATE != 0 )
		{
			//bvATST_LESS = lessThan( vTestPixel32, vAREF );
			//bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			//bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			//ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );


			uvATSelect = uvec4( ( ( sign( ivec4( vTestPixel32 - vAREF ) ) & iATMask ) + iATOffset ) >> 31 );

			vPixel32 = ( vPixel32 & ( AFAIL_FBMASK | uvATSelect ) ) | ( vDestPixel32 & ~( AFAIL_FBMASK | uvATSelect ) );
			vZPixel32 = ( vZPixel32 & ( AFAIL_ZBMASK | uvATSelect ) ) | ( vZDestPixel32 & ~( AFAIL_ZBMASK | uvATSelect ) );


			// alpha fail //

			//uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			//uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );

			// select between afail pixel and pixel
			//bvTestMask = notEqual( ivATSelect, vZero );
			//vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			//vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
		}

//#endif

//#ifdef ENABLE_DSTALPHA_TEST
		//if ( DATE != 0 )
		{
			// destination alpha test //

			// da test
			uvDASelect = ( vDestPixel32 ^ DATM ) & DATE;
			uvDASelect = ( uvDASelect >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			uvDASelect |= FPSM & 1;

			uvEnable &= uvDASelect;

			//bvTestMask = notEqual( ivDASelect, vZero );
			//vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
		}
//#endif

//#ifdef ENABLE_DEPTH_TEST
			// depth test //

		//if ( ZTE != 0 )
		{
			// depth test //

			//bvZTST_LESS = lessThan( vZPixel32, vZDestPixel32 );
			//ivZSelect = ( ivec4( bvZTST_LESS ) & int( ZTST_LESS ) ) | ( ivec4( bvZTST_GREATER ) & int( ZTST_GREATER ) ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) );
			//ivZSelect = ivec4( bvZTST_GREATER ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) );
			//bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			//bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );

			uvZTST_EQUAL = usubBorrow( vZDestPixel32, vZPixel32, uvZTST_GREATER );
			uvZSelect = ( sign( ivec4( uvZTST_EQUAL ) ) ^ ZTST_EQUAL ) | uvZTST_GREATER | ZTST_LESS;

			uvEnable &= uvZSelect;

			//bvTestMask = bvec4( ivec4( bvZTST_GREATER ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) ) );
			//vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
		}
//#endif



			// and only the enabled pixels
			uvEnable = -uvEnable;
			vPixel32 = ( vPixel32 & uvEnable ) | ( vDestPixel32 & ~uvEnable );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );



			// write frame buffer //


			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				//vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );
				vPixel32 = bitfieldInsert( vPixel32, bitfieldExtract( vDPixelX, 24, 8 ), 24, (FPSM & 1) << 3 );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset[0] + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset[0] + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset[0] + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset[0] + 10 ] = vPixel32_0 [ 3 ];
			}



//#ifdef ENABLE_WRITE_ZBUFFER
			// write z buffer //


			if ( ZMSK == 0 )
			{
				vZPixel32 = ( vZPixel32 & uvEnable ) | ( vZDestPixel32 & ~uvEnable );

				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					//vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );
					vZPixel32 = bitfieldInsert( vZPixel32, bitfieldExtract( vZPixelX, 24, 8 ), 24, (ZPSM & 1) << 3 );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
				}
			}


			
//#endif

		}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
		
	}	// end for ( Line = StartY + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )



#ifdef DRAW_RECTANGLE_MULTI

		uIndex += 64;

		uIdx += 128;

		Comm = inputdata [ uIndex + ( 15 << 1 ) + 0 ];


		Comm &= 0xff000017;

	} while ( ( ( Comm == 0x06 ) || ( Comm == 0x00 ) ) && ( uIndex < ( COMMAND_LIST_SIZE << 6 ) ) );

	return ( uIndex >> 6 ) - 1;

#else

	return;

#endif
	
}




#ifdef DRAW_SPRITE_MULTI
uint Draw_Sprite ( uint uIndex )
#else
void Draw_Sprite ( uint uIndex )
#endif
{
	// constants //

	//int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );


	// variables //

	int xid, yid;


	uint Comm;
	int bDraw;

	uint uIdx;


	int iPtr;
	ivec4 vPtr;
	
	int Temp;
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	uint bgr32;
	int x, y, w, h;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	//int x0, y0, x1, y1;
	uint z0, z1;


	int StartX;
	int EndX;
	int StartY;
	int EndY;


	uint PRIM;
	int FRAME;
	uint FBMSK;

	uint FST, ABE, FGE, PABE;
	uint FOGCOL;
	int FCR, FCG, FCB;

	int FBP;
	int FBW;
	int FPSM;

	int FrameBufferStartOffset32;
	int FrameBufferWidth_Pixels;

	int yoffset32, zyoffset32;
	int yoffset32_xor, zyoffset32_xor;
	ivec4 vXOffset32, vZXOffset32;

	uint TEST, ATE, ATST, AREF, AFAIL, DATE, DATM, ZTE, ZTST;
	uint AFAIL_FBMASK, AFAIL_ZBMASK, ZTST_LESS, ZTST_GREATER, ZTST_EQUAL;
	bvec4 bvATST_LESS, bvATST_EQUAL, bvATST_GREATER;
	int ATST_LESS, ATST_EQUAL, ATST_GREATER;

	uvec4 uvAFAIL_PIXEL, uvAFAIL_ZPIXEL;

	uint ALPHA;
	uint ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX;
	uint ALPHA_A_SELECT, ALPHA_B_SELECT, ALPHA_C_SELECT, ALPHA_D_SELECT;
	uint ALPHA_A_AND, ALPHA_B_AND, ALPHA_C_AND, ALPHA_D_AND, ALPHA_C_OR;
	uvec4 vALPHA_A_PIXEL, vALPHA_B_PIXEL, vALPHA_C_PIXEL, vALPHA_D_PIXEL;
	uvec4 vAREF;

	uvec4 vPixelA, vPixelB, vPixelC, vPixelD;
	ivec4 iva, ivb, ivc, ivd;

	int ZBUF;
	int ZBP;
	int ZPSM;
	int ZMSK;

	int ZBufferStartOffset32;

	uint FBA;


	ivec4 vIdx;
	ivec4 vIdx32;
	ivec4 vxid;
	ivec4 vx_across;
	ivec4 vOffset;
	ivec4 vZOffset;

	uvec4 vDestPixel16, vDestPixel32, vDestPixel32_0, vDestPixel32_1;
	uvec4 vZDestPixel16, vZDestPixel32, vZDestPixel32_0, vZDestPixel32_1;
	uvec4 vZDestPixel24_1;
	uvec4 vPixel32, vZPixel32;
	uvec4 vPixel24, vZPixel24;
	uvec4 vPixel32_0, vPixel32_1, vZPixel32_0, vZPixel32_1;
	uvec4 vPixel32_2;
	uvec4 vPixel16;
	uvec4 vMask, vMask32;
	ivec4 vPixelShift;

	uvec4 vDPixelX, vZPixelX;

	bvec4 bvALPHA_A_SELECT, bvALPHA_B_SELECT, bvALPHA_C_SELECT, bvALPHA_D_SELECT;
	ivec4 ivAlphaA, ivAlphaB, ivAlphaC, ivAlphaD;
	ivec4 ivRedA, ivRedB, ivRedC, ivRedD;
	ivec4 ivGreenA, ivGreenB, ivGreenC, ivGreenD;
	ivec4 ivBlueA, ivBlueB, ivBlueC, ivBlueD;

	ivec4 ivATSelect, ivDASelect, ivZSelect;
	uvec4 uvATSelect, uvDASelect, uvZSelect;

	bvec4 bvZTST_LESS, bvZTST_GREATER, bvZTST_EQUAL;
	uvec4 uvZTST_GREATER, uvZTST_EQUAL;
	bvec4 bvTestMask;
	bvec4 bvEnable;
	uvec4 uvEnable;

	uvec4 vTestPixel32;

	int DRAWPSM, ZBUFPSM;

	ivec4 vav, vrv, vgv, vbv;
	ivec4 vaf, vrf, vgf, vbf;
	ivec4 vat, vrt, vgt, vbt;
	ivec4 vadd, vmul;

	uvec4 uvbgr32;


	// texture vars //

	uvec4 vTPixel32;
	ivec4 viU;
	int iV;
	int iAnd1, iShift1, iShift2, iAnd3, iShift3;

	int dudx, dvdy;
	int CLAMP_0, CLAMP_1;
	int WMS, WMT;
	int MINU, MAXU, MINV, MAXV;
	int TexY_And, TexY_Or, TexY_Min, TexY_Max;
	int TexX_And, TexX_Or, TexX_Min, TexX_Max;

	ivec4 vTexCoordX, vTXOffset, vTOffset;
	int TexCoordY;
	int iTYOffset, xTYOffset;

	int AEM;
	int TEXA_0, TEXA_1;

	uvec4 uvTEXA_0, uvTEXA_1;
	uvec4 uvZ0;

	//float fs0, ft0, fs1, ft1;

	//int u0, v0, u1, v1;
	int f0, f1;
	int rf0;
	int TEX0_0, TEX0_1;
	int TBP0, TBW, TPSM, TW, TH;
	int TEXPSM;
	int TexWidth, TexHeight;
	int TexWidth_Mask, TexHeight_Mask;
	int TCC, TFX;
	int CBP, CPSM, CSM, CSA, CLD;
	int CLUTStartOffset32;

	int TextureBufferStartOffset32;
	int TextureBufferWidth_Pixels;

	ivec2 vx, vy;
	ivec2 vu, vv;
	vec2 vfs, vft;

	//ivec4 clampprimfogcol, xyoffsetscissor, framezbuf, alphatest, texatex0, pabefbacolclampdthe;
	//ivec4 xyzrgbaq0, xyzrgbaq1, xyzrgbaq2;
	//ivec4 uvstfog0, uvstfog1, uvstfog2;

	ivec2 dxdx;

	int COLCLAMP;

	uvec4 uvALPHA_FIX;

	uvec4 uvAlphaSelect [ 4 ];
	mat4 mAlphaSelect;

	int DYNAND, ZYNAND, TYNAND;

	int iZTOffset;
	int iATOffset, iATMask;

	// *** setup *** //

		uIdx = uIndex << 7;
		uIndex <<= 6;
		//uIndex <<= 4;

	// load vars
	//xyoffsetscissor = ivec4( inputdata4 [ uIndex + 0 ] );
	//framezbuf = ivec4( inputdata4 [ uIndex + 1 ] );
	//alphatest = ivec4( inputdata4 [ uIndex + 2 ] );
	//texatex0 = ivec4( inputdata4 [ uIndex + 3 ] );
	//clampprimfogcol = ivec4( inputdata4 [ uIndex + 7 ] );
	//pabefbacolclampdthe = ivec4( inputdata4 [ uIndex + 8 ] );

	//xyzrgbaq0 = ivec4( inputdata4 [ uIndex + 10 ] );
	//uvstfog0 = ivec4( inputdata4 [ uIndex + 11 ] );
	//xyzrgbaq1 = ivec4( inputdata4 [ uIndex + 12 ] );
	//uvstfog1 = ivec4( inputdata4 [ uIndex + 13 ] );

		//uIndex <<= 2;


#ifdef DRAW_SPRITE_MULTI
	do
	{
#endif


#ifdef CALC_SPRITE_VARS

		// prim //

		PRIM = inputdata [ uIndex + ( 15 << 1 ) + 0 ];
		//PRIM = clampprimfogcol.z;

		FST = ( PRIM >> 8 ) & 1;
		ABE = ( PRIM >> 6 ) & 1;
		FGE = ( PRIM >> 5 ) & 1;


		// pixel set //

		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ];
		//FBA = pabefbacolclampdthe.y;
		FBA = ( FBA & 1 ) << 31;

		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		// fragment color //

		// get rgba from coord1 (last color value entered)
		bgr32 = inputdata [ uIndex + ( 25 << 1 ) + 0 ];
		//bgr32 = xyzrgbaq1.z;

		// split into rgba
		uvbgr32 = uvec4( bgr32 );
		vaf = ivec4( uvbgr32 >> 24 ) & 0xff;
		vrf = ivec4( uvbgr32 >> 16 ) & 0xff;
		vgf = ivec4( uvbgr32 >> 8 ) & 0xff;
		vbf = ivec4( uvbgr32 >> 0 ) & 0xff;


		// coords //
		
		// get x0,y0 from coord1 (first coord entered)
		// x0,y0 are unsigned

		// get x1,y1 from coord0

		vx.y = int( inputdata [ uIndex + ( 20 << 1 ) + 0 ] );
		vx.x = int( inputdata [ uIndex + ( 24 << 1 ) + 0 ] );
		//vx.y = xyzrgbaq0.x;
		//vx.x = xyzrgbaq1.x;
		vy = ( vx >> 16 ) & 0xffff;
		vx &= 0xffff;


		// get z from coord1
		z0 = inputdata [ uIndex + ( 24 << 1 ) + 1 ];
		f0 = int( inputdata [ uIndex + ( 27 << 1 ) + 0 ] );
		//z0 = xyzrgbaq1.y;
		//f0 = uvstfog1.w;
		
		DrawArea_OffsetX = int( inputdata [ uIndex + ( 0 << 1 ) + 0 ] ) & 0xffff;
		DrawArea_OffsetY = int( inputdata [ uIndex + ( 0 << 1 ) + 1 ] ) & 0xffff;
		//xyoffsetscissor.xy &= 0xffff;
		//DrawArea_OffsetX = xyoffsetscissor.x;
		//DrawArea_OffsetY = xyoffsetscissor.y;

		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		//DrawArea_TopLeftX = xyoffsetscissor.z;
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		//DrawArea_TopLeftY = xyoffsetscissor.w;
		DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		DrawArea_TopLeftY &= 0x7ff;

		
		// get top left corner of sprite and bottom right corner of sprite
		//x0 -= DrawArea_OffsetX;
		//y0 -= DrawArea_OffsetY;
		//x1 -= DrawArea_OffsetX;
		//y1 -= DrawArea_OffsetY;
		vx -= DrawArea_OffsetX;
		vy -= DrawArea_OffsetY;



		// frame buffer //

		FRAME = int( inputdata [ uIndex + ( 2 << 1 ) + 0 ] );
		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];
		//FRAME = framezbuf.x;
		//FBMSK = framezbuf.y;

		FBP = FRAME & 0x1ff;
		FBW = ( FRAME >> 16 ) & 0x3f;
		FPSM = ( FRAME >> 24 ) & 0x3f;

		// the offset is two times further because of the data arrangement in shader
		FrameBufferStartOffset32 = FBP << 11;
		FrameBufferStartOffset32 <<= 1;

		FrameBufferWidth_Pixels = FBW << 6;

		DRAWPSM = FPSM >> 1;


		// z-buffer //

		ZBUF = int( inputdata [ uIndex + ( 3 << 1 ) + 0 ] );
		//ZBUF = framezbuf.z;
		ZBP = ZBUF & 0x1ff;
		ZPSM = ( ZBUF >> 24 ) & 0xf;
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) & 1;
		//ZMSK = framezbuf.w;

		ZBufferStartOffset32 = ZBP << 11;
		ZBufferStartOffset32 <<= 1;

		// add on the missing bits for the zpsm
		ZPSM |= 0x30;

		ZBUFPSM = ZPSM >> 1;


	// pixel test //

	// pixel test
	TEST = inputdata [ uIndex + ( 5 << 1 ) + 0 ];
	//TEST = alphatest.z;

	// destination alpha test
	DATE = ( ( TEST >> 14 ) & 1 ) << 31;
	DATM = ( ( TEST >> 15 ) & 1 ) << 31;
	
	// depth test
	ZTE = ( TEST >> 16 ) & 1;
	ZTST = ( TEST >> 17 ) & 0x3;

	// alpha test
	ATE = TEST & 1;
	ATST = ( TEST >> 1 ) & 0x7;
	AREF = ( TEST >> 4 ) & 0xff;
	AFAIL = ( TEST >> 12 ) & 0x3;

	// initialize to RGB only on non-RGBA32 format
	AFAIL_FBMASK = -1;
	AFAIL_ZBMASK = -1;

	ATST_LESS = -1;
	ATST_EQUAL = -1;
	ATST_GREATER = -1;
	if ( ATE != 0 )
	{
		// alpha test enabled //

		switch ( ATST )
		{
			// never pass
			case 0:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// always pass
			case 1:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// less
			case 2:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// less or equal
			case 3:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// equal
			case 4:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// greater or equal
			case 5:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// greater
			case 6:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;

			// not equal
			case 7:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;
		}

		switch ( AFAIL )
		{
			// keep/hold
			case 0:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = 0;
				break;

			// only update FB
			case 1:
				AFAIL_FBMASK = -1;
				AFAIL_ZBMASK = 0;
				break;

			// only update ZB
			case 2:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = -1;
				break;

			// only update rgb
			case 3:
				// only if format is RGBA32
				if ( FPSM == 0 )
				{
					AFAIL_FBMASK = 0x00ffffff;
					AFAIL_ZBMASK = 0;
				}
				break;
		}
	}

	// depth test
	ZTST_LESS = -1;
	ZTST_GREATER = -1;
	ZTST_EQUAL = -1;
	if ( ZTE != 0 )
	{
		// depth test enabled //

		switch( ZTST )
		{
			// never
			case 0:
				ZTST_LESS = 0;
				ZTST_GREATER = 0;
				ZTST_EQUAL = 0;
				break;

			// always
			case 1:
				ZTST_LESS = -1;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater or equal
			case 2:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater
			case 3:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = 0;
				break;
		}
	}


	// alpha blending //

	// blending per pixel
	PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;
	//pabefbacolclampdthe &= 1;
	//PABE = pabefbacolclampdthe.x;

	ALPHA = inputdata [ uIndex + ( 4 << 1 ) + 0 ];
	//ALPHA = alphatest.x;

	// no alpha blending if disabled
	ALPHA &= -ABE;

	ALPHA_A = ( ALPHA >> 0 ) & 0x3;
	ALPHA_B = ( ALPHA >> 2 ) & 0x3;
	ALPHA_C = ( ALPHA >> 4 ) & 0x3;
	ALPHA_D = ( ALPHA >> 6 ) & 0x3;
	ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;
	//ALPHA_FIX = ( alphatest.y & 0xff ) << 24;


	if ( ( ( ALPHA_A == ALPHA_B ) || ( ALPHA_FIX == 0 ) ) && ( ALPHA_D == 0 ) )
	{
		ABE = 0;
	}

	if ( ( ALPHA_A == 0 ) && ( ALPHA_B > 1 ) && ( ALPHA_FIX == 0x80 ) && ( ALPHA_D > 1 ) )
	{
		ABE = 0;
	}

	



		// texture buffer //

		// get the texture variabls
		TEX0_0 = int( inputdata [ uIndex + ( 7 << 1 ) + 0 ] );
		TEX0_1 = int( inputdata [ uIndex + ( 7 << 1 ) + 1 ] );
		//TEX0_0 = texatex0.z;
		//TEX0_1 = texatex0.w;

		TBP0 = ( TEX0_0 >> 0 ) & 0x3fff;

		TextureBufferStartOffset32 = ( TBP0 << 6 );
		TextureBufferStartOffset32 <<= 1;

		TBW = ( TEX0_0 >> 14 ) & 0x3f;

		TextureBufferWidth_Pixels = TBW << 6;

		TPSM = ( TEX0_0 >> 20 ) & 0x3f;

		TEXPSM = TPSM >> 1;

		TW = ( TEX0_0 >> 26 ) & 0xf;
		TH = ( ( TEX0_0 >> 30 ) & 0x3 ) | ( ( TEX0_1 & 0x3 ) << 2 );

		TexWidth = 1 << TW;
		TexHeight = 1 << TH;
		TexWidth_Mask = TexWidth - 1;
		TexHeight_Mask = TexHeight - 1;

		TCC = ( TEX0_1 >> 2 ) & 0x1;
		TFX = ( TEX0_1 >> 3 ) & 0x3;


	// color lookup table pixel format variables //

		//CBP = ( TEX0_1 >> 5 ) & 0x3fff;

		//CLUTStartOffset32 = ( CBP << 6 );
		//CLUTStartOffset32 <<= 1;

		CPSM = ( TEX0_1 >> 19 ) & 0xf;
		CSM = ( TEX0_1 >> 23 ) & 0x1;
		CSA = ( TEX0_1 >> 24 ) & 0x1f;
		CLD = ( TEX0_1 >> 29 ) & 0x7;

	

	
	if ( CSM == 0 )
	{
		// CSM1 //
		
		if ( ( CPSM & 0x2 ) != 0 )
		{
			// 4-bit pixels - 16 colors
			// 16-bit pixels in CLUT //
			CSA &= 0x1f;
		}
		else
		{
			// 32-bit pixels in CLUT //
			CSA &= 0xf;
		}
		
	}
	else
	{
		// CSM2 //
		
		// when these pixels load into temporary clut, they should be at index 0
		CSA = 0;
	}
	
	CSA <<= 4;
	//ptr_clut16 = & ( InternalCLUT [ CLUTOffset ] );


	TEXA_0 = int( inputdata [ uIndex + ( 6 << 1 ) + 0 ] );
	TEXA_1 = int( inputdata [ uIndex + ( 6 << 1 ) + 1 ] );
	//TEXA_0 = texatex0.x;
	//TEXA_1 = texatex0.y;

	AEM = ( TEXA_0 >> 15 ) & 1;
	TEXA_0 <<= 24;
	TEXA_1 <<= 24;




	// texture clamp //

	CLAMP_0 = int( inputdata [ uIndex + ( 14 << 1 ) + 0 ] );
	CLAMP_1 = int( inputdata [ uIndex + ( 14 << 1 ) + 1 ] );
	//CLAMP_0 = clampprimfogcol.x;
	//CLAMP_1 = clampprimfogcol.y;

	WMS = ( CLAMP_0 >> 0 ) & 0x3;
	WMT = ( CLAMP_0 >> 2 ) & 0x3;

	MINU = ( CLAMP_0 >> 4 ) & 0x3ff;
	MAXU = ( CLAMP_0 >> 14 ) & 0x3ff;

	MINV = ( ( CLAMP_0 >> 24 ) & 0xff ) | ( ( CLAMP_1 & 0x3 ) << 8 );
	MAXV = ( CLAMP_1 >> 2 ) & 0x3ff;

	switch ( WMT )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexY_And = TexHeight_Mask;
			
			TexY_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexY_Min = 0;
			TexY_Max = TexHeight_Mask;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexY_Min = MINV;
			TexY_Max = MAXV;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexY_And = MINV & TexHeight_Mask;
			TexY_Or = MAXV & TexHeight_Mask;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
	}

	
	switch ( WMS )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexX_And = TexWidth_Mask;
			
			TexX_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexX_Min = 0;
			TexX_Max = TexWidth_Mask;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexX_Min = MINU;
			TexX_Max = MAXU;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexX_And = MINU & TexWidth_Mask;
			TexX_Or = MAXU & TexWidth_Mask;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
	}


	// texture processing values //

	// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
	// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
	// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
	// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
	// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
	switch ( TPSM )
	{
		// PSMCT32
		// PSMCT24
		// PSMZ32
		// PSMZ24
		case 0x0:
		case 0x1:
		case 0x30:
		case 0x31:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = -1; iShift3 = 0;
			break;

		// PSMCT16
		// PSMCT16S
		// PSMZ16
		// PSMZ16S
		case 0x2:
		case 0xa:
		case 0x32:
		case 0x3a:
			iAnd1 = 0; iShift1 = 0; iShift2 = 1; iAnd3 = 0xffff; iShift3 = 0;
			break;

		// PSMT8
		case 0x13:
			iAnd1 = 1; iShift1 = 3; iShift2 = 2; iAnd3 = 0xff; iShift3 = 0;
			break;

		// PSMT4
		case 0x14:
			iAnd1 = 3; iShift1 = 2; iShift2 = 3; iAnd3 = 0xf; iShift3 = 0;
			break;

		// PSMT8H
		case 0x1b:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xff; iShift3 = 24;
			break;

		// PSMT4HL
		case 0x24:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 24;
			break;

		// PSMT4HH
		case 0x2c:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 28;
			break;
	}




	// texture fogging //

	FOGCOL = inputdata [ uIndex + ( 15 << 1 ) + 1 ];
	//FOGCOL = clampprimfogcol.w;

	FCB = int( FOGCOL >> 0 ) & 0xff;
	FCG = int( FOGCOL >> 8 ) & 0xff;
	FCR = int( FOGCOL >> 16 ) & 0xff;

	// prepare f0, rf0
	f0 = ( f0 >> 24 ) & 0xff;
	rf0 = 0xff - f0;

	if ( FGE == 0 )
	{
		f0 = 0x100;
		rf0 = 0;
	}

	// need to do swap/scissor after texwidth/texheight //

	if ( FST != 0 )
	{

		// get u,v
		// coord0

		// coord1

		vu.y = int( inputdata [ uIndex + ( 22 << 1 ) + 0 ] );
		vu.x = int( inputdata [ uIndex + ( 26 << 1 ) + 0 ] );
		//vu.y = uvstfog0.x;
		//vu.x = uvstfog1.x;
		vv = ( vu >> 16 ) & 0x3fff;
		vu &= 0x3fff;
		
	}
	else
	{

		// put s,t coords into 10.4 fixed point
		// note: tex width/height should probably be minus one

		vu.y = int( inputdata [ uIndex + ( 22 << 1 ) + 0 ] );
		vv.y = int( inputdata [ uIndex + ( 22 << 1 ) + 1 ] );
		vu.x = int( inputdata [ uIndex + ( 26 << 1 ) + 0 ] );
		vv.x = int( inputdata [ uIndex + ( 26 << 1 ) + 1 ] );
		//vu.y = uvstfog0.x;
		//vv.y = uvstfog0.y;
		//vu.x = uvstfog1.x;
		//vv.x = uvstfog1.y;

		vfs = intBitsToFloat( vu );
		vft = intBitsToFloat( vv );

		vu = ivec2( vfs * float( TexWidth ) * 16.0f );
		vv = ivec2( vft * float( TexHeight ) * 16.0f );
	}


	// order coords so they go top to bottom and left to right
	//if ( vx[1] < vx[0] )
	if ( vx.y < vx.x )
	{
		// swap x,u coords
		vx.xy = vx.yx;
		vu.xy = vu.yx;
	}
	
	//if ( vy[1] < vy[0] )
	if ( vy.y < vy.x )
	{
		// swap y,v coords
		vy.xy = vy.yx;
		vv.xy = vv.yx;
	}


	// scissor test //
	
	StartX = ( vx.x + 0xf ) >> 4;
	EndX = ( vx.y - 1 ) >> 4;
	StartY = ( vy.x + 0xf ) >> 4;
	EndY = ( vy.y - 1 ) >> 4;


	// draw test //

	bDraw = 1;


	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	

	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( EndX < DrawArea_TopLeftX || StartX > DrawArea_BottomRightX || EndY < DrawArea_TopLeftY || StartY > DrawArea_BottomRightY ) bDraw = 0; //return;

	if ( ( vy.y < vy.x ) || ( vx.y < vx.x ) )
	{
		bDraw = 0;
	}


	// dx/dy values //

	

	dxdx = intdivfv2( ivec2( vu.y - vu.x, vv.y - vv.x), ivec2( vx.y - vx.x, vy.y - vy.x ), 4, 4, 16 );
	dudx = dxdx.x;
	dvdy = dxdx.y;


	//u0 <<= 12;
	//v0 <<= 12;
	//u1 <<= 12;
	//v1 <<= 12;
	vu <<= 12;
	vv <<= 12;

	// y clip/start //

	Temp = ( StartY << 4 ) - vy[0];

	if ( StartY < DrawArea_TopLeftY )
	{
		Temp += ( DrawArea_TopLeftY - StartY ) << 4;
		StartY = DrawArea_TopLeftY;
	}
	
	vv.x += ( dvdy >> 4 ) * Temp;
	//vv.x += ( dxdx.y >> 4 ) * Temp;
	
	
	if ( EndY > DrawArea_BottomRightY )
	{
		EndY = DrawArea_BottomRightY;
	}


	// x clip/start //
	
	Temp = ( StartX << 4 ) - vx[0];
	
	if ( StartX < DrawArea_TopLeftX )
	{
		Temp += ( DrawArea_TopLeftX - StartX ) << 4;
		StartX = DrawArea_TopLeftX;
	}
	
	vu.x += ( dudx >> 4 ) * Temp;
	//vu.x += ( dxdx.x >> 4 ) * Temp;
	
	
	if ( EndX > DrawArea_BottomRightX )
	{
		EndX = DrawArea_BottomRightX;
	}


	// vars needed: AREF, w, dudx, dvdy, u0, v0, StartX, EndX, StartY, EndY, z0, f0, rf0, FCR, FCG, FCB
	// ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX, DRAWPSM, ZBUFPSM, TEXPSM, FPSM, ZPSM, TPSM
	// TexX_Min, TexX_Max, TexX_And, TexX_Or, TexY_Min, TexY_Max, TexY_And, TexY_Or
	// FBA, FBMSK, ZMSK, ABE, PABE, TFX, TCC, iShift1, iShift2, iShift3, iAnd1, iAnd3
	// bDraw, TextureBufferStartOffset32, ZBufferStartOffset32, FrameBufferStartOffset32, FrameBufferWidth_Pixels
	// CPSM, AEM, TEXA_0, TEXA_1, ATST_LESS, ATST_GREATER, ATST_EQUAL, AFAIL_FBMASK, AFAIL_ZBMASK
	// ZTST_LESS, ZTST_GREATER, ZTST_EQUAL

	// general:
	// bDraw
	// StartY, EndY
	// DRAWPSM, ZBUFPSM, FPSM, ZPSM
	// ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX
	// AREF, ATST_LESS, ATST_GREATER, ATST_EQUAL
	// AFAIL_FBMASK, AFAIL_ZBMASK
	// ZTST_LESS, ZTST_GREATER, ZTST_EQUAL
	// FBA, FBMSK, ZMSK, ABE, PABE
	// ZBufferStartOffset32, FrameBufferStartOffset32, FrameBufferWidth_Pixels
	// texture related:
	// iShift1, iShift2, iShift3, iAnd1, iAnd3
	// TexX_Min, TexX_Max, TexX_And, TexX_Or, TexY_Min, TexY_Max, TexY_And, TexY_Or
	// FGE, FCR, FCG, FCB
	// TEXPSM, TPSM, CPSM, TFX, TCC
	// AEM, TEXA_0, TEXA_1
	// TextureBufferStartOffset32, TextureBufferWidth_Pixels
	// sprite:
	// StartX, EndX, z0, w, u0, v0, f0, rf0, dudx, dvdy

	w = EndX - StartX + 1;

#endif


#ifdef LOAD_SPRITE_VARS
	bDraw = data [ uIdx + 0 ];
#endif

	if ( bDraw == 1 )
	{

#ifdef LOAD_SPRITE_VARS

		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) << 31;
		PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;
		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ] << 31;
		ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;
		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		//uvAlphaSelect [ 2 ] = ivec4( ALPHA_FIX );
		//uvAlphaSelect [ 3 ] = vZero;
		mAlphaSelect [ 2 ] = ivec4( ALPHA_FIX );
		mAlphaSelect [ 3 ] = intBitsToFloat( vZero );

		//COLCLAMP = data [ uIdx + 1 ];
		//PABE = data [ uIdx + 2 ];
		//FBA = data [ uIdx + 3 ];

		FPSM = data [ uIdx + 1 ];
		ZPSM = data [ uIdx + 2 ];
		DRAWPSM = data [ uIdx + 3 ];
		ZBUFPSM = data [ uIdx + 4 ];
		FrameBufferStartOffset32 = data [ uIdx + 5 ];
		FrameBufferWidth_Pixels = data [ uIdx + 6 ];
		ZBufferStartOffset32 = data [ uIdx + 7 ];
		
		//FBMSK = data [ uIdx + 8 ];
		//ZMSK = data [ uIdx + 9 ];
		
		AFAIL_FBMASK = data [ uIdx + 8 ];
		AFAIL_ZBMASK = data [ uIdx + 9 ];

		//ALPHA_FIX = data [ uIdx + 10 ];

		ALPHA_A = data [ uIdx + 10 ];
		ALPHA_B = data [ uIdx + 11 ];
		ALPHA_C = data [ uIdx + 12 ];
		ALPHA_D = data [ uIdx + 13 ];
		AREF = data [ uIdx + 14 ];
		ATST_LESS = data [ uIdx + 15 ];
		ATST_GREATER = data [ uIdx + 16 ];
		ATST_EQUAL = data [ uIdx + 17 ];
		ZTST_LESS = data [ uIdx + 18 ];
		ZTST_GREATER = data [ uIdx + 19 ];
		ZTST_EQUAL = data [ uIdx + 20 ];
		FGE = data [ uIdx + 21 ];
		DATE = data [ uIdx + 22 ];
		DATM = data [ uIdx + 23 ];
		ABE = data [ uIdx + 24 ];

		iZTOffset = data [ uIdx + 91 ];
		ZTE = data [ uIdx + 95 ];
		ATE = data [ uIdx + 123 ];

		// load common texture settings //

		TexX_Min = data [ uIdx + 25 ];
		TexX_Max = data [ uIdx + 26 ];
		TexX_And = data [ uIdx + 27 ];
		TexX_Or = data [ uIdx + 28 ];
		TexY_Min = data [ uIdx + 29 ];
		TexY_Max = data [ uIdx + 30 ];
		TexY_And = data [ uIdx + 31 ];
		TexY_Or = data [ uIdx + 32 ];
		TPSM = data [ uIdx + 33 ];
		TEXPSM = data [ uIdx + 34 ];
		TFX = data [ uIdx + 35 ];
		TCC = data [ uIdx + 36 ];
		CPSM = data [ uIdx + 37 ];
		CSA = data [ uIdx + 38 ];
		AEM = data [ uIdx + 39 ];
		TEXA_0 = data [ uIdx + 40 ];
		TEXA_1 = data [ uIdx + 41 ];
		TextureBufferStartOffset32 = data [ uIdx + 42 ];
		TextureBufferWidth_Pixels = data [ uIdx + 43 ];
		FCR = data [ uIdx + 44 ];
		FCG = data [ uIdx + 45 ];
		FCB = data [ uIdx + 46 ];
		iShift1 = data [ uIdx + 47 ];
		iShift2 = data [ uIdx + 48 ];
		iShift3 = data [ uIdx + 49 ];
		iAnd1 = data [ uIdx + 50 ];
		iAnd3 = data [ uIdx + 51 ];


		// load sprite vars //
		
		StartY = data [ uIdx + 57 ];
		EndY = data [ uIdx + 58 ];
		StartX = data [ uIdx + 59 ];
		EndX = data [ uIdx + 60 ];
		w = data [ uIdx + 61 ];
		z0 = uint( data [ uIdx + 62 ] );
		f0 = data [ uIdx + 63 ];
		rf0 = data [ uIdx + 64 ];
		vu.x = data [ uIdx + 65 ];
		vv.x = data [ uIdx + 66 ];
		dudx = data [ uIdx + 67 ];
		dvdy = data [ uIdx + 68 ];
		//bgr32 = data [ uIdx + 69 ];
		//data [ uIdx + 70 ] = bgra;
		//data [ uIdx + 71 ] = bgrr;
		//data [ uIdx + 72 ] = bgrg;
		//data [ uIdx + 73 ] = bgrb;

		vaf = ivec4( data [ uIdx + 70 ] );
		vrf = ivec4( data [ uIdx + 71 ] );
		vgf = ivec4( data [ uIdx + 72 ] );
		vbf = ivec4( data [ uIdx + 73 ] );

		iATMask = data [ uIdx + 15 ];
		iATOffset = data [ uIdx + 16 ];

#endif

	uvTEXA_0 = uvec4( TEXA_0 );
	uvTEXA_1 = uvec4( TEXA_1 );
	uvALPHA_FIX = uvec4( ALPHA_FIX );
	uvZ0 = uvec4( z0 );


	vAREF = uvec4( AREF );



	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
	//vxid = ( vxid.w >= 0 ) ? vxid : ( vxid + group_vxinc );
	vxid = vxid + group_vxinc * ( ( vxid.w >> 31 ) & 1 );
	
	// if 16-bit z-buffer (24-bit should already be masked), then mask z0

	// 32-bit frame-buffer, 32-bit z-buffer //

	ivec2 vyoffset_xor;
	ivec2 vyoffset;
	ivec2 vdzpsm7;
	ivec2 vdzpsm12;
	ivec2 vdzpsm;
	ivec2 vdznand;
	ivec2 vstartoffset;
	ivec4 viStartU;


//#ifdef ENABLE_TEXTURE_MAPPING
	iV = vv.x + ( yid * dvdy );
	dvdy *= group_yinc;
	//dxdx.y *= group_yinc;

	viStartU = vu.x + ( vxid * dudx );

	dudx <<= group_vxinc_shift;
//#endif

	DYNAND = LUT_YNAND[ DRAWPSM ];
	ZYNAND = LUT_YNAND[ ZBUFPSM ];
	TYNAND = LUT_YNAND[ TEXPSM ];


	vdzpsm.x = ( DRAWPSM & 1 ) ^ 1;
	vdzpsm.y = ( ZBUFPSM & 1 ) ^ 1;

	vdzpsm7.x = DRAWPSM << 7;
	vdzpsm7.y = ZBUFPSM << 7;

	vdzpsm12.x = DRAWPSM << 12;
	vdzpsm12.y = ZBUFPSM << 12;

	vdznand.x = LUT_YNAND[ DRAWPSM ];
	vdznand.y = LUT_YNAND[ ZBUFPSM ];

	vstartoffset.x = FrameBufferStartOffset32;
	vstartoffset.y = ZBufferStartOffset32;

	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		vIdx.xy = vdzpsm7.xy | ( Line & 0x3f );
		vyoffset_xor = ivec2( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ] );
		vyoffset = ( Line & vdznand ) * FrameBufferWidth_Pixels;


//#ifdef ENABLE_TEXTURE_MAPPING
			// need to start texture coord from left again
			//viU = vu.x + ( vxid * dudx );
			//viU = vu.x + ( vxid * dxdx.x );
			viU = viStartU;
			
			TexCoordY = ( iV >> 16 );
			
			//TexCoordY = ( ( TexCoordY < TexY_Min ) ? TexY_Min : TexCoordY );
			//TexCoordY = ( ( TexCoordY > TexY_Max ) ? TexY_Max : TexCoordY );
			TexCoordY = clamp( TexCoordY, TexY_Min, TexY_Max );
			TexCoordY &= TexY_And;
			TexCoordY |= TexY_Or;

			xTYOffset = LUT_YOFFSET [ ( TexCoordY & 0x7f ) | ( TEXPSM << 7 ) ];
			iTYOffset = ( TexCoordY & TYNAND ) * TextureBufferWidth_Pixels;

//#endif


		// draw horizontal line
		//for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
		for ( vx_across = vxid; vx_across.x < w; vx_across += group_vxinc )
		{
			// get pointer to pixel based on frame buffer pixel format (4-bit aligned offset) //

			// get the pixels to be drawn
			//bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
			usubBorrow( uvec4( vx_across ), uvec4( w ), uvEnable );

			// z value is z0
			//vZPixel32 = uvec4( z0 );
			vZPixel32 = uvZ0;


			// calculate xoffset
			vIdx.xy = ( ( vx_across.x + StartX ) & 0xfff ) | vdzpsm12.xy;
			vXOffset32.xy = ivec2( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ] );
			vXOffset32.xy ^= vyoffset_xor.xy;
			vOffset.xy = vXOffset32.xy + vyoffset.xy;
			vOffset.xy <<= vdzpsm.xy;
			vOffset.xy += vstartoffset.xy;

			vZOffset[0] = vOffset.y;


			// x-bit pixels //

			vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];

			// combine
			//vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			//vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );
			vDestPixel32.xy = bitfieldInsert( vDestPixel32_0.xz, vDestPixel32_0.yw, 16, 16 );
			vDestPixel32.zw = bitfieldInsert( vDestPixel32_1.xz, vDestPixel32_1.yw, 16, 16 );

			vDPixelX = vDestPixel32;

			// extract
			vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				//vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
				vDestPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vDestPixel32, 3, 5 ), bitfieldExtract( vDestPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vDestPixel32, 10, 5 ), 19, 5 ), bitfieldExtract( vDestPixel32, 15, 1 ), 31, 1 );
			}



			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );


			// x-bit zpixels //

			vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];

			// combine
			//vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			//vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );
			vZDestPixel32.xy = bitfieldInsert( vZDestPixel32_0.xz, vZDestPixel32_0.yw, 16, 16 );
			vZDestPixel32.zw = bitfieldInsert( vZDestPixel32_1.xz, vZDestPixel32_1.yw, 16, 16 );

			vZPixelX = vZDestPixel32;

			// extract
			vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );



			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );


			// load pixel to draw //


//#ifdef ENABLE_TEXTURE_MAPPING_SPRITE

			vTexCoordX = ( viU >> 16 );


			//vTexCoordX = mix( vTexCoordX, ivec4( TexX_Min ), lessThan( vTexCoordX, ivec4( TexX_Min ) ) );
			//vTexCoordX = mix( vTexCoordX, ivec4( TexX_Max ), greaterThan( vTexCoordX, ivec4( TexX_Max ) ) );
			vTexCoordX = clamp( vTexCoordX, TexX_Min, TexX_Max );
			vTexCoordX &= TexX_And;
			vTexCoordX |= TexX_Or;



			vIdx = ( vTexCoordX & 0x0fff ) | ( TEXPSM << 12 );
			vTXOffset = ivec4( LUT_XOFFSET[ vIdx[0] ], LUT_XOFFSET[ vIdx[1] ], LUT_XOFFSET[ vIdx[2] ], LUT_XOFFSET[ vIdx[3] ] );




			// need to shift to left once if 32-bit pixels //
			vTOffset = vTXOffset ^ xTYOffset;
			vTOffset += iTYOffset;

			


			// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
			// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
			// get the amount to shift pixel
			vPixelShift = ( vTOffset & iAnd1 ) << iShift1;

			// if looking up 32-bit pixels, then need to multiply by 2 in x-direction
			vTOffset <<= 1;

			// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
			// get the remainder of the offset (for 32-bit lookup after already shifting left 1)
			vTOffset >>= iShift2;

			vTOffset += TextureBufferStartOffset32;

			// check if 32-bit pixel format or not for texture
			if ( ( TEXPSM & 0x7 ) == 0 )
			{
				// 32-bit texture pixel //

				
				// load 32-bit pixel data
				vTOffset >>= 1;
				vPixel32_0.xy = VRAM2 [ vTOffset[0] ];
				vPixel32_0.zw = VRAM2 [ vTOffset[1] ];
				vPixel32_1.xy = VRAM2 [ vTOffset[2] ];
				vPixel32_1.zw = VRAM2 [ vTOffset[3] ];

				// combine
				//vPixel32.xy = ( vPixel32_0.xz & 0xffff ) | ( vPixel32_0.yw << 16 );
				//vPixel32.zw = ( vPixel32_1.xz & 0xffff ) | ( vPixel32_1.yw << 16 );
				vPixel32.xy = bitfieldInsert( vPixel32_0.xz, vPixel32_0.yw, 16, 16 );
				vPixel32.zw = bitfieldInsert( vPixel32_1.xz, vPixel32_1.yw, 16, 16 );
				

				// check if rgb24 format
				if ( ( TPSM & 1 ) == 1 )
				{
					// handle aem for rgb24 //

					// mask pixel
					vPixel32 &= 0x00ffffff;

					// check if zero
					vPixel32 |= TEXA_0 & ( ( AEM ) | ~( vPixel32-1 ) );

					// pull in texa if aem=0
				}
			}
			else
			{
				// either 16-bit or lookup pixel //


				// pull the pixel
				vTOffset += ( iShift3 >> 3 ) & 1;
				vPixel32 = uvec4( VRAM [ vTOffset[0] ], VRAM [ vTOffset[1] ], VRAM [ vTOffset[2] ], VRAM [ vTOffset[3] ] );

				// check if pixel needs lookup
				if ( ( TPSM & 7 ) < 3 )
				{
					// straight 16-bit pixel //


					// handle aem for rgb16 //

					// get alpha0 if aem=1

					// mask pixel just in case
					vPixel32 &= 0xffff;

					// if a=0, then a=texa0 if either rgb!=0 or aem=0, otherwise a=0
					vPixel24 = TEXA_0 & ( ( AEM ) | ~( vPixel32 - 1 ) );

					// get texa0 value

					// select alpha
					vPixel16 = -( vPixel32 >> 15 );
					vPixel24 = ( TEXA_1 & vPixel16 ) | ( vPixel24 & ~vPixel16 );


					// convert 16-bit pixels to 32-bit pixels
					//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
					vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

					// put in the alpha value
					vPixel32 |= vPixel24;
				}
				else
				{
					// lookup pixel //


					// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
					// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
					// shift/mask pixel (need mask value and right shift value for offset)
					vPixel32 = ( ( vPixel32 >> vPixelShift ) >> ( iShift3 & 0xf ) ) & iAnd3;
					vIdx = ivec4( vPixel32 ) + CSA;

					// lookup pixel in CLUT (and load 16-bit chunks)

					vPixel32 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

					if ( CPSM == 0 )
					{
						// 32-bit lookup //

						vIdx = ( vIdx + 256 ) & 0x1ff;
						vPixel32_1 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

						// combine pixel
						//vPixel32 = ( vPixel32 & 0xffff ) | ( vPixel32_1 << 16 );
						vPixel32 = bitfieldInsert( vPixel32, vPixel32_1, 16, 16 );

						// no rgb24 when lookup //
					}
					else
					{
						// 16-bit lookup //

						// handle aem for rgb16 //

						// get alpha0 if aem=1

						// get texa0 value
						vPixel24 = TEXA_0 & ( ( AEM ) | ~( vPixel32 - 1 ) );

						// select alpha
						vPixel16 = -( vPixel32 >> 15 );
						vPixel24 = ( TEXA_1 & vPixel16 ) | ( vPixel24 & ~vPixel16 );

						// convert 16-bit pixels to 32-bit pixels
						//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
						vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

						// put in the alpha value
						vPixel32 |= vPixel24;

					}	// end if ( CPSM == 0 )

				}	// end if ( ( TPSM & 7 ) < 3 )

			}	// end if ( ( TEXPSM & 1 ) == 0 )




			// fragment color should already be in vaf, vrf, vgf, vbf
			// split into rgba
			//vat = ivec4( vPixel32 >> 24 ) & 0xff;
			//vrt = ivec4( vPixel32 >> 16 ) & 0xff;
			//vgt = ivec4( vPixel32 >> 8 ) & 0xff;
			//vbt = ivec4( vPixel32 >> 0 ) & 0xff;

			// tfx, tcc

			if ( TFX == 1 )
			{
				//if ( TCC == 0 )
				//{
					//vav = vaf;
					//vPixel32 = ( vPixel32 & 0x00ffffff ) | ( vaf << 24 );
					vPixel32 = bitfieldInsert( vPixel32, vaf, 24, ( TCC ^ 1 ) << 3 );
				//}
			}
			else
			{
				//vat = ivec4( vPixel32 >> 24 ) & 0xff;
				//vrt = ivec4( vPixel32 >> 16 ) & 0xff;
				//vgt = ivec4( vPixel32 >> 8 ) & 0xff;
				//vbt = ivec4( vPixel32 >> 0 ) & 0xff;
				vat = ivec4( bitfieldExtract( vPixel32, 24, 8 ) );
				vrt = ivec4( bitfieldExtract( vPixel32, 16, 8 ) );
				vgt = ivec4( bitfieldExtract( vPixel32, 8, 8 ) );
				vbt = ivec4( bitfieldExtract( vPixel32, 0, 8 ) );

				// handle alpha first

				// do the multiply and add
				vmul = ( vat * vaf ) >> 7;
				vadd = vat + vaf;


				// select multiply/add
				//vat = ( TFX == 0 ) ? vmul : vat;
				//vat = ( TFX == 2 ) ? vadd : vat;
				vmul = bitfieldInsert( vmul, vadd, 0, ( TFX << 3 ) );
				vat = bitfieldInsert( vat, vmul, 0, ( TFX - 3 ) & 0x1f );

				// select af,at
				//vav = ( TCC == 0 ) ? vaf : vat;
				vav = bitfieldInsert( vaf, vat, 0, TCC << 5 );

				// COLCLAMP ??
				//vav &= COLCLAMP;

				vav = clamp( vav, 0, 255 );


				// handle the colors next


				//vadd = ( ( TFX & 0x2 ) == 0 ) ? vZero : vaf;
				//vadd = vaf & -( ( TFX >> 1 ) & 1 );
				vadd = vaf & -( TFX >> 1 );

				// red
				vmul = ( ( vrt * vrf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vrv = ( TFX == 1 ) ? vrt : vmul;
				vrv = clamp( vmul, 0, 255 );

				// green
				vmul = ( ( vgt * vgf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vgv = ( TFX == 1 ) ? vgt : vmul;
				vgv = clamp( vmul, 0, 255 );

				// blue
				vmul = ( ( vbt * vbf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vbv = ( TFX == 1 ) ? vbt : vmul;
				vbv = clamp( vmul, 0, 255 );

				//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
				vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vbv, vav, 24, 8 ), vrv, 16, 8 ), vgv, 8, 8 );
			}

			vTPixel32 = vPixel32;

//#endif

	// re-form pixel //
	//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	// transparency check
	//vTPixel32 = vPixel32;



//#ifdef ENABLE_FOGGING_SPRITE

	if ( FGE == 1 )
	{
		//vav = ivec4( vPixel32 >> 24 ) & 0xff;
		//vrv = ivec4( vPixel32 >> 16 ) & 0xff;
		//vgv = ivec4( vPixel32 >> 8 ) & 0xff;
		//vbv = ivec4( vPixel32 >> 0 ) & 0xff;
		vav = ivec4( bitfieldExtract( vPixel32, 24, 8 ) );
		vrv = ivec4( bitfieldExtract( vPixel32, 16, 8 ) );
		vgv = ivec4( bitfieldExtract( vPixel32, 8, 8 ) );
		vbv = ivec4( bitfieldExtract( vPixel32, 0, 8 ) );

		// should do fogging here
		vrv = ( ( vrv * f0 ) >> 8 ) + ( ( rf0 * FCR ) >> 8 );
		vgv = ( ( vgv * f0 ) >> 8 ) + ( ( rf0 * FCG ) >> 8 );
		vbv = ( ( vbv * f0 ) >> 8 ) + ( ( rf0 * FCB ) >> 8 );

		// COLCLAMP ??
		vrv &= COLCLAMP;
		vgv &= COLCLAMP;
		vbv &= COLCLAMP;

		// fogging clamp (***todo*** COLCLAMP??)
		vrv = clamp ( vrv, 0, 255 );
		vgv = clamp ( vgv, 0, 255 );
		vbv = clamp ( vbv, 0, 255 );

		//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
		vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vbv, vav, 24, 8 ), vrv, 16, 8 ), vgv, 8, 8 );
	}

//#endif


	// re-form pixel //
	//vPixel32_0 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );

	// if not fogging, then use orginal pixel
	//vPixel32 = ( FGE == 0 ) ? vPixel32 : vPixel32_0;




//#ifdef ENABLE_ALPHA_BLEND_SPRITE

	if ( ABE == 1 )
	{
			// alpha blend //


			// A pixel //

			// select
			//mAlphaSelect [ 0 ] = uintBitsToFloat( vPixel32 );
			//mAlphaSelect [ 1 ] = uintBitsToFloat( vDestPixel32 );

			//vPixelA = floatBitsToInt( mAlphaSelect [ ALPHA_A ] );
			//vPixelB = floatBitsToInt( mAlphaSelect [ ALPHA_B ] );
			//vPixelC = floatBitsToInt( mAlphaSelect [ ALPHA_C ] );
			//vPixelD = floatBitsToInt( mAlphaSelect [ ALPHA_D ] );

			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( ALPHA_FIX & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );

			// perform alpha blend calculation //

			// get alpha
			//ivc = ivec4( vPixelC >> 24 ) & 0xff;
			ivc = ivec4( bitfieldExtract( vPixelC, 24, 8 ) );

			// do r
			//iva = ivec4( vPixelA >> 16 ) & 0xff;
			//ivb = ivec4( vPixelB >> 16 ) & 0xff;
			//ivd = ivec4( vPixelD >> 16 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 16, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 16, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 16, 8 ) );

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			//iva = ivec4( vPixelA >> 8 ) & 0xff;
			//ivb = ivec4( vPixelB >> 8 ) & 0xff;
			//ivd = ivec4( vPixelD >> 8 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 8, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 8, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 8, 8 ) );

			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			//iva = ivec4( vPixelA >> 0 ) & 0xff;
			//ivb = ivec4( vPixelB >> 0 ) & 0xff;
			//ivd = ivec4( vPixelD >> 0 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 0, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 0, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 0, 8 ) );

			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			//vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
			vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vPixel32, vrv, 16, 8 ), vgv, 8, 8 ), vbv, 0, 8 );

			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );

	}

//#endif

		// should now be safe for FBA AND FBMSK //
		// set FBA
		vPixel32 |= FBA;

		// FBMSK
		vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );


			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle



//#ifdef ENABLE_SRCALPHA_TEST_SPRITE
			// alpha test //

		//if ( ATE != 0 )
		{
			vTestPixel32 = vTPixel32 >> 24;

			
			uvATSelect = uvec4( ( ( sign( ivec4( vTestPixel32 - vAREF ) ) & iATMask ) + iATOffset ) >> 31 );

			vPixel32 = ( vPixel32 & ( AFAIL_FBMASK | uvATSelect ) ) | ( vDestPixel32 & ~( AFAIL_FBMASK | uvATSelect ) );
			vZPixel32 = ( vZPixel32 & ( AFAIL_ZBMASK | uvATSelect ) ) | ( vZDestPixel32 & ~( AFAIL_ZBMASK | uvATSelect ) );
			

			/*
			bvATST_LESS = lessThan( vTestPixel32, vAREF );
			bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );

			// alpha fail //

			uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );

			// select between afail pixel and pixel
			bvTestMask = notEqual( ivATSelect, vZero );
			vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
			*/
		}

//#endif



//#ifdef ENABLE_DSTALPHA_TEST_SPRITE

		//if ( DATE != 0 )
		{
			// destination alpha test //

			// da test
			uvDASelect = ( vDestPixel32 ^ DATM ) & DATE;
			uvDASelect = ( uvDASelect >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			uvDASelect |= FPSM & 1;

			uvEnable &= uvDASelect;

			//bvTestMask = notEqual( uvDASelect, vZero );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
		}

//#endif



//#ifdef ENABLE_DEPTH_TEST_SPRITE

		//if ( ZTE != 0 )
		{
			// depth test //

			
			uvZTST_EQUAL = usubBorrow( vZDestPixel32, vZPixel32, uvZTST_GREATER );
			uvZSelect = ( sign( ivec4( uvZTST_EQUAL ) ) ^ ZTST_EQUAL ) | uvZTST_GREATER | ZTST_LESS;

			uvEnable &= uvZSelect;
			

			//bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			//bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );
			//bvTestMask = bvec4( ivec4( bvZTST_GREATER ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) ) );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );

		}

//#endif



			uvEnable &= sign( ivec4( vTPixel32 ) );
			uvEnable = -uvEnable;

			// and only the enabled pixels
			vPixel32 = ( vPixel32 & uvEnable ) | ( vDestPixel32 & ~uvEnable );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );

			// also check for transparent pixels in texture (rgba=0??)
			//bvTestMask = notEqual( vTPixel32, vZero );
			//vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );

			// write frame buffer //


			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				//vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );
				vPixel32 = bitfieldInsert( vPixel32, bitfieldExtract( vDPixelX, 24, 8 ), 24, (FPSM & 1) << 3 );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset[0] + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset[0] + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset[0] + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset[0] + 10 ] = vPixel32_0 [ 3 ];
			}



//ifdef ENABLE_WRITE_ZBUFFER_SPRITE

			// write z buffer //

			if ( ZMSK == 0 )
			{
				vZPixel32 = ( vZPixel32 & uvEnable ) | ( vZDestPixel32 & ~uvEnable );

				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					//vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );
					vZPixel32 = bitfieldInsert( vZPixel32, bitfieldExtract( vZPixelX, 24, 8 ), 24, (ZPSM & 1) << 3 );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
				}
			}

//#endif


			//viU += ( dudx * group_vxinc );
			//viU += ( dudx << group_vxinc_shift );
			viU += dudx;

		}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )


		//iV += ( dvdy * yinc );
		//iV += dxdx.y;
		iV += dvdy;
		
	}	// end for ( Line = StartY + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )


#ifdef DRAW_SPRITE_MULTI

		uIndex += 64;

		uIdx += 128;

		Comm = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		//PRIM = Comm & 0xff000017;
		//Comm >>= 24;

		Comm &= 0xff000017;

	} while ( ( ( Comm == 0x16 ) || ( Comm == 0x10 ) ) && ( uIndex < ( COMMAND_LIST_SIZE << 6 ) ) );

	return ( uIndex >> 6 ) - 1;

#else

	return;

#endif

}





#ifdef DRAW_TRIANGLE_COLOR_MULTI
uint Draw_Triangle_Color ( uint uIndex )
#else
void Draw_Triangle_Color ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;
	ivec4 vPtr;
	
	int Temp;
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	uint bgr32;
	//int x, y, w, h;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	//int x0, y0, x1, y1;
	//int z0, z1;
	ivec4 vx, vy;
	uvec4 vz;
	ivec4 vr, vg, vb, va;
	ivec2 vdx;
	//, vdr, vdg, vdb, vda;
	//ivec4 vdxdy, vdrdy, vdgdy, vdbdy, vdady;
	ivec2 vdxdy;
	int drdx, dgdx, dbdx, dadx;
	double dzdx;
	double vdzdy;
	double vdz;

	uvec2 vdz2, vdzdy2, dzdx2;

	int vdr, vdg, vdb, vda;
	int vdrdy, vdgdy, vdbdy, vdady;

	uvec4 Coord;

	int iR, iG, iB, iA;
	ivec4 viR, viG, viB, viA;
	ivec4 vRed, vGreen, vBlue, vAlpha;
	double iZ;
	dvec4 viZ;

	int StartX;
	int EndX;
	int StartY;
	int EndY;


	uint PRIM;
	int FRAME;
	uint FBMSK;

	uint FST, ABE, FGE, PABE;

	int FBP;
	int FBW;
	int FPSM;

	int FrameBufferStartOffset32;
	int FrameBufferWidth_Pixels;

	int yoffset32, zyoffset32;
	int yoffset32_xor, zyoffset32_xor;
	ivec4 vXOffset32, vZXOffset32;

	uint TEST, ATE, ATST, AREF, AFAIL, DATE, DATM, ZTE, ZTST;
	uint AFAIL_FBMASK, AFAIL_ZBMASK, ZTST_LESS, ZTST_GREATER, ZTST_EQUAL;
	bvec4 bvATST_LESS, bvATST_EQUAL, bvATST_GREATER;
	int ATST_LESS, ATST_EQUAL, ATST_GREATER;

	uvec4 uvAFAIL_PIXEL, uvAFAIL_ZPIXEL;

	uint ALPHA;
	uint ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX;
	uint ALPHA_A_SELECT, ALPHA_B_SELECT, ALPHA_C_SELECT, ALPHA_D_SELECT;
	uint ALPHA_A_AND, ALPHA_B_AND, ALPHA_C_AND, ALPHA_D_AND, ALPHA_C_OR;
	uvec4 vALPHA_A_PIXEL, vALPHA_B_PIXEL, vALPHA_C_PIXEL, vALPHA_D_PIXEL;
	uvec4 vAREF;

	uvec4 vPixelA, vPixelB, vPixelC, vPixelD;
	ivec4 iva, ivb, ivc, ivd;

	int ZBUF;
	int ZBP;
	int ZPSM;
	int ZMSK;

	int ZBufferStartOffset32;

	uint FBA;


	ivec4 vIdx;
	ivec4 vIdx32;
	ivec4 vxid;
	ivec4 vx_across;
	ivec4 vOffset;
	ivec4 vZOffset;

	uvec4 vDestPixel16, vDestPixel32, vDestPixel32_0, vDestPixel32_1;
	uvec4 vZDestPixel16, vZDestPixel32, vZDestPixel32_0, vZDestPixel32_1;
	uvec4 vZDestPixel24_1;
	uvec4 vPixel32, vZPixel32;
	uvec4 vPixel24, vZPixel24;
	uvec4 vPixel32_0, vPixel32_1, vZPixel32_0, vZPixel32_1;
	uvec4 vPixel32_2;
	uvec4 vPixel16;
	uvec4 vMask, vMask32;
	ivec4 vPixelShift;

	uvec4 vDPixelX, vZPixelX;

	bvec4 bvALPHA_A_SELECT, bvALPHA_B_SELECT, bvALPHA_C_SELECT, bvALPHA_D_SELECT;
	ivec4 ivAlphaA, ivAlphaB, ivAlphaC, ivAlphaD;
	ivec4 ivRedA, ivRedB, ivRedC, ivRedD;
	ivec4 ivGreenA, ivGreenB, ivGreenC, ivGreenD;
	ivec4 ivBlueA, ivBlueB, ivBlueC, ivBlueD;

	ivec4 ivATSelect, ivDASelect, ivZSelect;
	uvec4 uvATSelect, uvDASelect, uvZSelect;

	//bvec4 bvZTST_LESS, bvZTST_GREATER, bvZTST_EQUAL;
	uvec4 uvZTST_LESS, uvZTST_GREATER, uvZTST_EQUAL;
	bvec4 bvTestMask;
	//bvec4 bvEnable;
	uvec4 uvEnable;

	int iATOffset, iATMask;

	uvec4 vTestPixel32;

	int DRAWPSM, ZBUFPSM;

	ivec4 vav, vrv, vgv, vbv;
	ivec4 vaf, vrf, vgf, vbf;
	ivec4 vat, vrt, vgt, vbt;
	ivec4 vadd, vmul;

	uvec4 uvbgr32;

	int LeftMostX, RightMostX, TopMostY, BottomMostY;
	int t0, t1, denominator;
	int X0Index, X1Index;
	int w;

	ivec4 vrgba0, vrgba1, vrgba2;

	ivec4 drgbadx;
	ivec4 irgba;

	ivec4 vdrgbady;

	ivec4 vdrgba;

	int COLCLAMP;

	int DYNAND, ZYNAND;
	uvec4 uvALPHA_FIX;

	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	uIdx = uIndex << 7;
	uIndex <<= 6;


#ifdef DRAW_TRIANGLE_COLOR_MULTI
	do
	{
#endif


#ifdef CALC_TRIANGLE_COLOR_VARS

		PRIM = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		FST = ( PRIM >> 8 ) & 1;
		ABE = ( PRIM >> 6 ) & 1;
		FGE = ( PRIM >> 5 ) & 1;


		// pixel set //

		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ];
		FBA = ( FBA & 1 ) << 31;

		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		DrawArea_OffsetX = int( inputdata [ uIndex + ( 0 << 1 ) + 0 ] ) & 0xffff;
		DrawArea_OffsetY = int( inputdata [ uIndex + ( 0 << 1 ) + 1 ] ) & 0xffff;

		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		DrawArea_TopLeftY &= 0x7ff;



	Coord.x = uIndex + ( 20 << 1 );
	Coord.y = uIndex + ( 24 << 1 );
	Coord.z = uIndex + ( 28 << 1 );

	// if mono triangle, then copy coord2 to all the colors
	if ( ( PRIM & 0x8 ) == 0 )
	{
		inputdata [ Coord.x + 2 ] = inputdata [ Coord.z + 2 ];
		inputdata [ Coord.y + 2 ] = inputdata [ Coord.z + 2 ];
	}



	///////////////////////////////////
	// put top coordinates in x0,y0
	if ( inputdata [ Coord.y ] < inputdata [ Coord.x ] )
	{
		//Swap ( Coord0, Coord1 );
		Coord.xyz = Coord.yxz;
	}
	
	if ( inputdata [ Coord.z ] < inputdata [ Coord.x ] )
	{
		//Swap ( Coord2, Coord0 );
		Coord.xyz = Coord.zyx;
	}
	
	///////////////////////////////////////
	// put middle coordinates in x1,y1
	if ( inputdata [ Coord.z ] < inputdata [ Coord.y ] )
	{
		//Swap ( Coord2, Coord1 );
		Coord.xyz = Coord.xzy;
	}
	
	// get x,y

	vx.x = int( inputdata [ Coord.x ] );
	vx.y = int( inputdata [ Coord.y ] );
	vx.z = int( inputdata [ Coord.z ] );

	vy = ( vx >> 16 ) & 0xffff;
	vx &= 0xffff;
	
	// get z
	vz.x = inputdata [ Coord.x + 1 ];
	vz.y = inputdata [ Coord.y + 1 ];
	vz.z = inputdata [ Coord.z + 1 ];



	// get r,g,b,a
	va.x = int ( inputdata [ Coord.x + 2 ] );
	va.y = int ( inputdata [ Coord.y + 2 ] );
	va.z = int ( inputdata [ Coord.z + 2 ] );

	vb = ( va >> 0 ) & 0xff;
	vg = ( va >> 8 ) & 0xff;
	vr = ( va >> 16 ) & 0xff;
	va = ( va >> 24 ) & 0xff;

	//////////////////////////////////////////
	// get coordinates on screen
	// *note* this is different from PS1, where you would add the offsets..
	
	vx -= DrawArea_OffsetX;
	vy -= DrawArea_OffsetY;



	
	// get the left/right most x
	LeftMostX = ( ( vx.x < vx.y ) ? vx.x : vx.y );
	LeftMostX = ( ( vx.z < LeftMostX ) ? vx.z : LeftMostX );
	RightMostX = ( ( vx.x > vx.y ) ? vx.x : vx.y );
	RightMostX = ( ( vx.z > RightMostX ) ? vx.z : RightMostX );
	
	LeftMostX >>= 4;
	RightMostX >>= 4;
	TopMostY = vy.x >> 4;
	BottomMostY = vy.z >> 4;


	// put the coords vertical

	vrgba0 = ivec4 ( vr.x, vg.x, vb.x, va.x );
	vrgba1 = ivec4 ( vr.y, vg.y, vb.y, va.y );
	vrgba2 = ivec4 ( vr.z, vg.z, vb.z, va.z );


	t0 = vy.y - vy.z;
	t1 = vy.x - vy.z;
	denominator = ( ( vx.x - vx.z ) * t0 ) - ( ( vx.y - vx.z ) * t1 );
	
	// check if x1 is on left or right //
	//X1Index = 0;
	//X0Index = 1;
	//if ( denominator > 0 )
	//{
	//	// x1 is on the right //
	//	X1Index = 1;
	//	X0Index = 0;
	//}
	
	// calculate across
	if ( denominator != 0 )
	{
		
		// result here should be in x.24 fixed point for now

		// colors //

		//drdx = ( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ) << 12 ) / denominator;
		//dgdx = ( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ) << 12 ) / denominator;
		//dbdx = ( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ) << 12 ) / denominator;
		//dadx = ( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ) << 12 ) / denominator;
		//drdx = intdivf2( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dgdx = intdivf2( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dbdx = intdivf2( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dadx = intdivf2( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ), denominator, 4, 8, 16 );

		drgbadx = intdivfv4( ( ( ( vrgba0 - vrgba2 ) * t0 ) - ( ( vrgba1 - vrgba2 ) * t1 ) ), denominator, 4, 8, 16 );

		
		// ***todo*** need to use a double here
		//dzdx = ( ( ( ( (s64) ( z0 - z2 ) ) * t0 ) - ( ( (s64) ( z1 - z2 ) ) * t1 ) ) << 27 ) / denominator;
		//dzdx = ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 )/16.0 ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 )/16.0 ) ) ) / ( double( denominator )/256.0 );
		dzdx = ( ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 ) ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 ) ) ) ) / ( double( denominator ) ) ) * double( 1 << (16-(4-8)) );


		drdx = drgbadx.r;
		dgdx = drgbadx.g;
		dbdx = drgbadx.b;
		dadx = drgbadx.a;
	}
	
	
	/////////////////////////////////////////////////
	// draw top part of triangle
	
	if ( ( vy.y - vy.x ) != 0 )
	{
		// triangle is pointed on top //

		// need to set the x0 index unconditionally
		//vdx [ X0Index ] = ( vx[0] << 12 );
		vdx.xy = vx.xx << 12;
		
		vdr = vr.x << 16;
		vdg = vg.x << 16;
		vdb = vb.x << 16;
		vda = va.x << 16;

		//vdrgba = vrgba0 << 16;

		vdz = double( vz[0] );


		if ( denominator < 0 )
		{
			//vdxdy [ 0 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
			//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
			vdxdy.xy = intdivfv2( vx.yz - vx.xx, vy.yz - vy.xx, 4, 4, 16 );

			
			vdrdy = intdivf2(( vr.y - vr.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.y - vg.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.y - vb.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdady = intdivf2(( va.y - va.x ), ( vy.y - vy.x ), 0, 4, 16 );

			//vdrgbady = intdivfv4( vrgba1 - vrgba0, vy.y - vy.x, 0, 4, 16 );

			vdzdy = ( ( double(vz[1]) - double(vz[0]) ) / ( double( vy[1] - vy[0] ) ) ) * 16.0;
		}
		else
		{
			//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
			//vdxdy [ 1 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
			vdxdy.xy = intdivfv2( vx.zy - vx.xx, vy.zy - vy.xx, 4, 4, 16 );

			vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

			//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );

			vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
		}
		

	}
	else
	{
		// Triangle is flat on top //


		if ( denominator < 0 )
		{
			// x1 is on left //
			vdx.xy = vx.yx << 12;
			
			vdr = vr.y << 16;
			vdg = vg.y << 16;
			vdb = vb.y << 16;
			vda = va.y << 16;

			//vdrgba = vrgba1 << 16;

			vdz = double( vz[1] );

			if ( ( vy.z - vy.y ) != 0 )
			{
				//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
				//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
				vdxdy.xy = intdivfv2( vx.zz - vx.yx, vy.zz - vy.yx, 4, 4, 16 );
				
				vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

				//vdrgbady = intdivfv4( vrgba2 - vrgba1, vy.z - vy.y, 0, 4, 16 );

				vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;
			}
		}
		else
		{
			// x1 is on right //
			vdx.xy = vx.xy << 12;
			
			vdr = vr.x << 16;
			vdg = vg.x << 16;
			vdb = vb.x << 16;
			vda = va.x << 16;

			//vdrgba = vrgba0 << 16;

			vdz = double( vz[0] );

			if ( ( vy.z - vy.y ) != 0 )
			{
				//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
				//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
				vdxdy.xy = intdivfv2( vx.zz - vx.xy, vy.zz - vy.xy, 4, 4, 16 );
				
				vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

				//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );

				vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
			}
		}
		
	}


		// frame buffer //

		FRAME = int( inputdata [ uIndex + ( 2 << 1 ) + 0 ] );
		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];

		FBP = FRAME & 0x1ff;
		FBW = ( FRAME >> 16 ) & 0x3f;
		FPSM = ( FRAME >> 24 ) & 0x3f;

		// the offset is two times further because of the data arrangement in shader
		FrameBufferStartOffset32 = FBP << 11;
		FrameBufferStartOffset32 <<= 1;

		FrameBufferWidth_Pixels = FBW << 6;

		DRAWPSM = FPSM >> 1;


		// z-buffer //

		ZBUF = int( inputdata [ uIndex + ( 3 << 1 ) + 0 ] );
		ZBP = ZBUF & 0x1ff;
		ZPSM = ( ZBUF >> 24 ) & 0xf;
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) & 1;

		ZBufferStartOffset32 = ZBP << 11;
		ZBufferStartOffset32 <<= 1;

		// add on the missing bits for the zpsm
		ZPSM |= 0x30;

		ZBUFPSM = ZPSM >> 1;


	// pixel test //

	// pixel test
	TEST = inputdata [ uIndex + ( 5 << 1 ) + 0 ];


	// destination alpha test
	DATE = ( ( TEST >> 14 ) & 1 ) << 31;
	DATM = ( ( TEST >> 15 ) & 1 ) << 31;
	
	// depth test
	ZTE = ( TEST >> 16 ) & 1;
	ZTST = ( TEST >> 17 ) & 0x3;

	// alpha test
	ATE = TEST & 1;
	ATST = ( TEST >> 1 ) & 0x7;
	AREF = ( TEST >> 4 ) & 0xff;
	AFAIL = ( TEST >> 12 ) & 0x3;

	// initialize to RGB only on non-RGBA32 format
	AFAIL_FBMASK = -1;
	AFAIL_ZBMASK = -1;

	ATST_LESS = -1;
	ATST_EQUAL = -1;
	ATST_GREATER = -1;
	if ( ATE != 0 )
	{
		// alpha test enabled //

		switch ( ATST )
		{
			// never pass
			case 0:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// always pass
			case 1:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// less
			case 2:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// less or equal
			case 3:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// equal
			case 4:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// greater or equal
			case 5:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// greater
			case 6:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;

			// not equal
			case 7:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;
		}

		switch ( AFAIL )
		{
			// keep/hold
			case 0:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = 0;
				break;

			// only update FB
			case 1:
				AFAIL_FBMASK = -1;
				AFAIL_ZBMASK = 0;
				break;

			// only update ZB
			case 2:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = -1;
				break;

			// only update rgb
			case 3:
				// only if format is RGBA32
				if ( FPSM == 0 )
				{
					AFAIL_FBMASK = 0x00ffffff;
					AFAIL_ZBMASK = 0;
				}
				break;
		}
	}

	// depth test
	ZTST_LESS = -1;
	ZTST_GREATER = -1;
	ZTST_EQUAL = -1;
	if ( ZTE != 0 )
	{
		// depth test enabled //

		switch( ZTST )
		{
			// never
			case 0:
				ZTST_LESS = 0;
				ZTST_GREATER = 0;
				ZTST_EQUAL = 0;
				break;

			// always
			case 1:
				ZTST_LESS = -1;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater or equal
			case 2:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater
			case 3:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = 0;
				break;
		}
	}


	// alpha blending //

	// blending per pixel
	PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;


	ALPHA = inputdata [ uIndex + ( 4 << 1 ) + 0 ];

	// no alpha blending if disabled
	ALPHA &= -ABE;

	ALPHA_A = ( ALPHA >> 0 ) & 0x3;
	ALPHA_B = ( ALPHA >> 2 ) & 0x3;
	ALPHA_C = ( ALPHA >> 4 ) & 0x3;
	ALPHA_D = ( ALPHA >> 6 ) & 0x3;
	ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;




	// draw test //

	bDraw = 1;


	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	

	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) bDraw = 0;

	// left point is included if points are equal
	StartY = ( vy.x + 0xf ) >> 4;
	EndY = ( vy.y - 1 ) >> 4;
	
	Temp = ( StartY << 4 ) - vy[0];

	if ( StartY < DrawArea_TopLeftY )
	{
		if ( EndY < DrawArea_TopLeftY )
		{
			Temp += ( EndY - StartY + 1 ) << 4;
			StartY = EndY + 1;
		}
		else
		{
			Temp += ( DrawArea_TopLeftY - StartY ) << 4;
			StartY = DrawArea_TopLeftY;
		}
	}
	
	
	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += ( vdxdy >> 4 ) * Temp;
	
	vdr += ( vdrdy >> 4 ) * Temp;
	vdg += ( vdgdy >> 4 ) * Temp;
	vdb += ( vdbdy >> 4 ) * Temp;
	vda += ( vdady >> 4 ) * Temp;

	//vdrgba += ( vdrgbady >> 4 ) * Temp;

	//vdz += ( vdzdy ) * ( double( Temp )/16.0 );
	vdz += ( vdzdy ) * ( double( Temp ) * (1.0/16.0) );

	
	if ( EndY > DrawArea_BottomRightY )
	{
		EndY = DrawArea_BottomRightY;
	}

#endif	// end #ifdef CALC_TRIANGLE_COLOR_VARS


#ifdef LOAD_TRIANGLE_COLOR_VARS
	bDraw = data [ uIdx + 0 ];
#endif

	if ( bDraw == 1 )
	{

#ifdef LOAD_TRIANGLE_COLOR_VARS

		// load common settings //

		
		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		//DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		//DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		//DrawArea_TopLeftY &= 0x7ff;

		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) << 31;
		PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;
		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ] << 31;
		ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;
		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		//COLCLAMP = data [ uIdx + 1 ];
		//PABE = data [ uIdx + 2 ];
		//FBA = data [ uIdx + 3 ];

		FPSM = data [ uIdx + 1 ];
		ZPSM = data [ uIdx + 2 ];
		DRAWPSM = data [ uIdx + 3 ];
		ZBUFPSM = data [ uIdx + 4 ];
		FrameBufferStartOffset32 = data [ uIdx + 5 ];
		FrameBufferWidth_Pixels = data [ uIdx + 6 ];
		ZBufferStartOffset32 = data [ uIdx + 7 ];
		
		//FBMSK = data [ uIdx + 8 ];
		//ZMSK = data [ uIdx + 9 ];
		
		AFAIL_FBMASK = data [ uIdx + 8 ];
		AFAIL_ZBMASK = data [ uIdx + 9 ];

		//ALPHA_FIX = data [ uIdx + 10 ];

		ALPHA_A = data [ uIdx + 10 ];
		ALPHA_B = data [ uIdx + 11 ];
		ALPHA_C = data [ uIdx + 12 ];
		ALPHA_D = data [ uIdx + 13 ];
		AREF = data [ uIdx + 14 ];

		//ATST_LESS = data [ uIdx + 15 ];
		//ATST_GREATER = data [ uIdx + 16 ];
		//ATST_EQUAL = data [ uIdx + 17 ];
		iATMask = data [ uIdx + 15 ];
		iATOffset = data [ uIdx + 16 ];

		ZTST_LESS = data [ uIdx + 18 ];
		ZTST_GREATER = data [ uIdx + 19 ];
		ZTST_EQUAL = data [ uIdx + 20 ];
		FGE = data [ uIdx + 21 ];
		DATE = data [ uIdx + 22 ];
		DATM = data [ uIdx + 23 ];
		ABE = data [ uIdx + 24 ];
		
		ZTE = data [ uIdx + 95 ];
		ATE = data [ uIdx + 123 ];
		
		// triangle vars //

		
		//drdx = data [ uIdx + 52 ];
		//dgdx = data [ uIdx + 53 ];
		//dbdx = data [ uIdx + 54 ];
		//dadx = data [ uIdx + 55 ];
		drgbadx = data4 [ ( uIdx + 52 ) >> 2 ];

		//dudx = data [ uIdx + 56 ];
		//dvdx = data [ uIdx + 57 ];
		//dfdx = data [ uIdx + 58 ];

		dzdx2[0] = uint( data [ uIdx + 59 ] );

		//dsdx = intBitsToFloat( data [ uIdx + 60 ] );
		//dtdx = intBitsToFloat( data [ uIdx + 61 ] );
		//dqdx = intBitsToFloat( data [ uIdx + 62 ] );

		dzdx2[1] = uint( data [ uIdx + 63 ] );

		dzdx = packDouble2x32( dzdx2 );

#endif

#ifdef LOAD_TRIANGLE_COLOR_VARS
	ivec2 vyoffset_xor;
	ivec2 vyoffset;
	ivec2 vdzpsm7;
	ivec2 vdzpsm12;
	ivec2 vdzpsm;
	ivec2 vdznand;
	ivec2 vstartoffset;
	ivec4 viStartU;

	DYNAND = LUT_YNAND[ DRAWPSM ];
	ZYNAND = LUT_YNAND[ ZBUFPSM ];
	//TYNAND = LUT_YNAND[ TEXPSM ];


	vdzpsm.x = ( DRAWPSM & 1 ) ^ 1;
	vdzpsm.y = ( ZBUFPSM & 1 ) ^ 1;

	vdzpsm7.x = DRAWPSM << 7;
	vdzpsm7.y = ZBUFPSM << 7;

	vdzpsm12.x = DRAWPSM << 12;
	vdzpsm12.y = ZBUFPSM << 12;

	vdznand.x = LUT_YNAND[ DRAWPSM ];
	vdznand.y = LUT_YNAND[ ZBUFPSM ];

	vstartoffset.x = FrameBufferStartOffset32;
	vstartoffset.y = ZBufferStartOffset32;

	uvALPHA_FIX = uvec4( ALPHA_FIX );

		// first set //

		for ( uLoop = 0; uLoop < 60; uLoop += 32 )
		{

		uIdx += uLoop;

		StartY = data [ uIdx + 64 ];
		EndY = data [ uIdx + 65 ];

		vdx.x = data [ uIdx + 66 ];
		vdx.y = data [ uIdx + 67 ];

		//vdr = data [ uIdx + 68 ];
		//vdg = data [ uIdx + 69 ];
		//vdb = data [ uIdx + 70 ];
		//vda = data [ uIdx + 71 ];
		vdrgba = data4 [ ( uIdx + 68 ) >> 2 ];

		//vdu = data [ uIdx + 72 ];
		//vdv = data [ uIdx + 73 ];
		//vdf = data [ uIdx + 74 ];

		vdz2[0] = uint( data [ uIdx + 75 ] );

		//vds = intBitsToFloat( data [ uIdx + 76 ] );
		//vdt = intBitsToFloat( data [ uIdx + 77 ] );
		//vdq = intBitsToFloat( data [ uIdx + 78 ] );

		vdz2[1] = uint( data [ uIdx + 79 ] );

		vdz = packDouble2x32( vdz2 );


		vdxdy.x = data [ uIdx + 80 ];
		vdxdy.y = data [ uIdx + 81 ];

		// split double and store
		vdzdy2[0] = uint( data [ uIdx + 82 ] );
		vdzdy2[1] = uint( data [ uIdx + 83 ] );
		vdzdy = packDouble2x32( vdzdy2 );

		//vdrdy = data [ uIdx + 84 ];
		//vdgdy = data [ uIdx + 85 ];
		//vdbdy = data [ uIdx + 86 ];
		//vdady = data [ uIdx + 87 ];
		vdrgbady = data4 [ ( uIdx + 84 ) >> 2 ];

		//vdudy = data [ uIdx + 88 ];
		//vdvdy = data [ uIdx + 89 ];
		//vdfdy = data [ uIdx + 90 ];

		//vdsdy = intBitsToFloat( data [ uIdx + 92 ] );
		//vdtdy = intBitsToFloat( data [ uIdx + 93 ] );
		//vdqdy = intBitsToFloat( data [ uIdx + 94 ] );
		
		uIdx -= uLoop;

#endif

	vAREF = uvec4( AREF );


	
	//if ( EndY >= StartY )
	{


	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;


	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += vdxdy * yid;
	
	//vdr += vdrdy * yid;
	//vdg += vdgdy * yid;
	//vdb += vdbdy * yid;
	//vda += vdady * yid;

	vdrgba += vdrgbady * yid;

	//vdz += ( vdzdy ) * ( double( yid ) );
	vdz += ( vdzdy ) * ( double( yid ) );


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		vIdx.xy = vdzpsm7.xy | ( Line & 0x3f );
		vyoffset_xor = ivec2( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ] );
		vyoffset = ( Line & vdznand ) * FrameBufferWidth_Pixels;


		// left point is included if points are equal
		StartX = ( vdx.x + 0xffff ) >> 16;
		EndX = ( vdx.y - 1 ) >> 16;
		
		//if ( StartX <= DrawArea_BottomRightX && EndX >= DrawArea_TopLeftX && EndX >= StartX )
		{

			//iR = vdr;
			//iG = vdg;
			//iB = vdb;
			//iA = vda;
			irgba = vdrgba;

			iZ = vdz;
			
			
			
			// get distance from point to pixel
			Temp = ( StartX << 16 ) - vdx.x;
			
			//if ( StartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - StartX ) << 16;
			//	StartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( StartX, DrawArea_TopLeftX ) ) << 16;
			StartX = max( StartX, DrawArea_TopLeftX );
			
			//iR += ( drdx >> 8 ) * ( Temp >> 8 );
			//iG += ( dgdx >> 8 ) * ( Temp >> 8 );
			//iB += ( dbdx >> 8 ) * ( Temp >> 8 );
			//iA += ( dadx >> 8 ) * ( Temp >> 8 );
			irgba += ( drgbadx >> 8 ) * ( Temp >> 8 );

			// *** todo ****
			//iZ += ( dzdx >> 16 ) * Temp;
			//iZ += dzdx * ( double( Temp )/65536.0 );
			iZ += dzdx * ( double( Temp ) * (1.0/65536.0) );
			
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	//EndX = Window_XRight + 1;
			//	EndX = DrawArea_BottomRightX;
			//}
			EndX = min( EndX, DrawArea_BottomRightX );


			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( StartX & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
			vxid = vxid + group_vxinc * ( ( vxid.w >> 31 ) & 1 );


			//viR = iR + ( vxid * drdx );
			//viG = iG + ( vxid * dgdx );
			//viB = iB + ( vxid * dbdx );
			//viA = iA + ( vxid * dadx );
			viR = irgba.r + ( vxid * drdx );
			viG = irgba.g + ( vxid * dgdx );
			viB = irgba.b + ( vxid * dbdx );
			viA = irgba.a + ( vxid * dadx );

			viZ = iZ + ( dvec4( vxid ) * dzdx );

			
			w = EndX - StartX + 1;

			w &= -( int( StartX <= DrawArea_BottomRightX ) & int( EndX >= DrawArea_TopLeftX ) & int( EndX >= StartX ) );

			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			for ( vx_across = vxid; vx_across.x < w; vx_across += group_vxinc )
			{
				
			// get the pixels to be drawn
			//bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
			usubBorrow( uvec4( vx_across ), uvec4( w ), uvEnable );

			// z value is z0
			//vZPixel32 = ivec4( z0 );
			vZPixel32 = ivec4( viZ );

			// calculate xoffset
			//vIdx = ( vx_across + StartX );
			vIdx.xy = ( ( vx_across.x + StartX ) & 0xfff ) | vdzpsm12.xy;
			vXOffset32.xy = ivec2( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ] );
			vXOffset32.xy ^= vyoffset_xor.xy;
			vOffset.xy = vXOffset32.xy + vyoffset.xy;
			vOffset.xy <<= vdzpsm.xy;
			vOffset.xy += vstartoffset.xy;

			vZOffset[0] = vOffset.y;



			// x-bit pixels //

			vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];

			// combine
			vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );

			vDPixelX = vDestPixel32;

			// extract
			vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
			}



			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );



			// x-bit zpixels //

			vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];

			// combine
			vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );

			vZPixelX = vZDestPixel32;

			// extract
			vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );



			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );

			// load pixel to draw //

			// ***TODO*** this is a PROBLEM, since iR, iG, iB, iA are signed 32-bit values, so below can easily get wrong colors!
			vRed = viR >> 16;
			vGreen = viG >> 16;
			vBlue = viB >> 16;
			vAlpha = viA >> 16;
			
			// clamp
			// *** NOTE *** need to clamp here since we are using s32 instead of s64 for iR,iG,iB,iA
			//vRed &= 0xff;
			//vGreen &= 0xff;
			//vBlue &= 0xff;
			//vAlpha &= 0xff;
			
			vPixel32 = ( vAlpha << 24 ) | ( vRed << 16 ) | ( vGreen << 8 ) | vBlue;



//#ifdef ENABLE_ALPHA_BLEND
		if ( ABE == 1 )
		{
			// alpha blend //

			// A pixel //

			// select
			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( uvec4( ALPHA_FIX ) & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );


			// perform alpha blend calculation //

			// get alpha
			ivc = ivec4( vPixelC >> 24 ) & 0xff;

			// do r
			iva = ivec4( vPixelA >> 16 ) & 0xff;
			ivb = ivec4( vPixelB >> 16 ) & 0xff;
			ivd = ivec4( vPixelD >> 16 ) & 0xff;

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			iva = ivec4( vPixelA >> 8 ) & 0xff;
			ivb = ivec4( vPixelB >> 8 ) & 0xff;
			ivd = ivec4( vPixelD >> 8 ) & 0xff;
			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;
			iva = ivec4( vPixelA >> 0 ) & 0xff;
			ivb = ivec4( vPixelB >> 0 ) & 0xff;
			ivd = ivec4( vPixelD >> 0 ) & 0xff;
			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );


			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );
		}
//#endif

			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle

//#ifdef ENABLE_SRCALPHA_TEST
			// alpha test //

			vTestPixel32 = vPixel32 >> 24;


			// should now be safe for FBA AND FBMSK //
			// set FBA
			vPixel32 |= FBA;

			// FBMSK
			vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );

		//if ( ATE != 0 )
		{
			uvATSelect = uvec4( ( ( sign( ivec4( vTestPixel32 - vAREF ) ) & iATMask ) + iATOffset ) >> 31 );

			vPixel32 = ( vPixel32 & ( AFAIL_FBMASK | uvATSelect ) ) | ( vDestPixel32 & ~( AFAIL_FBMASK | uvATSelect ) );
			vZPixel32 = ( vZPixel32 & ( AFAIL_ZBMASK | uvATSelect ) ) | ( vZDestPixel32 & ~( AFAIL_ZBMASK | uvATSelect ) );

			//bvATST_LESS = lessThan( vTestPixel32, vAREF );
			//bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			//bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			//ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );

			// alpha fail //

			//uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			//uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );

			// select between afail pixel and pixel
			//bvTestMask = notEqual( ivATSelect, vZero );
			//vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			//vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
		}

//#endif

//#ifdef ENABLE_DSTALPHA_TEST
		//if ( DATE != 0 )
		{
			// destination alpha test //

			// da test
			uvDASelect = ( vDestPixel32 ^ DATM ) & DATE;
			uvDASelect = ( uvDASelect >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			uvDASelect |= FPSM & 1;

			uvEnable &= uvDASelect;

			/*
			// da test
			ivDASelect = ivec4( ( vDestPixel32 ^ DATM ) & DATE );
			ivDASelect = ivec4( uvec4( ivDASelect ) >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			ivDASelect |= FPSM & 1;

			bvTestMask = notEqual( ivDASelect, vZero );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
			*/
		}

//#endif

//#ifdef ENABLE_DEPTH_TEST
		//if ( ZTE != 0 )
		{
			// depth test //

			uvZTST_EQUAL = usubBorrow( vZDestPixel32, vZPixel32, uvZTST_GREATER );
			uvZSelect = ( sign( ivec4( uvZTST_EQUAL ) ) ^ ZTST_EQUAL ) | uvZTST_GREATER | ZTST_LESS;

			uvEnable &= uvZSelect;

			/*
			bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );
			bvTestMask = bvec4( ivec4( bvZTST_GREATER ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) ) );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
			*/
		}
//#endif


			// and only the enabled pixels
			//uvEnable &= sign( ivec4( vTPixel32 ) );
			uvEnable = -uvEnable;

			// and only the enabled pixels
			vPixel32 = ( vPixel32 & uvEnable ) | ( vDestPixel32 & ~uvEnable );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );



			// write frame buffer //



			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				//vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );
				vPixel32 = bitfieldInsert( vPixel32, bitfieldExtract( vDPixelX, 24, 8 ), 24, (FPSM & 1) << 3 );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset[0] + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset[0] + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset[0] + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset[0] + 10 ] = vPixel32_0 [ 3 ];
			}



//#ifdef ENABLE_WRITE_ZBUFFER
			// write z buffer //


			if ( ZMSK == 0 )
			{
				vZPixel32 = ( vZPixel32 & uvEnable ) | ( vZDestPixel32 & ~uvEnable );

				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					//vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );
					vZPixel32 = bitfieldInsert( vZPixel32, bitfieldExtract( vZPixelX, 24, 8 ), 24, (ZPSM & 1) << 3 );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
				}
			}


//#endif


				viR += drdx << group_vxinc_shift;
				viG += dgdx << group_vxinc_shift;
				viB += dbdx << group_vxinc_shift;
				viA += dadx << group_vxinc_shift;

				// *** todo ***
				viZ += dzdx * double( group_vxinc );
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//vdx += vdxdy * group_yinc;
		vdx += vdxdy << group_yinc_shift;
		
		//vdr += vdrdy << group_yinc_shift;
		//vdg += vdgdy << group_yinc_shift;
		//vdb += vdbdy << group_yinc_shift;
		//vda += vdady << group_yinc_shift;
		vdrgba += vdrgbady << group_yinc_shift;

		// *** todo ***
		vdz += vdzdy * double( group_yinc );
	}
	
	} // end if ( EndY >= StartY )


#ifdef LOAD_TRIANGLE_COLOR_VARS

	}	// end for ( uLoop = 0; uLoop < 60; uLoop += 32 )

#endif

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	
#ifdef CALC_TRIANGLE_COLOR_VARS

	if ( denominator < 0 )
	{
		vdx.x = vx.y << 12;
		vdx.y = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.y >> 4 ) );
		
		vdr = vr.y << 16;
		vdg = vg.y << 16;
		vdb = vb.y << 16;
		vda = va.y << 16;

		vdz = double( vz[1] );

		
		if ( ( vy.z - vy.y ) != 0 )
		{
			// triangle is pointed on the bottom //
			vdxdy.x = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
			
			vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

			vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;

		}
		
	}
	else
	{
		vdx.y = vx.y << 12;
		vdx.x = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.x >> 4 ) );
		
		vdr = ( vr.x << 16 ) + ( ( vy.y - vy.x ) * ( vdrdy >> 4 ) );
		vdg = ( vg.x << 16 ) + ( ( vy.y - vy.x ) * ( vdgdy >> 4 ) );
		vdb = ( vb.x << 16 ) + ( ( vy.y - vy.x ) * ( vdbdy >> 4 ) );
		vda = ( va.x << 16 ) + ( ( vy.y - vy.x ) * ( vdady >> 4 ) );

		//vdz = double(vz[0]) + ( (double( vy.y - vy.x )/16.0) * vdzdy );
		vdz = double(vz[0]) + ( ( double( vy.y - vy.x ) * (1.0/16.0) ) * vdzdy );

		if ( ( vy.z - vy.y ) != 0 )
		{
			// triangle is pointed on the bottom //
			vdxdy.y = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
		}
	}
	
	

	// left point is included if points are equal
	StartY = ( vy.y + 0xf ) >> 4;
	EndY = ( vy.z - 1 ) >> 4;
	
	Temp = ( StartY << 4 ) - vy.y;
	

	if ( StartY < DrawArea_TopLeftY )
	{
		if ( EndY < DrawArea_TopLeftY )
		{
			Temp += ( EndY - StartY + 1 ) << 4;
			StartY = EndY + 1;
		}
		else
		{
			Temp += ( DrawArea_TopLeftY - StartY ) << 4;
			StartY = DrawArea_TopLeftY;
		}
	}	
	
	
	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += ( vdxdy >> 4 ) * Temp;
	
	vdr += ( vdrdy >> 4 ) * Temp;
	vdg += ( vdgdy >> 4 ) * Temp;
	vdb += ( vdbdy >> 4 ) * Temp;
	vda += ( vdady >> 4 ) * Temp;

	//vdz += ( vdzdy ) * ( double( Temp )/16.0 );
	vdz += ( vdzdy ) * ( double( Temp ) * (1.0/16.0) );


	if ( EndY > DrawArea_BottomRightY )
	{
		//EndY = Window_YBottom + 1;
		EndY = DrawArea_BottomRightY;
	}


#ifdef LOAD_TRIANGLE_COLOR_VARS

		// second set //

		
		StartY = data [ uIdx + 96 ];
		EndY = data [ uIdx + 97 ];

		vdx.x = data [ uIdx + 98 ];
		vdx.y = data [ uIdx + 99 ];

		vdr = data [ uIdx + 100 ];
		vdg = data [ uIdx + 101 ];
		vdb = data [ uIdx + 102 ];
		vda = data [ uIdx + 103 ];

		//vdu = data [ uIdx + 104 ];
		//vdv = data [ uIdx + 105 ];
		//vdf = data [ uIdx + 106 ];

		vdz2[0] = uint( data [ uIdx + 107 ] );

		//vds = intBitsToFloat( data [ uIdx + 108 ] );
		//vdt = intBitsToFloat( data [ uIdx + 109 ] );
		//vdq = intBitsToFloat( data [ uIdx + 110 ] );

		vdz2[1] = uint( data [ uIdx + 111 ] );

		vdz = packDouble2x32( vdz2 );


		vdxdy.x = data [ uIdx + 112 ];
		vdxdy.y = data [ uIdx + 113 ];

		vdzdy2[0] = uint( data [ uIdx + 114 ] );
		vdzdy2[1] = uint( data [ uIdx + 115 ] );
		vdzdy = packDouble2x32( vdzdy2 );

		vdrdy = data [ uIdx + 116 ];
		vdgdy = data [ uIdx + 117 ];
		vdbdy = data [ uIdx + 118 ];
		vdady = data [ uIdx + 119 ];

		//vdudy = data [ uIdx + 120 ];
		//vdvdy = data [ uIdx + 121 ];
		//vdfdy = data [ uIdx + 122 ];

		//vdsdy = intBitsToFloat( data [ uIdx + 124 ] );
		//vdtdy = intBitsToFloat( data [ uIdx + 125 ] );
		//vdqdy = intBitsToFloat( data [ uIdx + 126 ] );
		

#endif	// end #ifdef LOAD_TRIANGLE_COLOR_VARS


	if ( EndY >= StartY )
	{


	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;


	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += vdxdy * yid;
	
	vdr += vdrdy * yid;
	vdg += vdgdy * yid;
	vdb += vdbdy * yid;
	vda += vdady * yid;

	//vdz += ( vdzdy ) * ( double( Temp )/16.0 );
	vdz += ( vdzdy ) * ( double( yid ) );


	vIdx.zw = ivec2( DRAWPSM << 12, ZBUFPSM << 12 );
	vXOffset.zw = ivec2( ( DRAWPSM & 1 ) ^ 1, ( ZBUFPSM & 1 ) ^ 1 );
	vOffset.zw = ivec2( FrameBufferStartOffset32, ZBufferStartOffset32 );

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line <= EndY; Line++ )
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		// get the y-offset for row
		yoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( DRAWPSM << 7 ) ];
		yoffset32 = ( Line & LUT_YNAND[ DRAWPSM ] ) * ( FrameBufferWidth_Pixels );

		zyoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( ZBUFPSM << 7 ) ];
		zyoffset32 = ( Line & LUT_YNAND[ ZBUFPSM ] ) * ( FrameBufferWidth_Pixels );

		// left point is included if points are equal
		StartX = ( vdx.x + 0xffff ) >> 16;
		EndX = ( vdx.y - 1 ) >> 16;
		
		if ( StartX <= DrawArea_BottomRightX && EndX >= DrawArea_TopLeftX && EndX >= StartX )
		{

			iR = vdr;
			iG = vdg;
			iB = vdb;
			iA = vda;

			iZ = vdz;
			
			
			// get distance from point to pixel
			Temp = ( StartX << 16 ) - vdx.x;
			
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - StartX ) << 16;
				StartX = DrawArea_TopLeftX;
			}
			
			iR += ( drdx >> 8 ) * ( Temp >> 8 );
			iG += ( dgdx >> 8 ) * ( Temp >> 8 );
			iB += ( dbdx >> 8 ) * ( Temp >> 8 );
			iA += ( dadx >> 8 ) * ( Temp >> 8 );

			//iZ += dzdx * ( double( Temp )/65536.0 );
			iZ += dzdx * ( double( Temp ) * (1.0/65536.0) );
			
			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = Window_XRight + 1;
				EndX = DrawArea_BottomRightX;
			}


			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( StartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


			viR = iR + ( vxid * drdx );
			viG = iG + ( vxid * dgdx );
			viB = iB + ( vxid * dbdx );
			viA = iA + ( vxid * dadx );

			viZ = iZ + ( dvec4( vxid ) * dzdx );

			
			w = EndX - StartX + 1;


			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = StartX; x_across <= EndX; x_across += c_iVectorSize )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
					
				
				
				
			// get the pixels to be drawn
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

			// z value is z0
			//vZPixel32 = ivec4( z0 );
			vZPixel32 = ivec4( viZ );

			// calculate xoffset
			vIdx.xy = ( vx_across + StartX ) & 0x0fff;

			vIdx.xy |= vIdx.zw;
			vXOffset.xy = ivec2( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ] );
			vXOffset.xy ^= yoffset32_xor;
			vOffset.xy = vXOffset32.xy + yoffset32;
			vOffset.xy <<= vXOffset.zw;
			vOffset.xy += vOffset.zw;

			/*
			vIdx = ( vIdx & 0x0fff ) | ( DRAWPSM << 12 );
			vXOffset32[0] = LUT_XOFFSET [ vIdx[0] ];
			vXOffset32 ^= yoffset32_xor;
			vOffset = vXOffset32 + yoffset32;
			vOffset <<= ( DRAWPSM & 1 ) ^ 1;
			vOffset += FrameBufferStartOffset32;

			vIdx = ( vIdx & 0x0fff ) | ( ZBUFPSM << 12 );
			vZXOffset32[0] = LUT_XOFFSET [ vIdx[0] ];
			vZXOffset32 ^= zyoffset32_xor;
			vZOffset = vZXOffset32 + zyoffset32;
			vZOffset <<= ( ZBUFPSM & 1 ) ^ 1;
			vZOffset += ZBufferStartOffset32;
			*/

#ifdef USE_TRIANGLE_MULTI_PIXEL

			// x-bit pixels //

			//vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			//vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];
			vDestPixel32_0 = VRAM4[ ( vOffset.x >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset.x >> 2 ) + 2 ];

			// combine
			vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );

			vDPixelX = vDestPixel32;

			// extract
			//vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );
			vDestPixel32 >>= ( ( vOffset.x & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
			}

#else

			
			// pull the pixels //
			vDestPixel32_0 = uvec4( VRAM[vOffset[0]], VRAM[vOffset[1]], VRAM[vOffset[2]], VRAM[vOffset[3]] );

			// get upper pixels
			vDestPixel32_1 = uvec4( VRAM[vOffset[0]+1], VRAM[vOffset[1]+1], VRAM[vOffset[2]+1], VRAM[vOffset[3]+1] );

			
			// make 32-bit pixels
			vDestPixel32 = ( vDestPixel32_0 & 0xffff ) | ( vDestPixel32_1 << 16 );

			// if destination pixel is 16-bit, need to convert to 32-bit and include alpha for alpha blending, etc
			vPixel16 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
			vDestPixel32 = ( ( DRAWPSM & 1 ) == 0 ) ? vDestPixel32 : vPixel16;

			// save the original pixel from the dest for later (da test)
			vDPixelX = vDestPixel32;
#endif


			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );


#ifdef USE_TRIANGLE_MULTI_ZPIXEL

			// x-bit zpixels //

			//vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			//vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];
			vZDestPixel32_0 = VRAM4[ ( vOffset.y >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vOffset.y >> 2 ) + 2 ];

			// combine
			vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );

			vZPixelX = vZDestPixel32;

			// extract
			//vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );
			vZDestPixel32 >>= ( ( vOffset.y & ZBUFPSM & 1 ) << 4 );

#else

			// pull the z-pixels //
			vZDestPixel32_0 = uvec4( VRAM[vZOffset[0]], VRAM[vZOffset[1]], VRAM[vZOffset[2]], VRAM[vZOffset[3]] );

			// get upper z-pixels
			vZDestPixel32_1 = uvec4( VRAM[vZOffset[0]+1], VRAM[vZOffset[1]+1], VRAM[vZOffset[2]+1], VRAM[vZOffset[3]+1] );

			// make 32-bit z-pixels
			vZDestPixel32 = ( vZDestPixel32_0 & 0xffff ) | ( vZDestPixel32_1 << 16 );

			vZPixelX = vZDestPixel32;
#endif


			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );

			// load pixel to draw //

			// ***TODO*** this is a PROBLEM, since iR, iG, iB, iA are signed 32-bit values, so below can easily get wrong colors!
			vRed = viR >> 16;
			vGreen = viG >> 16;
			vBlue = viB >> 16;
			vAlpha = viA >> 16;
			
			// clamp
			// *** NOTE *** need to clamp here since we are using s32 instead of s64 for iR,iG,iB,iA
			//vRed &= 0xff;
			//vGreen &= 0xff;
			//vBlue &= 0xff;
			//vAlpha &= 0xff;
			
			vPixel32 = ( vAlpha << 24 ) | ( vRed << 16 ) | ( vGreen << 8 ) | vBlue;



//#ifdef ENABLE_ALPHA_BLEND

		if ( ABE == 1 )
		{
			// alpha blend //


			// A pixel //

			// select
			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( uvec4( ALPHA_FIX ) & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );


			// perform alpha blend calculation //

			// get alpha
			ivc = ivec4( vPixelC >> 24 ) & 0xff;

			// do r
			iva = ivec4( vPixelA >> 16 ) & 0xff;
			ivb = ivec4( vPixelB >> 16 ) & 0xff;
			ivd = ivec4( vPixelD >> 16 ) & 0xff;

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			iva = ivec4( vPixelA >> 8 ) & 0xff;
			ivb = ivec4( vPixelB >> 8 ) & 0xff;
			ivd = ivec4( vPixelD >> 8 ) & 0xff;
			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;
			iva = ivec4( vPixelA >> 0 ) & 0xff;
			ivb = ivec4( vPixelB >> 0 ) & 0xff;
			ivd = ivec4( vPixelD >> 0 ) & 0xff;
			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );


			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );
		}
//#endif

			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle

//#ifdef ENABLE_SRCALPHA_TEST
			// alpha test //

			vTestPixel32 = vPixel32 >> 24;


			// should now be safe for FBA AND FBMSK //
			// set FBA
			vPixel32 |= FBA;

			// FBMSK
			vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );


			bvATST_LESS = lessThan( vTestPixel32, vAREF );
			bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );

			// alpha fail //

			uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );

			// select between afail pixel and pixel
			bvTestMask = notEqual( ivATSelect, vZero );
			vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
//#endif

//#ifdef ENABLE_DSTALPHA_TEST
			// destination alpha test //

			// calc 16-bit pixel
			//vPixel16 = ( ( vDPixelX << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDPixelX << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDPixelX << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDPixelX << 16 ) & ( 0x80 << 24 ) );

			// use 16-bit pixel if 16-bit frame-buffer
			//vDPixelX = ( ( DRAWPSM & 1 ) == 0 ) ? vDPixelX : vPixel16;
			//vDPixelX <<= ( DRAWPSM & 1 ) << 4;

			// da test
			ivDASelect = ivec4( ( vDestPixel32 ^ DATM ) & DATE );
			ivDASelect = ivec4( uvec4( ivDASelect ) >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			//vDPixelX = ( ( FPSM & 1 ) == 0 ) ? vDPixelX : vZero;
			ivDASelect |= FPSM & 1;

			//ivDASelect = ( ivec4( vDestPixel32 ^ DATM ) | int( DATE ) ) >> 31;
//#endif

//#ifdef ENABLE_DEPTH_TEST
			// depth test //

			bvZTST_LESS = lessThan( vZPixel32, vZDestPixel32 );
			bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );
			ivZSelect = ( ivec4( bvZTST_LESS ) & int( ZTST_LESS ) ) | ( ivec4( bvZTST_GREATER ) & int( ZTST_GREATER ) ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) );
//#endif




//#ifdef ENABLE_PIXEL_TEST
			// select pixels
			bvTestMask = notEqual( ivZSelect & ivDASelect, vZero );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
//#endif

			// and only the enabled pixels
			vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );



			// write frame buffer //



			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				//VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				//VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
				VRAM4 [ ( vOffset.x >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset.x >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset.x + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset.x + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset.x + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset.x + 10 ] = vPixel32_0 [ 3 ];
			}



//#ifdef ENABLE_WRITE_ZBUFFER
			// write z buffer //



			if ( ZMSK == 0 )
			{
				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					//VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					//VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
					VRAM4 [ ( vZOffset.y >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset.y >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					//VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					//VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					//VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					//VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
					VRAM[ vOffset.y + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vOffset.y + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vOffset.y + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vOffset.y + 10 ] = vZPixel32 [ 3 ];
				}
			}



//#endif


				//viR += drdx * group_vxinc;
				//viG += dgdx * group_vxinc;
				//viB += dbdx * group_vxinc;
				//viA += dadx * group_vxinc;
				viR += drdx << group_vxinc_shift;
				viG += dgdx << group_vxinc_shift;
				viB += dbdx << group_vxinc_shift;
				viA += dadx << group_vxinc_shift;

				// *** todo ***
				viZ += dzdx * double( group_vxinc );
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//vdx += vdxdy * group_yinc;
		vdx += vdxdy << group_yinc_shift;
		
		//vdr += vdrdy * group_yinc;
		//vdg += vdgdy * group_yinc;
		//vdb += vdbdy * group_yinc;
		//vda += vdady * group_yinc;
		vdr += vdrdy << group_yinc_shift;
		vdg += vdgdy << group_yinc_shift;
		vdb += vdbdy << group_yinc_shift;
		vda += vdady << group_yinc_shift;

		vdz += vdzdy * double( group_yinc );
	}
	
	} // end if ( EndY >= StartY )

#endif


	}	// end if ( bDraw == 1 )


#ifdef DRAW_TRIANGLE_COLOR_MULTI

		uIndex += 64;

		uIdx += 128;

		Comm = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		//PRIM = Comm & 0x17;
		//Comm >>= 24;

		Comm &= 0xff000017;

	} while ( ( Comm >= 0x03 ) && ( Comm <= 0x05 ) && ( uIndex < ( COMMAND_LIST_SIZE << 6 ) ) );

	return ( uIndex >> 6 ) - 1;

#else

	return;

#endif

}








#ifdef DRAW_TRIANGLE_TEXTURE_MULTI
uint Draw_Triangle_Texture ( uint uIndex )
#else
void Draw_Triangle_Texture ( uint uIndex )
#endif
{
	//int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;
	ivec4 vPtr;
	
	int Temp;

	// common object vars //

	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;

	uint PRIM;
	int FRAME;
	uint FBMSK;

	uint FST, ABE, FGE, PABE;
	uint FOGCOL;
	int FCR, FCG, FCB;

	int FBP;
	int FBW;
	int FPSM;

	int FrameBufferStartOffset32;
	int FrameBufferWidth_Pixels;

	uint TEST, ATE, ATST, AREF, AFAIL, DATE, DATM, ZTE, ZTST;
	uint AFAIL_FBMASK, AFAIL_ZBMASK, ZTST_LESS, ZTST_GREATER, ZTST_EQUAL;
	int ATST_LESS, ATST_EQUAL, ATST_GREATER;
	bvec4 bvATST_LESS, bvATST_EQUAL, bvATST_GREATER;
	uvec4 uvAFAIL_PIXEL, uvAFAIL_ZPIXEL;

	uint ALPHA;
	uint ALPHA_A, ALPHA_B, ALPHA_C, ALPHA_D, ALPHA_FIX;
	uint ALPHA_A_SELECT, ALPHA_B_SELECT, ALPHA_C_SELECT, ALPHA_D_SELECT;
	uint ALPHA_A_AND, ALPHA_B_AND, ALPHA_C_AND, ALPHA_D_AND, ALPHA_C_OR;
	uvec4 vALPHA_A_PIXEL, vALPHA_B_PIXEL, vALPHA_C_PIXEL, vALPHA_D_PIXEL;
	uvec4 vAREF;

	int ZBUF;
	int ZBP;
	int ZPSM;
	int ZMSK;

	int ZBufferStartOffset32;

	int DRAWPSM, ZBUFPSM;

	uint FBA;

	int CLAMP_0, CLAMP_1;
	int WMS, WMT;
	int MINU, MAXU, MINV, MAXV;
	int TexY_And, TexY_Or, TexY_Min, TexY_Max;
	int TexX_And, TexX_Or, TexX_Min, TexX_Max;

	int AEM;
	int TEXA_0, TEXA_1;

	int TEX0_0, TEX0_1;
	int TBP0, TBW, TPSM, TW, TH;
	int TEXPSM;
	int TexWidth, TexHeight;
	int TexWidth_Mask, TexHeight_Mask;
	int TCC, TFX;
	int CBP, CPSM, CSM, CSA, CLD;
	int CLUTStartOffset32;

	int TextureBufferStartOffset32;
	int TextureBufferWidth_Pixels;

	int COLCLAMP;

	int StartX;
	int EndX;
	int StartY;
	int EndY;


	// common triangle vars //

	uvec4 Coord;

	int LeftMostX, RightMostX, TopMostY, BottomMostY;
	int t0, t1, denominator;
	//int X0Index, X1Index;
	int w;

	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	uint bgr32;
	ivec3 vx, vy;
	uvec3 vz;

	ivec2 vdx;
	ivec2 vdxdy;

	ivec4 vr, vg, vb, va;
	int vdr, vdg, vdb, vda;

	int vdrdy, vdgdy, vdbdy, vdady;

	int drdx, dgdx, dbdx, dadx;
	double dzdx;
	double vdz;
	double vdzdy;

	uvec2 vdz2, vdzdy2, dzdx2;

	int iR, iG, iB, iA;
	ivec4 viR, viG, viB, viA;
	ivec4 vRed, vGreen, vBlue, vAlpha;
	double iZ;
	dvec4 viZ;




	int yoffset32, zyoffset32;
	int yoffset32_xor, zyoffset32_xor;
	ivec4 vXOffset32, vZXOffset32;


	uvec4 vPixelA, vPixelB, vPixelC, vPixelD;
	ivec4 iva, ivb, ivc, ivd;



	ivec4 vIdx;
	ivec4 vIdx32;
	ivec4 vxid;
	ivec4 vx_across;
	ivec4 vOffset;
	ivec4 vZOffset;

	uvec4 vDestPixel16, vDestPixel32, vDestPixel32_0, vDestPixel32_1;
	uvec4 vZDestPixel16, vZDestPixel32, vZDestPixel32_0, vZDestPixel32_1;
	uvec4 vZDestPixel24_1;
	uvec4 vPixel32, vZPixel32;
	uvec4 vPixel24, vZPixel24;
	uvec4 vPixel32_0, vPixel32_1, vZPixel32_0, vZPixel32_1;
	uvec4 vPixel32_2;
	uvec4 vPixel16;
	uvec4 vMask, vMask32;
	ivec4 vPixelShift;

	uvec4 vDPixelX, vZPixelX;

	bvec4 bvALPHA_A_SELECT, bvALPHA_B_SELECT, bvALPHA_C_SELECT, bvALPHA_D_SELECT;
	ivec4 ivAlphaA, ivAlphaB, ivAlphaC, ivAlphaD;
	ivec4 ivRedA, ivRedB, ivRedC, ivRedD;
	ivec4 ivGreenA, ivGreenB, ivGreenC, ivGreenD;
	ivec4 ivBlueA, ivBlueB, ivBlueC, ivBlueD;

	ivec4 ivATSelect, ivDASelect, ivZSelect;
	uvec4 uvATSelect, uvDASelect, uvZSelect;

	//bvec4 bvZTST_LESS, bvZTST_GREATER, bvZTST_EQUAL;
	uvec4 uvZTST_GREATER, uvZTST_EQUAL;
	bvec4 bvTestMask;
	//bvec4 bvEnable;
	uvec4 uvEnable;

	uvec4 vTestPixel32;


	ivec4 vav, vrv, vgv, vbv;
	ivec4 vaf, vrf, vgf, vbf;
	ivec4 vat, vrt, vgt, vbt;
	ivec4 vadd, vmul;

	uvec4 uvbgr32;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// texture vars //

	uvec4 vTPixel32;
	int iAnd1, iShift1, iShift2, iAnd3, iShift3;

	int dudx, dvdx, dfdx;
	float dsdx, dtdx, dqdx;

	int vdu, vdv, vdf;
	float vds, vdt, vdq;

	int vdudy, vdvdy, vdfdy;
	float vdsdy, vdtdy, vdqdy;

	int iU, iV, iF;
	float fS, fT, fQ;

	ivec4 viU, viV, viF;
	vec4 vfS, vfT, vfQ;

	ivec4 vf0, vrf0;


	ivec4 vTexCoordX, vTXOffset, vTOffset;
	ivec4 vTexCoordY;
	//ivec2 vTexCoordUV, vTexCoordST;
	ivec4 viTYOffset, vxTYOffset;


	int f0, f1;
	int rf0;

	ivec3 vu, vv;
	ivec3 vf;
	vec3 vs, vt, vq;


	ivec4 vrgba0, vrgba1, vrgba2;
	ivec3 vuvf0, vuvf1, vuvf2;
	vec3 vstq0, vstq1, vstq2;

	ivec4 drgbadx;
	ivec4 duvfdx;
	vec4 dstqdx;

	ivec4 vdrgbady;
	ivec4 vduvfdy;
	vec4 vdstqdy;

	vec4 vyvdstqdy;
	double vyvdzdy;

	ivec4 vdrgba;
	ivec4 vduvf;
	vec4 vdstq;

	float vxdsdx;
	float vxdtdx;
	float vxdqdx;
	double vxdzdx;

	ivec4 irgba, iuvf;
	vec4 ifstq;

	ivec4 vTemp;

	uvec4 uvAlphaSelect [ 4 ];

	uvec4 uvTEXA_0;
	uvec4 uvTEXA_1;
	uvec4 uvALPHA_FIX;

	int iATOffset, iATMask;

	int DYNAND, ZYNAND, TYNAND;

	uIdx = uIndex << 7;
	uIndex <<= 6;


#ifdef DRAW_TRIANGLE_TEXTURE_MULTI
	do
	{
#endif


#ifdef CALC_TRIANGLE_TEXTURE_VARS

	
		PRIM = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		FST = ( PRIM >> 8 ) & 1;
		ABE = ( PRIM >> 6 ) & 1;
		FGE = ( PRIM >> 5 ) & 1;


		// pixel set //

		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ];
		FBA = ( FBA & 1 ) << 31;

		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		DrawArea_OffsetX = int( inputdata [ uIndex + ( 0 << 1 ) + 0 ] ) & 0xffff;
		DrawArea_OffsetY = int( inputdata [ uIndex + ( 0 << 1 ) + 1 ] ) & 0xffff;

		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		DrawArea_TopLeftY &= 0x7ff;


	bDraw = 1;

	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	

	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}


		// frame buffer //

		FRAME = int( inputdata [ uIndex + ( 2 << 1 ) + 0 ] );
		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];

		FBP = FRAME & 0x1ff;
		FBW = ( FRAME >> 16 ) & 0x3f;
		FPSM = ( FRAME >> 24 ) & 0x3f;

		// the offset is two times further because of the data arrangement in shader
		FrameBufferStartOffset32 = FBP << 11;
		FrameBufferStartOffset32 <<= 1;

		FrameBufferWidth_Pixels = FBW << 6;

		DRAWPSM = FPSM >> 1;


		// z-buffer //

		ZBUF = int( inputdata [ uIndex + ( 3 << 1 ) + 0 ] );
		ZBP = ZBUF & 0x1ff;
		ZPSM = ( ZBUF >> 24 ) & 0xf;
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) & 1;

		ZBufferStartOffset32 = ZBP << 11;
		ZBufferStartOffset32 <<= 1;

		// add on the missing bits for the zpsm
		ZPSM |= 0x30;

		ZBUFPSM = ZPSM >> 1;


	// pixel test //

	// pixel test
	TEST = inputdata [ uIndex + ( 5 << 1 ) + 0 ];


	// destination alpha test
	DATE = ( ( TEST >> 14 ) & 1 ) << 31;
	DATM = ( ( TEST >> 15 ) & 1 ) << 31;
	
	// depth test
	ZTE = ( TEST >> 16 ) & 1;
	ZTST = ( TEST >> 17 ) & 0x3;

	// alpha test
	ATE = TEST & 1;
	ATST = ( TEST >> 1 ) & 0x7;
	AREF = ( TEST >> 4 ) & 0xff;
	AFAIL = ( TEST >> 12 ) & 0x3;

	// initialize to RGB only on non-RGBA32 format
	AFAIL_FBMASK = -1;
	AFAIL_ZBMASK = -1;

	ATST_LESS = -1;
	ATST_EQUAL = -1;
	ATST_GREATER = -1;
	if ( ATE != 0 )
	{
		// alpha test enabled //

		switch ( ATST )
		{
			// never pass
			case 0:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// always pass
			case 1:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// less
			case 2:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = 0;
				break;

			// less or equal
			case 3:
				ATST_LESS = -1;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// equal
			case 4:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = 0;
				break;

			// greater or equal
			case 5:
				ATST_LESS = 0;
				ATST_EQUAL = -1;
				ATST_GREATER = -1;
				break;

			// greater
			case 6:
				ATST_LESS = 0;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;

			// not equal
			case 7:
				ATST_LESS = -1;
				ATST_EQUAL = 0;
				ATST_GREATER = -1;
				break;
		}

		switch ( AFAIL )
		{
			// keep/hold
			case 0:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = 0;
				break;

			// only update FB
			case 1:
				AFAIL_FBMASK = -1;
				AFAIL_ZBMASK = 0;
				break;

			// only update ZB
			case 2:
				AFAIL_FBMASK = 0;
				AFAIL_ZBMASK = -1;
				break;

			// only update rgb
			case 3:
				// only if format is RGBA32
				if ( FPSM == 0 )
				{
					AFAIL_FBMASK = 0x00ffffff;
					AFAIL_ZBMASK = 0;
				}
				break;
		}
	}

	// depth test
	ZTST_LESS = -1;
	ZTST_GREATER = -1;
	ZTST_EQUAL = -1;
	if ( ZTE != 0 )
	{
		// depth test enabled //

		switch( ZTST )
		{
			// never
			case 0:
				ZTST_LESS = 0;
				ZTST_GREATER = 0;
				ZTST_EQUAL = 0;
				break;

			// always
			case 1:
				ZTST_LESS = -1;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater or equal
			case 2:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = -1;
				break;

			// greater
			case 3:
				ZTST_LESS = 0;
				ZTST_GREATER = -1;
				ZTST_EQUAL = 0;
				break;
		}
	}


	// alpha blending //

	// blending per pixel
	PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;


	ALPHA = inputdata [ uIndex + ( 4 << 1 ) + 0 ];

	// no alpha blending if disabled
	ALPHA &= -ABE;

	ALPHA_A = ( ALPHA >> 0 ) & 0x3;
	ALPHA_B = ( ALPHA >> 2 ) & 0x3;
	ALPHA_C = ( ALPHA >> 4 ) & 0x3;
	ALPHA_D = ( ALPHA >> 6 ) & 0x3;
	ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;




	// texture buffer //

	
	// get the texture variabls
	TEX0_0 = int( inputdata [ uIndex + ( 7 << 1 ) + 0 ] );
	TEX0_1 = int( inputdata [ uIndex + ( 7 << 1 ) + 1 ] );

	TBP0 = ( TEX0_0 >> 0 ) & 0x3fff;

	TextureBufferStartOffset32 = ( TBP0 << 6 );
	TextureBufferStartOffset32 <<= 1;

	TBW = ( TEX0_0 >> 14 ) & 0x3f;

	TextureBufferWidth_Pixels = TBW << 6;

	TPSM = ( TEX0_0 >> 20 ) & 0x3f;

	TEXPSM = TPSM >> 1;

	TW = ( TEX0_0 >> 26 ) & 0xf;
	TH = ( ( TEX0_0 >> 30 ) & 0x3 ) | ( ( TEX0_1 & 0x3 ) << 2 );

	TexWidth = 1 << TW;
	TexHeight = 1 << TH;
	TexWidth_Mask = TexWidth - 1;
	TexHeight_Mask = TexHeight - 1;

	TCC = ( TEX0_1 >> 2 ) & 0x1;
	TFX = ( TEX0_1 >> 3 ) & 0x3;


	// color lookup table pixel format variables //

		//CBP = ( TEX0_1 >> 5 ) & 0x3fff;

		//CLUTStartOffset32 = ( CBP << 6 );
		//CLUTStartOffset32 <<= 1;

	CPSM = ( TEX0_1 >> 19 ) & 0xf;
	CSM = ( TEX0_1 >> 23 ) & 0x1;
	CSA = ( TEX0_1 >> 24 ) & 0x1f;
	CLD = ( TEX0_1 >> 29 ) & 0x7;

	
	// CLUT setup //
	
	if ( CSM == 0 )
	{
		// CSM1 //
		
		if ( ( CPSM & 0x2 ) != 0 )
		{
			// 4-bit pixels - 16 colors
			// 16-bit pixels in CLUT //
			CSA &= 0x1f;
		}
		else
		{
			// 32-bit pixels in CLUT //
			CSA &= 0xf;
		}
		
	}
	else
	{
		// CSM2 //
		
		// when these pixels load into temporary clut, they should be at index 0
		CSA = 0;
	}
	
	CSA <<= 4;
	//ptr_clut16 = & ( InternalCLUT [ CLUTOffset ] );

	// TEXA //

	TEXA_0 = int( inputdata [ uIndex + ( 6 << 1 ) + 0 ] );
	TEXA_1 = int( inputdata [ uIndex + ( 6 << 1 ) + 1 ] );

	AEM = ( TEXA_0 >> 15 ) & 1;
	TEXA_0 <<= 24;
	TEXA_1 <<= 24;




	// texture clamp //

	CLAMP_0 = int( inputdata [ uIndex + ( 14 << 1 ) + 0 ] );
	CLAMP_1 = int( inputdata [ uIndex + ( 14 << 1 ) + 1 ] );

	WMS = ( CLAMP_0 >> 0 ) & 0x3;
	WMT = ( CLAMP_0 >> 2 ) & 0x3;

	MINU = ( CLAMP_0 >> 4 ) & 0x3ff;
	MAXU = ( CLAMP_0 >> 14 ) & 0x3ff;

	MINV = ( ( CLAMP_0 >> 24 ) & 0xff ) | ( ( CLAMP_1 & 0x3 ) << 8 );
	MAXV = ( CLAMP_1 >> 2 ) & 0x3ff;

	switch ( WMT )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexY_And = TexHeight_Mask;
			
			TexY_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexY_Min = 0;
			TexY_Max = TexHeight_Mask;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexY_Min = MINV;
			TexY_Max = MAXV;
			
			TexY_And = TexHeight_Mask;
			TexY_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexY_And = MINV & TexHeight_Mask;
			TexY_Or = MAXV & TexHeight_Mask;
			
			// can only have coords in range -2047 to +2047
			TexY_Min = -2047;
			TexY_Max = 2047;
			break;
	}

	
	switch ( WMS )
	{
		case 0:
			// repeat //
			//TexCoordY &= TexHeight_Mask;
			TexX_And = TexWidth_Mask;
			
			TexX_Or = 0;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
			
		case 1:
			// clamp //
			//TexCoordY = ( TexCoordY < 0 ) ? 0 : TexCoordY;
			//TexCoordY = ( TexCoordY > TexHeight ) ? TexHeight : TexCoordY;
			TexX_Min = 0;
			TexX_Max = TexWidth_Mask;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 2:
			// region clamp //
			//TexCoordY = ( TexCoordY < Clamp_MinV ) ? Clamp_MinV : TexCoordY;
			//TexCoordY = ( TexCoordY > Clamp_MaxV ) ? Clamp_MaxV : TexCoordY;
			TexX_Min = MINU;
			TexX_Max = MAXU;
			
			TexX_And = TexWidth_Mask;
			TexX_Or = 0;
			break;
			
		case 3:
			// region repeat //
			// this one is just like on the ps1
			//TexCoordY = ( TexCoordY & Clamp_MinV ) | Clamp_MaxV;
			TexX_And = MINU & TexWidth_Mask;
			TexX_Or = MAXU & TexWidth_Mask;
			
			// can only have coords in range -2047 to +2047
			TexX_Min = -2047;
			TexX_Max = 2047;
			break;
	}


	// texture processing values //

	// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
	// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
	// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
	// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
	// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
	switch ( TPSM )
	{
		// PSMCT32
		// PSMCT24
		// PSMZ32
		// PSMZ24
		case 0x0:
		case 0x1:
		case 0x30:
		case 0x31:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = -1; iShift3 = 0;
			break;

		// PSMCT16
		// PSMCT16S
		// PSMZ16
		// PSMZ16S
		case 0x2:
		case 0xa:
		case 0x32:
		case 0x3a:
			iAnd1 = 0; iShift1 = 0; iShift2 = 1; iAnd3 = 0xffff; iShift3 = 0;
			break;

		// PSMT8
		case 0x13:
			iAnd1 = 1; iShift1 = 3; iShift2 = 2; iAnd3 = 0xff; iShift3 = 0;
			break;

		// PSMT4
		case 0x14:
			iAnd1 = 3; iShift1 = 2; iShift2 = 3; iAnd3 = 0xf; iShift3 = 0;
			break;

		// PSMT8H
		case 0x1b:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xff; iShift3 = 24;
			break;

		// PSMT4HL
		case 0x24:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 24;
			break;

		// PSMT4HH
		case 0x2c:
			iAnd1 = 0; iShift1 = 0; iShift2 = 0; iAnd3 = 0xf; iShift3 = 28;
			break;
	}




	// texture fogging //

	FOGCOL = inputdata [ uIndex + ( 15 << 1 ) + 1 ];
	FCB = int( FOGCOL >> 0 ) & 0xff;
	FCG = int( FOGCOL >> 8 ) & 0xff;
	FCR = int( FOGCOL >> 16 ) & 0xff;

	// prepare f0, rf0
	// needs to be done before calculating dx
	//f0 = ( f0 >> 24 ) & 0xff;
	//rf0 = 0xff - f0;


	// triangle coords //

	
	Coord.x = uIndex + ( 20 << 1 );
	Coord.y = uIndex + ( 24 << 1 );
	Coord.z = uIndex + ( 28 << 1 );

	// if mono triangle, then copy coord2 to all the colors
	if ( ( PRIM & 0x8 ) == 0 )
	{
		inputdata [ Coord.x + 2 ] = inputdata [ Coord.z + 2 ];
		inputdata [ Coord.y + 2 ] = inputdata [ Coord.z + 2 ];
	}



	///////////////////////////////////
	// put top coordinates in x0,y0
	if ( inputdata [ Coord.y ] < inputdata [ Coord.x ] )
	{
		//Swap ( Coord0, Coord1 );
		Coord.xyz = Coord.yxz;
	}
	
	if ( inputdata [ Coord.z ] < inputdata [ Coord.x ] )
	{
		//Swap ( Coord2, Coord0 );
		Coord.xyz = Coord.zyx;
	}
	
	///////////////////////////////////////
	// put middle coordinates in x1,y1
	if ( inputdata [ Coord.z ] < inputdata [ Coord.y ] )
	{
		//Swap ( Coord2, Coord1 );
		Coord.xyz = Coord.xzy;
	}
	
	// get x,y

	vx.x = int( inputdata [ Coord.x ] );
	vx.y = int( inputdata [ Coord.y ] );
	vx.z = int( inputdata [ Coord.z ] );

	vy = ( vx >> 16 ) & 0xffff;
	vx &= 0xffff;
	
	// get z
	vz.x = inputdata [ Coord.x + 1 ];
	vz.y = inputdata [ Coord.y + 1 ];
	vz.z = inputdata [ Coord.z + 1 ];

	//***todo*** unsure of F is in upper or lower value ??
	vf.x = int( inputdata [ Coord.x + 6 ] );
	vf.y = int( inputdata [ Coord.y + 6 ] );
	vf.z = int( inputdata [ Coord.z + 6 ] );

	// shift fog value down
	vf = ( vf >> 24 ) & 0xff;

	// get r,g,b,a
	va.x = int ( inputdata [ Coord.x + 2 ] );
	va.y = int ( inputdata [ Coord.y + 2 ] );
	va.z = int ( inputdata [ Coord.z + 2 ] );

	vb = ( va >> 0 ) & 0xff;
	vg = ( va >> 8 ) & 0xff;
	vr = ( va >> 16 ) & 0xff;
	va = ( va >> 24 ) & 0xff;




	//////////////////////////////////////////
	// get coordinates on screen
	// *note* this is different from PS1, where you would add the offsets..
	
	vx -= DrawArea_OffsetX;
	vy -= DrawArea_OffsetY;


	// get the left/right most x
	LeftMostX = ( ( vx.x < vx.y ) ? vx.x : vx.y );
	LeftMostX = ( ( vx.z < LeftMostX ) ? vx.z : LeftMostX );
	RightMostX = ( ( vx.x > vx.y ) ? vx.x : vx.y );
	RightMostX = ( ( vx.z > RightMostX ) ? vx.z : RightMostX );
	
	LeftMostX >>= 4;
	RightMostX >>= 4;
	TopMostY = vy.x >> 4;
	BottomMostY = vy.z >> 4;


	// draw test //


	// check if sprite is within draw area
	if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) bDraw = 0;







	if ( FST != 0 )
	{

		// get u,v
		// coord0
		vu.x = int( inputdata [ Coord.x + 4 ] );
		vu.y = int( inputdata [ Coord.y + 4 ] );
		vu.z = int( inputdata [ Coord.z + 4 ] );

		vv = ( vu >> 16 ) & 0x3fff;
		vu &= 0x3fff;
		
	}
	else
	{
		// *** TODO *** //

		// put s,t coords into 10.4 fixed point
		// note: tex width/height should probably be minus one
		//u0 = (s32) ( st [ Coord0 ].fS * ( (float) ( TexWidth ) ) * 16.0f );
		//u1 = (s32) ( st [ Coord1 ].fS * ( (float) ( TexWidth ) ) * 16.0f );
		//v0 = (s32) ( st [ Coord0 ].fT * ( (float) ( TexHeight ) ) * 16.0f );
		//v1 = (s32) ( st [ Coord1 ].fT * ( (float) ( TexHeight ) ) * 16.0f );
		vu.x = int( inputdata [ Coord.x + 4 ] );
		vu.y = int( inputdata [ Coord.y + 4 ] );
		vu.z = int( inputdata [ Coord.z + 4 ] );

		vv.x = int( inputdata [ Coord.x + 5 ] );
		vv.y = int( inputdata [ Coord.y + 5 ] );
		vv.z = int( inputdata [ Coord.z + 5 ] );

		vs = intBitsToFloat ( vu );
		vt = intBitsToFloat ( vv );

		// multiply by tex width/height
		vs *= float( TexWidth );
		vt *= float( TexHeight );

		vu.x = int( inputdata [ Coord.x + 3 ] );
		vu.y = int( inputdata [ Coord.y + 3 ] );
		vu.z = int( inputdata [ Coord.z + 3 ] );

		vq = intBitsToFloat ( vu );

	}

	// put the coords vertical

	vrgba0 = ivec4 ( vr.x, vg.x, vb.x, va.x );
	vrgba1 = ivec4 ( vr.y, vg.y, vb.y, va.y );
	vrgba2 = ivec4 ( vr.z, vg.z, vb.z, va.z );

	vstq0 = vec3 ( vs.x, vt.x, vq.x );
	vstq1 = vec3 ( vs.y, vt.y, vq.y );
	vstq2 = vec3 ( vs.z, vt.z, vq.z );

	vuvf0 = ivec3 ( vu.x, vv.x, vf.x << 4 );
	vuvf1 = ivec3 ( vu.y, vv.y, vf.y << 4 );
	vuvf2 = ivec3 ( vu.z, vv.z, vf.z << 4 );


	//t0 = vy[1] - vy[2];
	//t1 = vy[0] - vy[2];
	//denominator = ( ( vx[0] - vx[2] ) * t0 ) - ( ( vx[1] - vx[2] ) * t1 );
	t0 = vy.y - vy.z;
	t1 = vy.x - vy.z;
	denominator = ( ( vx.x - vx.z ) * t0 ) - ( ( vx.y - vx.z ) * t1 );
	
	// check if x1 is on left or right //
	
	// calculate across
	if ( denominator != 0 )
	{
		
		// result here should be in x.24 fixed point for now

		// colors //

		//drdx = ( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ) << 12 ) / denominator;
		//dgdx = ( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ) << 12 ) / denominator;
		//dbdx = ( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ) << 12 ) / denominator;
		//dadx = ( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ) << 12 ) / denominator;
		//drdx = intdivf2( ( ( ( vr[0] - vr[2] ) * t0 ) - ( ( vr[1] - vr[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dgdx = intdivf2( ( ( ( vg[0] - vg[2] ) * t0 ) - ( ( vg[1] - vg[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dbdx = intdivf2( ( ( ( vb[0] - vb[2] ) * t0 ) - ( ( vb[1] - vb[2] ) * t1 ) ), denominator, 4, 8, 16 );
		//dadx = intdivf2( ( ( ( va[0] - va[2] ) * t0 ) - ( ( va[1] - va[2] ) * t1 ) ), denominator, 4, 8, 16 );

		drgbadx = intdivfv4( ( ( ( vrgba0 - vrgba2 ) * t0 ) - ( ( vrgba1 - vrgba2 ) * t1 ) ), denominator, 4, 8, 16 );



		// u/v texture coords //

		//dudx = ( ( ( ( vu[0] - vu[2] ) * t0 ) - ( ( vu[1] - vu[2] ) * t1 ) ) << 8 ) / denominator;
		//dvdx = ( ( ( ( vv[0] - vv[2] ) * t0 ) - ( ( vv[1] - vv[2] ) * t1 ) ) << 8 ) / denominator;
		//dudx = intdivf2( ( ( ( vu[0] - vu[2] ) * t0 ) - ( ( vu[1] - vu[2] ) * t1 ) ), denominator, 8, 8, 16 );
		//dvdx = intdivf2( ( ( ( vv[0] - vv[2] ) * t0 ) - ( ( vv[1] - vv[2] ) * t1 ) ), denominator, 8, 8, 16 );

		// fog //

		//dfdx = ( ( ( ( vf[0] - vf[2] ) * t0 ) - ( ( vf[1] - vf[2] ) * t1 ) ) << 12 ) / denominator;
		//dfdx = intdivf2( ( ( ( vf[0] - vf[2] ) * t0 ) - ( ( vf[1] - vf[2] ) * t1 ) ), denominator, 4, 8, 16 );

		duvfdx = intdivfv3( ( ( ( vuvf0 - vuvf2 ) * t0 ) - ( ( vuvf1 - vuvf2 ) * t1 ) ), denominator, 8, 8, 16 );


		// s/t/q texture coords //

		//dsdx = ( ( ( vs[0] - vs[2] ) * ( float( t0 )/16.0 ) ) - ( ( vs[1] - vs[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
		//dtdx = ( ( ( vt[0] - vt[2] ) * ( float( t0 )/16.0 ) ) - ( ( vt[1] - vt[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
		//dqdx = ( ( ( vq[0] - vq[2] ) * ( float( t0 )/16.0 ) ) - ( ( vq[1] - vq[2] ) * ( float( t1 )/16.0 ) ) ) / ( float( denominator )/256.0 );
		//dsdx = ( ( ( ( vs[0] - vs[2] ) * ( float( t0 ) ) ) - ( ( vs[1] - vs[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;
		//dtdx = ( ( ( ( vt[0] - vt[2] ) * ( float( t0 ) ) ) - ( ( vt[1] - vt[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;
		//dqdx = ( ( ( ( vq[0] - vq[2] ) * ( float( t0 ) ) ) - ( ( vq[1] - vq[2] ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;

		dstqdx = ( ( ( ( vstq0 - vstq2 ) * ( float( t0 ) ) ) - ( ( vstq1 - vstq2 ) * ( float( t1 ) ) ) ) / ( float( denominator ) ) ) * 16.0f;


		// z-value //

		// ***todo*** need to use a double here
		//dzdx = ( ( ( ( (s64) ( z0 - z2 ) ) * t0 ) - ( ( (s64) ( z1 - z2 ) ) * t1 ) ) << 27 ) / denominator;
		//dzdx = ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 )/16.0 ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 )/16.0 ) ) ) / ( double( denominator )/256.0 );
		dzdx = ( ( ( ( double(vz[0]) - double(vz[2]) ) * ( double( t0 ) ) ) - ( ( double(vz[1]) - double(vz[2]) ) * ( double( t1 ) ) ) ) / ( double( denominator ) ) ) * 16.0;


		drdx = drgbadx.r;
		dgdx = drgbadx.g;
		dbdx = drgbadx.b;
		dadx = drgbadx.a;
		dudx = duvfdx.x;
		dvdx = duvfdx.y;
		dfdx = duvfdx.z;
		dsdx = dstqdx.x;
		dtdx = dstqdx.y;
		dqdx = dstqdx.z;
	}
	
	
	/////////////////////////////////////////////////
	// draw top part of triangle
	
	
	

	if ( ( vy.y - vy.x ) != 0 )
	{
		// triangle is pointed on top //

		// need to set the x0 index unconditionally
		//vdx [ X0Index ] = ( vx[0] << 12 );
		vdx.xy = vx.xx << 12;
		
		
		vdr = vr.x << 16;
		vdg = vg.x << 16;
		vdb = vb.x << 16;
		vda = va.x << 16;

		vdu = vu.x << 12;
		vdv = vv.x << 12;
		vdf = vf.x << 16;

		vds = vs.x;
		vdt = vt.x;
		vdq = vq.x;
		

		//vdrgba = vrgba0 << 16;
		//vduvf = vuvf0 << 12;
		//vdstq = vstq0;

		vdz = double( vz[0] );


		if ( denominator < 0 )
		{
			//vdxdy [ 0 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
			//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
			vdxdy.xy = intdivfv2( vx.yz - vx.xx, vy.yz - vy.xx, 4, 4, 16 );

			
			vdrdy = intdivf2(( vr.y - vr.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.y - vg.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.y - vb.x ), ( vy.y - vy.x ), 0, 4, 16 );
			vdady = intdivf2(( va.y - va.x ), ( vy.y - vy.x ), 0, 4, 16 );

			vdudy = intdivf2(( vu.y - vu.x ), ( vy.y - vy.x ), 4, 4, 16 );
			vdvdy = intdivf2(( vv.y - vv.x ), ( vy.y - vy.x ), 4, 4, 16 );
			vdfdy = intdivf2(( vf.y - vf.x ), ( vy.y - vy.x ), 0, 4, 16 );

			vdsdy = ( ( vs.y - vs.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
			vdtdy = ( ( vt.y - vt.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
			vdqdy = ( ( vq.y - vq.x ) / ( float( vy.y - vy.x ) ) ) * 16.0f;
			

			//vdrgbady = intdivfv4( vrgba1 - vrgba0, vy.y - vy.x, 0, 4, 16 );
			//vduvfdy = intdivfv3( vuvf1 - vuvf0, vy.y - vy.x, 4, 4, 16 );
			//vdstqdy = ( ( vstq1 - vstq0 ) / ( float( vy.y - vy.x ) ) ) * 16.0f;

			vdzdy = ( ( double(vz[1]) - double(vz[0]) ) / ( double( vy[1] - vy[0] ) ) ) * 16.0;
		}
		else
		{
			//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
			//vdxdy [ 1 ] = intdivf2(( vx[1] - vx[0] ), ( vy[1] - vy[0] ), 4, 4, 16 );
			vdxdy.xy = intdivfv2( vx.zy - vx.xx, vy.zy - vy.xx, 4, 4, 16 );

			
			vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
			vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

			vdudy = intdivf2(( vu.z - vu.x ), ( vy.z - vy.x ), 4, 4, 16 );
			vdvdy = intdivf2(( vv.z - vv.x ), ( vy.z - vy.x ), 4, 4, 16 );
			vdfdy = intdivf2(( vf.z - vf.x ), ( vy.z - vy.x ), 0, 4, 16 );

			vdsdy = ( ( vs.z - vs.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
			vdtdy = ( ( vt.z - vt.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
			vdqdy = ( ( vq.z - vq.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
			

			//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );
			//vduvfdy = intdivfv3( vuvf2 - vuvf0, vy.z - vy.x, 4, 4, 16 );
			//vdstqdy = ( ( vstq2 - vstq0 ) / ( float( vy.z - vy.x ) ) ) * 16.0f;

			vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
		}
		

	}
	else
	{
		// Triangle is flat on top //


		if ( denominator < 0 )
		{
			// x1 is on left //
			vdx.xy = vx.yx << 12;
			
			
			vdr = vr.y << 16;
			vdg = vg.y << 16;
			vdb = vb.y << 16;
			vda = va.y << 16;

			vdu = vu.y << 12;
			vdv = vv.y << 12;
			vdf = vf.y << 16;

			vds = vs.y;
			vdt = vt.y;
			vdq = vq.y;
			

			//vdrgba = vrgba1 << 16;
			//vduvf = vuvf1 << 12;
			//vdstq = vstq1;

			vdz = double( vz[1] );

			if ( ( vy.z - vy.y ) != 0 )
			{
				//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
				//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
				vdxdy.xy = intdivfv2( vx.zz - vx.yx, vy.zz - vy.yx, 4, 4, 16 );
				
				
				vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
				vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

				vdudy = intdivf2(( vu.z - vu.y ), ( vy.z - vy.y ), 4, 4, 16 );
				vdvdy = intdivf2(( vv.z - vv.y ), ( vy.z - vy.y ), 4, 4, 16 );
				vdfdy = intdivf2(( vf.z - vf.y ), ( vy.z - vy.y ), 0, 4, 16 );

				vdsdy = ( ( vs.z - vs.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
				vdtdy = ( ( vt.z - vt.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
				vdqdy = ( ( vq.z - vq.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
				

				//vdrgbady = intdivfv4( vrgba2 - vrgba1, vy.z - vy.y, 0, 4, 16 );
				//vduvfdy = intdivfv3( vuvf2 - vuvf1, vy.z - vy.y, 4, 4, 16 );
				//vdstqdy = ( ( vstq2 - vstq1 ) / ( float( vy.z - vy.y ) ) ) * 16.0f;

				vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;
			}
		}
		else
		{
			// x1 is on right //
			vdx.xy = vx.xy << 12;
			
			
			vdr = vr.x << 16;
			vdg = vg.x << 16;
			vdb = vb.x << 16;
			vda = va.x << 16;

			vdu = vu.x << 12;
			vdv = vv.x << 12;
			vdf = vf.x << 16;

			vds = vs.x;
			vdt = vt.x;
			vdq = vq.x;
			

			//vdrgba = vrgba0 << 16;
			//vduvf = vuvf0 << 12;
			//vdstq = vstq0;

			vdz = double( vz[0] );

			if ( ( vy.z - vy.y ) != 0 )
			{
				//vdxdy [ 0 ] = intdivf2(( vx[2] - vx[0] ), ( vy[2] - vy[0] ), 4, 4, 16 );
				//vdxdy [ 1 ] = intdivf2(( vx[2] - vx[1] ), ( vy[2] - vy[1] ), 4, 4, 16 );
				vdxdy.xy = intdivfv2( vx.zz - vx.xy, vy.zz - vy.xy, 4, 4, 16 );
				
				
				vdrdy = intdivf2(( vr.z - vr.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdgdy = intdivf2(( vg.z - vg.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdbdy = intdivf2(( vb.z - vb.x ), ( vy.z - vy.x ), 0, 4, 16 );
				vdady = intdivf2(( va.z - va.x ), ( vy.z - vy.x ), 0, 4, 16 );

				vdudy = intdivf2(( vu.z - vu.x ), ( vy.z - vy.x ), 4, 4, 16 );
				vdvdy = intdivf2(( vv.z - vv.x ), ( vy.z - vy.x ), 4, 4, 16 );
				vdfdy = intdivf2(( vf.z - vf.x ), ( vy.z - vy.x ), 0, 4, 16 );

				vdsdy = ( ( vs.z - vs.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
				vdtdy = ( ( vt.z - vt.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
				vdqdy = ( ( vq.z - vq.x ) / ( float( vy.z - vy.x ) ) ) * 16.0f;
				

				//vdrgbady = intdivfv4( vrgba2 - vrgba0, vy.z - vy.x, 0, 4, 16 );
				//vduvfdy = intdivfv3( vuvf2 - vuvf0, vy.z - vy.x, 4, 4, 16 );
				//vdstqdy = ( ( vstq2 - vstq0 ) / ( float( vy.z - vy.x ) ) ) * 16.0f;

				vdzdy = ( ( double(vz[2]) - double(vz[0]) ) / ( double( vy[2] - vy[0] ) ) ) * 16.0;
			}
		}
		
	}
	


	// left point is included if points are equal
	StartY = ( vy.x + 0xf ) >> 4;
	EndY = ( vy.y - 1 ) >> 4;



	Temp = ( StartY << 4 ) - vy.x;

	if ( StartY < DrawArea_TopLeftY )
	{
		if ( EndY < DrawArea_TopLeftY )
		{
			Temp += ( EndY - StartY + 1 ) << 4;
			StartY = EndY + 1;
		}
		else
		{
			Temp += ( DrawArea_TopLeftY - StartY ) << 4;
			StartY = DrawArea_TopLeftY;
		}
	}
	
	
	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += ( vdxdy >> 4 ) * Temp;
	
	
	vdr += ( vdrdy >> 4 ) * Temp;
	vdg += ( vdgdy >> 4 ) * Temp;
	vdb += ( vdbdy >> 4 ) * Temp;
	vda += ( vdady >> 4 ) * Temp;

	vdu += ( vdudy >> 4 ) * Temp;
	vdv += ( vdvdy >> 4 ) * Temp;

	vdf += ( vdfdy >> 4 ) * Temp;

	vds += ( vdsdy ) * ( float( Temp ) * (1.0f/16.0f) );
	vdt += ( vdtdy ) * ( float( Temp ) * (1.0f/16.0f) );
	vdq += ( vdqdy ) * ( float( Temp ) * (1.0f/16.0f) );
	

	//vdrgba += ( vdrgbady >> 4 ) * Temp;
	//vduvf += ( vduvfdy >> 4 ) * Temp;
	//vdstq += ( vdstqdy ) * ( float( Temp )/16.0f );

	// *** todo *** should be a double
	vdz += ( vdzdy ) * ( double( Temp ) * (1.0/16.0) );

	
	if ( EndY > DrawArea_BottomRightY )
	{
		EndY = DrawArea_BottomRightY;
	}
	

#endif	// end #ifdef CALC_TRIANGLE_TEXTURE_VARS



#ifdef LOAD_TRIANGLE_TEXTURE_VARS
	bDraw = data [ uIdx + 0 ];
#endif

	if ( bDraw == 1 )
	{

#ifdef LOAD_TRIANGLE_TEXTURE_VARS

		// load common settings //

		
		DrawArea_TopLeftX = int( inputdata [ uIndex + ( 1 << 1 ) + 0 ] );
		DrawArea_BottomRightX = ( DrawArea_TopLeftX >> 16 ) & 0x7ff;
		DrawArea_TopLeftX &= 0x7ff;

		//DrawArea_TopLeftY = int( inputdata [ uIndex + ( 1 << 1 ) + 1 ] );
		//DrawArea_BottomRightY = ( DrawArea_TopLeftY >> 16 ) & 0x7ff;
		//DrawArea_TopLeftY &= 0x7ff;

		FBMSK = inputdata [ uIndex + ( 2 << 1 ) + 1 ];
		ZMSK = int( inputdata [ uIndex + ( 3 << 1 ) + 1 ] ) << 31;
		PABE = inputdata [ uIndex + ( 16 << 1 ) + 0 ] << 31;
		FBA = inputdata [ uIndex + ( 16 << 1 ) + 1 ] << 31;
		ALPHA_FIX = ( inputdata [ uIndex + ( 4 << 1 ) + 1 ] & 0xff ) << 24;
		COLCLAMP = int( inputdata [ uIndex + ( 17 << 1 ) + 0 ] );
		COLCLAMP = ( -( COLCLAMP & 1 ) ) | 0xff;

		uvAlphaSelect [ 2 ] = ivec4( ALPHA_FIX );
		uvAlphaSelect [ 3 ] = vZero;

		//COLCLAMP = data [ uIdx + 1 ];
		//PABE = data [ uIdx + 2 ];
		//FBA = data [ uIdx + 3 ];

		FPSM = data [ uIdx + 1 ];
		ZPSM = data [ uIdx + 2 ];
		DRAWPSM = data [ uIdx + 3 ];
		ZBUFPSM = data [ uIdx + 4 ];
		FrameBufferStartOffset32 = data [ uIdx + 5 ];
		FrameBufferWidth_Pixels = data [ uIdx + 6 ];
		ZBufferStartOffset32 = data [ uIdx + 7 ];
		
		//FBMSK = data [ uIdx + 8 ];
		//ZMSK = data [ uIdx + 9 ];
		
		AFAIL_FBMASK = data [ uIdx + 8 ];
		AFAIL_ZBMASK = data [ uIdx + 9 ];

		//ALPHA_FIX = data [ uIdx + 10 ];

		ALPHA_A = data [ uIdx + 10 ];
		ALPHA_B = data [ uIdx + 11 ];
		ALPHA_C = data [ uIdx + 12 ];
		ALPHA_D = data [ uIdx + 13 ];
		AREF = data [ uIdx + 14 ];

		//ATST_LESS = data [ uIdx + 15 ];
		//ATST_GREATER = data [ uIdx + 16 ];
		//ATST_EQUAL = data [ uIdx + 17 ];
		iATMask = data [ uIdx + 15 ];
		iATOffset = data [ uIdx + 16 ];

		ZTST_LESS = data [ uIdx + 18 ];
		ZTST_GREATER = data [ uIdx + 19 ];
		ZTST_EQUAL = data [ uIdx + 20 ];
		FGE = data [ uIdx + 21 ];
		DATE = data [ uIdx + 22 ];
		DATM = data [ uIdx + 23 ];
		ABE = data [ uIdx + 24 ];

		ZTE = data [ uIdx + 95 ];
		ATE = data [ uIdx + 123 ];

		// load common texture settings //
		
		TexX_Min = data [ uIdx + 25 ];
		TexX_Max = data [ uIdx + 26 ];
		TexX_And = data [ uIdx + 27 ];
		TexX_Or = data [ uIdx + 28 ];
		TexY_Min = data [ uIdx + 29 ];
		TexY_Max = data [ uIdx + 30 ];
		TexY_And = data [ uIdx + 31 ];
		TexY_Or = data [ uIdx + 32 ];
		TPSM = data [ uIdx + 33 ];
		TEXPSM = data [ uIdx + 34 ];
		TFX = data [ uIdx + 35 ];
		TCC = data [ uIdx + 36 ];
		CPSM = data [ uIdx + 37 ];
		CSA = data [ uIdx + 38 ];
		AEM = data [ uIdx + 39 ];
		TEXA_0 = data [ uIdx + 40 ];
		TEXA_1 = data [ uIdx + 41 ];
		TextureBufferStartOffset32 = data [ uIdx + 42 ];
		TextureBufferWidth_Pixels = data [ uIdx + 43 ];
		FCR = data [ uIdx + 44 ];
		FCG = data [ uIdx + 45 ];
		FCB = data [ uIdx + 46 ];
		iShift1 = data [ uIdx + 47 ];
		iShift2 = data [ uIdx + 48 ];
		iShift3 = data [ uIdx + 49 ];
		iAnd1 = data [ uIdx + 50 ];
		iAnd3 = data [ uIdx + 51 ];
		
		FST = data [ uIdx + 127 ];
		
		// triangle vars //

		
		drdx = data [ uIdx + 52 ];
		dgdx = data [ uIdx + 53 ];
		dbdx = data [ uIdx + 54 ];
		dadx = data [ uIdx + 55 ];
		drgbadx = data4 [ ( uIdx + 52 ) >> 2 ];

		dudx = data [ uIdx + 56 ];
		dvdx = data [ uIdx + 57 ];
		dfdx = data [ uIdx + 58 ];
		duvfdx = data4 [ ( uIdx + 56 ) >> 2 ];

		dzdx2[0] = uint( data [ uIdx + 59 ] );

		dsdx = intBitsToFloat( data [ uIdx + 60 ] );
		dtdx = intBitsToFloat( data [ uIdx + 61 ] );
		dqdx = intBitsToFloat( data [ uIdx + 62 ] );
		dstqdx = intBitsToFloat( data4 [ ( uIdx + 60 ) >> 2 ] );

		dzdx2[1] = uint( data [ uIdx + 63 ] );

		dzdx = packDouble2x32( dzdx2 );

#endif


#ifdef LOAD_TRIANGLE_TEXTURE_VARS
	ivec2 vyoffset_xor;
	ivec2 vyoffset;
	ivec2 vdzpsm7;
	ivec2 vdzpsm12;
	ivec2 vdzpsm;
	ivec2 vdznand;
	ivec2 vstartoffset;
	ivec4 viStartU;

	DYNAND = LUT_YNAND[ DRAWPSM ];
	ZYNAND = LUT_YNAND[ ZBUFPSM ];
	TYNAND = LUT_YNAND[ TEXPSM ];


	vdzpsm.x = ( DRAWPSM & 1 ) ^ 1;
	vdzpsm.y = ( ZBUFPSM & 1 ) ^ 1;

	vdzpsm7.x = DRAWPSM << 7;
	vdzpsm7.y = ZBUFPSM << 7;

	vdzpsm12.x = DRAWPSM << 12;
	vdzpsm12.y = ZBUFPSM << 12;

	vdznand.x = LUT_YNAND[ DRAWPSM ];
	vdznand.y = LUT_YNAND[ ZBUFPSM ];

	vstartoffset.x = FrameBufferStartOffset32;
	vstartoffset.y = ZBufferStartOffset32;

		for ( uLoop = 0; uLoop < 60; uLoop += 32 )
		{
			uIdx += uLoop;

		// first set //
		
		StartY = data [ uIdx + 64 ];
		EndY = data [ uIdx + 65 ];

		vdx.x = data [ uIdx + 66 ];
		vdx.y = data [ uIdx + 67 ];

		
		//vdr = data [ uIdx + 68 ];
		//vdg = data [ uIdx + 69 ];
		//vdb = data [ uIdx + 70 ];
		//vda = data [ uIdx + 71 ];
		vdrgba = data4 [ ( uIdx + 68 ) >> 2 ];

		//vdu = data [ uIdx + 72 ];
		//vdv = data [ uIdx + 73 ];
		//vdf = data [ uIdx + 74 ];
		vduvf = data4 [ ( uIdx + 72 ) >> 2 ];

		
		vdz2[0] = uint( data [ uIdx + 75 ] );

		//vds = intBitsToFloat( data [ uIdx + 76 ] );
		//vdt = intBitsToFloat( data [ uIdx + 77 ] );
		//vdq = intBitsToFloat( data [ uIdx + 78 ] );
		vdstq = intBitsToFloat( data4 [ ( uIdx + 76 ) >> 2 ] );

		vdz2[1] = uint( data [ uIdx + 79 ] );

		
		vdz = packDouble2x32( vdz2 );

		
		vdxdy.x = data [ uIdx + 80 ];
		vdxdy.y = data [ uIdx + 81 ];

		// split double and store
		vdzdy2[0] = uint( data [ uIdx + 82 ] );
		vdzdy2[1] = uint( data [ uIdx + 83 ] );
		vdzdy = packDouble2x32( vdzdy2 );

		//vdrdy = data [ uIdx + 84 ];
		//vdgdy = data [ uIdx + 85 ];
		//vdbdy = data [ uIdx + 86 ];
		//vdady = data [ uIdx + 87 ];
		vdrgbady = data4 [ ( uIdx + 84 ) >> 2 ];

		//vdudy = data [ uIdx + 88 ];
		//vdvdy = data [ uIdx + 89 ];
		//vdfdy = data [ uIdx + 90 ];
		vduvfdy = data4 [ ( uIdx + 88 ) >> 2 ];

		//vdsdy = intBitsToFloat( data [ uIdx + 92 ] );
		//vdtdy = intBitsToFloat( data [ uIdx + 93 ] );
		//vdqdy = intBitsToFloat( data [ uIdx + 94 ] );
		vdstqdy = intBitsToFloat( data4 [ ( uIdx + 92 ) >> 2 ] );
		
			uIdx -= uLoop;

#endif

	uvTEXA_0 = uvec4( TEXA_0 );
	uvTEXA_1 = uvec4( TEXA_1 );
	uvALPHA_FIX = uvec4( ALPHA_FIX );

	vAREF = uvec4( AREF );

	vxdsdx = dsdx * float( group_vxinc );
	vxdtdx = dtdx * float( group_vxinc );
	vxdqdx = dqdx * float( group_vxinc );
	vxdzdx = dzdx * double( group_vxinc );

	vyvdstqdy = vdstqdy * float( group_yinc );
	vyvdzdy = vdzdy * double( group_yinc );



	//if ( EndY >= StartY )
	{

	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;


	// dxdy is in .16, Temp is in .4, and x is in .16
	vdx += vdxdy * yid;
	
	
	//vdr += vdrdy * yid;
	//vdg += vdgdy * yid;
	//vdb += vdbdy * yid;
	//vda += vdady * yid;

	//vdu += vdudy * yid;
	//vdv += vdvdy * yid;
	//vdf += vdfdy * yid;

	//vds += ( vdsdy ) * ( float( yid ) );
	//vdt += ( vdtdy ) * ( float( yid ) );
	//vdq += ( vdqdy ) * ( float( yid ) );
	
	vdrgba += vdrgbady * yid;
	vduvf += vduvfdy * yid;
	vdstq += ( vdstqdy ) * ( float( yid ) );

	// *** todo *** should be a double
	//vdz += ( vdzdy ) * ( double( Temp )/16.0 );
	vdz += ( vdzdy ) * ( double( yid ) );


	//vIdx.zw = ivec2( DRAWPSM << 12, ZBUFPSM << 12 );
	//vXOffset32.zw = ivec2( ( DRAWPSM & 1 ) ^ 1, ( ZBUFPSM & 1 ) ^ 1 );
	//vOffset.zw = ivec2( FrameBufferStartOffset32, ZBufferStartOffset32 );

	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		vIdx.xy = vdzpsm7.xy | ( Line & 0x3f );
		vyoffset_xor = ivec2( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ] );
		vyoffset = ( Line & vdznand ) * FrameBufferWidth_Pixels;


		// left point is included if points are equal
		StartX = ( vdx.x + 0xffff ) >> 16;
		EndX = ( vdx.y - 1 ) >> 16;


		//if ( StartX <= DrawArea_BottomRightX && EndX >= DrawArea_TopLeftX && EndX >= StartX )
		{


			//iR = vdr;
			//iG = vdg;
			//iB = vdb;
			//iA = vda;
			irgba = vdrgba;

			//iU = vdu;
			//iV = vdv;
			//iF = vdf;
			iuvf = vduvf;

			//fS = vds;
			//fT = vdt;
			//fQ = vdq;
			ifstq = vdstq;

			// *** todo ***
			iZ = vdz;
			
			
			// get distance from point to pixel
			Temp = ( StartX << 16 ) - vdx.x;
			
			//if ( StartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - StartX ) << 16;
			//	StartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( StartX, DrawArea_TopLeftX ) ) << 16;
			StartX = max( StartX, DrawArea_TopLeftX );

			
			//iR += ( drdx >> 8 ) * ( Temp >> 8 );
			//iG += ( dgdx >> 8 ) * ( Temp >> 8 );
			//iB += ( dbdx >> 8 ) * ( Temp >> 8 );
			//iA += ( dadx >> 8 ) * ( Temp >> 8 );
			irgba += ( drgbadx >> 8 ) * ( Temp >> 8 );

			//iU += ( dudx >> 8 ) * ( Temp >> 8 );
			//iV += ( dvdx >> 8 ) * ( Temp >> 8 );
			//iF += ( dfdx >> 8 ) * ( Temp >> 8 );
			iuvf += ( duvfdx >> 8 ) * ( Temp >> 8 );

			//fS += dsdx * ( float( Temp ) * (1.0f/65536.0f) );
			//fT += dtdx * ( float( Temp ) * (1.0f/65536.0f) );
			//fQ += dqdx * ( float( Temp ) * (1.0f/65536.0f) );
			ifstq += ( dstqdx ) * ( float( Temp ) * (1.0f/65536.0f) );

			//iZ += dzdx * ( double( Temp )/65536.0 );
			iZ += dzdx * ( double( Temp ) * (1.0/65536.0) );
			
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	//EndX = Window_XRight + 1;
			//	EndX = DrawArea_BottomRightX;
			//}
			EndX = min( EndX, DrawArea_BottomRightX );


			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( StartX & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
			vxid = vxid + group_vxinc * ( ( vxid.w >> 31 ) & 1 );


			
			//viR = iR + ( vxid * drdx );
			//viG = iG + ( vxid * dgdx );
			//viB = iB + ( vxid * dbdx );
			//viA = iA + ( vxid * dadx );
			viR = irgba.r + ( vxid * drdx );
			viG = irgba.g + ( vxid * dgdx );
			viB = irgba.b + ( vxid * dbdx );
			viA = irgba.a + ( vxid * dadx );

			//viU = iU + ( vxid * dudx );
			//viV = iV + ( vxid * dvdx );
			//viF = iF + ( vxid * dfdx );
			viU = iuvf.x + ( vxid * dudx );
			viV = iuvf.y + ( vxid * dvdx );
			viF = iuvf.z + ( vxid * dfdx );

			//vfS = fS + ( vec4( vxid ) * dsdx );
			//vfT = fT + ( vec4( vxid ) * dtdx );
			//vfQ = fQ + ( vec4( vxid ) * dqdx );
			vfS = ifstq.x + ( vec4( vxid ) * dsdx );
			vfT = ifstq.y + ( vec4( vxid ) * dtdx );
			vfQ = ifstq.z + ( vec4( vxid ) * dqdx );

			viZ = iZ + ( dvec4( vxid ) * dzdx );
			


			w = EndX - StartX + 1;

			w &= -( int( StartX <= DrawArea_BottomRightX ) & int( EndX >= DrawArea_TopLeftX ) & int( EndX >= StartX ) );

			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			for ( vx_across = vxid; vx_across.x < w; vx_across += group_vxinc )
			{
			// get the pixels to be drawn
			//bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
			usubBorrow( uvec4( vx_across ), uvec4( w ), uvEnable );

			// z value is z0
			//vZPixel32 = ivec4( z0 );
			vZPixel32 = ivec4( viZ );
			
			// calculate xoffset
			//vIdx = ( vx_across + StartX );
			vIdx.xy = ( ( vx_across.x + StartX ) & 0xfff ) | vdzpsm12.xy;
			vXOffset32.xy = ivec2( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ] );
			vXOffset32.xy ^= vyoffset_xor.xy;
			vOffset.xy = vXOffset32.xy + vyoffset.xy;
			vOffset.xy <<= vdzpsm.xy;
			vOffset.xy += vstartoffset.xy;

			vZOffset[0] = vOffset.y;

			

			// pull the pixels //

			// x-bit pixels //

			vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];

			// combine
			//vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			//vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );
			vDestPixel32.xy = bitfieldInsert( vDestPixel32_0.xz, vDestPixel32_0.yw, 16, 16 );
			vDestPixel32.zw = bitfieldInsert( vDestPixel32_1.xz, vDestPixel32_1.yw, 16, 16 );

			vDPixelX = vDestPixel32;

			// extract
			vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );
			//vDestPixel32 >>= ( ( vOffset.x & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				//vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
				vDestPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vDestPixel32, 3, 5 ), bitfieldExtract( vDestPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vDestPixel32, 10, 5 ), 19, 5 ), bitfieldExtract( vDestPixel32, 15, 1 ), 31, 1 );
			}



			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );



			// x-bit zpixels //

			vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];

			// combine
			//vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			//vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );
			vZDestPixel32.xy = bitfieldInsert( vZDestPixel32_0.xz, vZDestPixel32_0.yw, 16, 16 );
			vZDestPixel32.zw = bitfieldInsert( vZDestPixel32_1.xz, vZDestPixel32_1.yw, 16, 16 );

			vZPixelX = vZDestPixel32;

			// extract
			vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );
			//vZDestPixel32 >>= ( ( vOffset.y & ZBUFPSM & 1 ) << 4 );



			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );


			// load pixel to draw //


			// set fragment color //

			// ***TODO*** this is a PROBLEM, since iR, iG, iB, iA are signed 32-bit values, so below can easily get wrong colors!
			vrf = viR >> 16;
			vgf = viG >> 16;
			vbf = viB >> 16;
			vaf = viA >> 16;
			
			// clamp fragment color
			// *** NOTE *** need to clamp here since we are using s32 instead of s64 for iR,iG,iB,iA
			//vrf &= 0xff;
			//vgf &= 0xff;
			//vbf &= 0xff;
			//vaf &= 0xff;
			

			// get viU, viV //
			if ( FST == 0 )
			{
				vTexCoordX = ivec4(vfS / vfQ);
				vTexCoordY = ivec4(vfT / vfQ);
			}
			else
			{
				vTexCoordX = viU >> 16;
				vTexCoordY = viV >> 16;

			}



//#ifdef ENABLE_TEXTURE_MAPPING
			// need to start texture coord from left again
			//viU = u0 + ( vxid * dudx );
			
			//TexCoordY = ( viV >> 16 );
			
			vTexCoordY = clamp( vTexCoordY, TexY_Min, TexY_Max );
			vTexCoordY &= TexY_And;
			vTexCoordY |= TexY_Or;

			vIdx = ( vTexCoordY & 0x7f ) | ( TEXPSM << 7 );
			vxTYOffset = ivec4( LUT_YOFFSET[vIdx[0]], LUT_YOFFSET[vIdx[1]], LUT_YOFFSET[vIdx[2]], LUT_YOFFSET[vIdx[3]] );
			//viTYOffset = ( vTexCoordY & LUT_YNAND[ TEXPSM ] ) * TextureBufferWidth_Pixels;
			viTYOffset = ( vTexCoordY & TYNAND ) * TextureBufferWidth_Pixels;

//#endif


//#ifdef ENABLE_TEXTURE_MAPPING


			vTexCoordX = clamp( vTexCoordX, TexX_Min, TexX_Max );
			vTexCoordX &= TexX_And;
			vTexCoordX |= TexX_Or;


			vIdx = ( vTexCoordX & 0x0fff ) | ( TEXPSM << 12 );
			vTXOffset = ivec4( LUT_XOFFSET[ vIdx[0] ], LUT_XOFFSET[ vIdx[1] ], LUT_XOFFSET[ vIdx[2] ], LUT_XOFFSET[ vIdx[3] ] );


			// need to shift to left once if 32-bit pixels //
			vTOffset = vTXOffset ^ vxTYOffset;
			vTOffset += viTYOffset;


			

			// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
			// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
			// get the amount to shift pixel
			vPixelShift = ( vTOffset & iAnd1 ) << iShift1;

			// if looking up 32-bit pixels, then need to multiply by 2 in x-direction
			vTOffset <<= 1;

			// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
			// get the remainder of the offset (for 32-bit lookup after already shifting left 1)
			vTOffset >>= iShift2;

			vTOffset += TextureBufferStartOffset32;

			// check if 32-bit pixel format or not for texture
			if ( ( TEXPSM & 0x7 ) == 0 )
			{
				// 32-bit texture pixel //

				
				// load 32-bit pixel data
				vTOffset >>= 1;
				vPixel32_0.xy = VRAM2 [ vTOffset[0] ];
				vPixel32_0.zw = VRAM2 [ vTOffset[1] ];
				vPixel32_1.xy = VRAM2 [ vTOffset[2] ];
				vPixel32_1.zw = VRAM2 [ vTOffset[3] ];

				// combine
				//vPixel32.xy = ( vPixel32_0.xz & 0xffff ) | ( vPixel32_0.yw << 16 );
				//vPixel32.zw = ( vPixel32_1.xz & 0xffff ) | ( vPixel32_1.yw << 16 );
				vPixel32.xy = bitfieldInsert( vPixel32_0.xz, vPixel32_0.yw, 16, 16 );
				vPixel32.zw = bitfieldInsert( vPixel32_1.xz, vPixel32_1.yw, 16, 16 );



				// check if rgb24 format
				if ( ( TPSM & 1 ) == 1 )
				{
					// handle aem for rgb24 //

					// mask pixel
					vPixel32 &= 0x00ffffff;

					// check if zero
					vPixel32 |= TEXA_0 & ( ( AEM ) | ~( vPixel32-1 ) );

					// pull in texa if aem=0
				}
			}
			else
			{
				// either 16-bit or lookup pixel //


				// pull the pixel
				vTOffset += ( iShift3 >> 3 ) & 1;
				vPixel32 = uvec4( VRAM [ vTOffset[0] ], VRAM [ vTOffset[1] ], VRAM [ vTOffset[2] ], VRAM [ vTOffset[3] ] );

				// check if pixel needs lookup
				if ( ( TPSM & 7 ) < 3 )
				{
					// straight 16-bit pixel //


					// handle aem for rgb16 //

					// get alpha0 if aem=1

					// mask pixel just in case
					vPixel32 &= 0xffff;

					// if a=0, then a=texa0 if either rgb!=0 or aem=0, otherwise a=0
					vPixel24 = TEXA_0 & ( ( AEM ) | ~( vPixel32 - 1 ) );

					// get texa0 value

					// select alpha
					vPixel16 = -( vPixel32 >> 15 );
					vPixel24 = ( TEXA_1 & vPixel16 ) | ( vPixel24 & ~vPixel16 );

					// convert 16-bit pixels to 32-bit pixels
					//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
					vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

					// put in the alpha value
					vPixel32 |= vPixel24;
				}
				else
				{
					// lookup pixel //

					// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
					// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
					// shift/mask pixel (need mask value and right shift value for offset)
					vPixel32 = ( ( vPixel32 >> vPixelShift ) >> ( iShift3 & 0xf ) ) & iAnd3;
					vIdx = ivec4( vPixel32 ) + CSA;

					// lookup pixel in CLUT (and load 16-bit chunks)

					vPixel32 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

					if ( CPSM == 0 )
					{
						// 32-bit lookup //

						vIdx = ( vIdx + 256 ) & 0x1ff;
						vPixel32_1 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

						// combine pixel
						//vPixel32 = ( vPixel32 & 0xffff ) | ( vPixel32_1 << 16 );
						vPixel32 = bitfieldInsert( vPixel32, vPixel32_1, 16, 16 );

						// no rgb24 when lookup //
					}
					else
					{
						// 16-bit lookup //

						// handle aem for rgb16 //

						// get alpha0 if aem=1

						// get texa0 value
						vPixel24 = TEXA_0 & ( ( AEM ) | ~( vPixel32 - 1 ) );

						// select alpha
						vPixel16 = -( vPixel32 >> 15 );
						vPixel24 = ( TEXA_1 & vPixel16 ) | ( vPixel24 & ~vPixel16 );

						// convert 16-bit pixels to 32-bit pixels
						//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
						vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

						// put in the alpha value
						vPixel32 |= vPixel24;

					}	// end if ( CPSM == 0 )

				}	// end if ( ( TPSM & 7 ) < 3 )

			}	// end if ( ( TEXPSM & 1 ) == 0 )


			// fragment color should already be in vaf, vrf, vgf, vbf
			// split into rgba
			vat = ivec4( vPixel32 >> 24 ) & 0xff;
			vrt = ivec4( vPixel32 >> 16 ) & 0xff;
			vgt = ivec4( vPixel32 >> 8 ) & 0xff;
			vbt = ivec4( vPixel32 >> 0 ) & 0xff;

			// tfx, tcc

			if ( TFX == 1 )
			{
				vav = vat;
				vrv = vrt;
				vgv = vgt;
				vbv = vbt;

				if ( TCC == 0 )
				{
					vav = vaf;
				}
			}
			else
			{

				// handle alpha first

				// do the multiply and add
				vmul = ( vat * vaf ) >> 7;
				vadd = vat + vaf;


				// select multiply/add
				//vat = ( TFX == 0 ) ? vmul : vat;
				//vat = ( TFX == 2 ) ? vadd : vat;
				vmul = bitfieldInsert( vmul, vadd, 0, ( TFX << 3 ) );
				vat = bitfieldInsert( vat, vmul, 0, ( TFX - 3 ) & 0x1f );

				// select af,at
				//vav = ( TCC == 0 ) ? vaf : vat;
				vav = bitfieldInsert( vaf, vat, 0, TCC << 5 );

				// COLCLAMP ??
				//vav &= COLCLAMP;

				vav = clamp( vav, 0, 255 );


				// handle the colors next


				//vadd = ( ( TFX & 0x2 ) == 0 ) ? vZero : vaf;
				//vadd = vaf & -( ( TFX >> 1 ) & 1 );
				vadd = vaf & -( TFX >> 1 );

				// red
				vmul = ( ( vrt * vrf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vrv = ( TFX == 1 ) ? vrt : vmul;
				vrv = clamp( vmul, 0, 255 );

				// green
				vmul = ( ( vgt * vgf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vgv = ( TFX == 1 ) ? vgt : vmul;
				vgv = clamp( vmul, 0, 255 );

				// blue
				vmul = ( ( vbt * vbf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vbv = ( TFX == 1 ) ? vbt : vmul;
				vbv = clamp( vmul, 0, 255 );

			}

//#endif

	// re-form pixel //
	//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vbv, vav, 24, 8 ), vrv, 16, 8 ), vgv, 8, 8 );

	// transparency check
	vTPixel32 = vPixel32;

	if ( FGE == 1 )
	{
	// get f0, rf0 //
	vf0 = viF >> 16;
	vrf0 = 0xff - vf0;

//#ifdef ENABLE_FOGGING
	// should do fogging here
	// but pixel is bgr
	vrv = ( ( vrv * vf0 ) >> 8 ) + ( ( vrf0 * FCR ) >> 8 );
	vgv = ( ( vgv * vf0 ) >> 8 ) + ( ( vrf0 * FCG ) >> 8 );
	vbv = ( ( vbv * vf0 ) >> 8 ) + ( ( vrf0 * FCB ) >> 8 );

	//vrv = ivec4 ( ( ( ( ( vPixel32 & 0x00ff00ff ) * uint( vf0 ) ) & 0xff00ff00 ) + ( uint( FCR | ( FCB << 16 ) ) * uint( vrf0 ) ) & 0xff00ff00 ) >> 8 );
	//vgv = ivec4( ( ( ( vPixel32 >> 8 ) & 0x000000ff ) * uint( vf0 ) ) + ( ( uint( FCG ) * uint( vrf0 ) ) & 0x0000ff00 ) ) & 0x0000ff00;
	//vPixel32 = bitfieldInsert( vPixel32, uvec4( vrv | vgv ), 0, 24 );


	// COLCLAMP ??
	//vrv &= COLCLAMP;
	//vgv &= COLCLAMP;
	//vbv &= COLCLAMP;

	// fogging clamp (***todo*** COLCLAMP??)
	//vrv = clamp ( vrv, 0, 255 );
	//vgv = clamp ( vgv, 0, 255 );
	//vbv = clamp ( vbv, 0, 255 );

	// re-form pixel //
	//vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vbv, vav, 24, 8 ), vrv, 16, 8 ), vgv, 8, 8 );
	}
//#endif



	// if not fogging, then use orginal pixel
	//vPixel32 = ( FGE == 0 ) ? vPixel32 : vPixel32_0;




//#ifdef ENABLE_ALPHA_BLEND

		if ( ABE == 1 )
		{
			// alpha blend //


			// A pixel //

			// select
			//uvAlphaSelect [ 0 ] = vPixel32;
			//uvAlphaSelect [ 1 ] = vDestPixel32;

			//vPixelA = uvAlphaSelect [ ALPHA_A ];
			//vPixelB = uvAlphaSelect [ ALPHA_B ];
			//vPixelC = uvAlphaSelect [ ALPHA_C ];
			//vPixelD = uvAlphaSelect [ ALPHA_D ];

			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( uvALPHA_FIX & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );



			// perform alpha blend calculation //

			// get alpha
			ivc = ivec4( vPixelC >> 24 ) & 0xff;

			// do r
			//iva = ivec4( vPixelA >> 16 ) & 0xff;
			//ivb = ivec4( vPixelB >> 16 ) & 0xff;
			//ivd = ivec4( vPixelD >> 16 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 16, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 16, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 16, 8 ) );

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			//iva = ivec4( vPixelA >> 8 ) & 0xff;
			//ivb = ivec4( vPixelB >> 8 ) & 0xff;
			//ivd = ivec4( vPixelD >> 8 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 8, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 8, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 8, 8 ) );

			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			//iva = ivec4( vPixelA >> 0 ) & 0xff;
			//ivb = ivec4( vPixelB >> 0 ) & 0xff;
			//ivd = ivec4( vPixelD >> 0 ) & 0xff;
			iva = ivec4( bitfieldExtract( vPixelA, 0, 8 ) );
			ivb = ivec4( bitfieldExtract( vPixelB, 0, 8 ) );
			ivd = ivec4( bitfieldExtract( vPixelD, 0, 8 ) );

			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			//vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
			vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vPixel32, vrv, 16, 8 ), vgv, 8, 8 ), vbv, 0, 8 );


			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );
		}
//#endif

			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle

//#ifdef ENABLE_SRCALPHA_TEST
			// alpha test //


			// should now be safe for FBA AND FBMSK //
			// set FBA
			vPixel32 |= FBA;

			// FBMSK
			vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );

		//if ( ATE != 0 )
		{
			vTestPixel32 = vTPixel32 >> 24;

			
			uvATSelect = uvec4( ( ( sign( ivec4( vTestPixel32 - vAREF ) ) & iATMask ) + iATOffset ) >> 31 );

			vPixel32 = ( vPixel32 & ( AFAIL_FBMASK | uvATSelect ) ) | ( vDestPixel32 & ~( AFAIL_FBMASK | uvATSelect ) );
			vZPixel32 = ( vZPixel32 & ( AFAIL_ZBMASK | uvATSelect ) ) | ( vZDestPixel32 & ~( AFAIL_ZBMASK | uvATSelect ) );

			//bvATST_LESS = lessThan( vTestPixel32, vAREF );
			//bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			//bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			//ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );

			// alpha fail //

			//uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			//uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );
			//ivATSelect = -ivATSelect;
			//vPixel32 = ( vPixel32 & ( AFAIL_FBMASK | ivATSelect ) ) | ( vDestPixel32 & ~( AFAIL_FBMASK | ivATSelect ) );
			//vZPixel32 = ( vZPixel32 & ( AFAIL_ZBMASK | ivATSelect ) ) | ( vZDestPixel32 & ~( AFAIL_ZBMASK | ivATSelect ) );

			// select between afail pixel and pixel
			//bvTestMask = notEqual( ivATSelect, vZero );
			//vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			//vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
		}
//#endif

//#ifdef ENABLE_DSTALPHA_TEST
		//if ( DATE != 0 )
		{
			// destination alpha test //

			// da test
			uvDASelect = ( vDestPixel32 ^ DATM ) & DATE;
			uvDASelect = ( uvDASelect >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			uvDASelect |= FPSM & 1;

			uvEnable &= uvDASelect;

			/*
			// da test
			ivDASelect = ivec4( ( vDestPixel32 ^ DATM ) & DATE );
			ivDASelect = ivec4( uvec4( ivDASelect ) >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			ivDASelect |= FPSM & 1;

			bvTestMask = notEqual( ivDASelect, vZero );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
			*/
		}

//#endif

//#ifdef ENABLE_DEPTH_TEST
		//if ( ZTE != 0 )
		{
			// depth test //

			uvZTST_EQUAL = usubBorrow( vZDestPixel32, vZPixel32, uvZTST_GREATER );
			uvZSelect = ( sign( ivec4( uvZTST_EQUAL ) ) ^ ZTST_EQUAL ) | uvZTST_GREATER | ZTST_LESS;

			uvEnable &= uvZSelect;

			/*
			bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );
			bvTestMask = bvec4( ivec4( bvZTST_GREATER ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) ) );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
			*/
		}
//#endif


			// and only the enabled pixels
			uvEnable &= sign( ivec4( vTPixel32 ) );
			uvEnable = -uvEnable;

			// and only the enabled pixels
			vPixel32 = ( vPixel32 & uvEnable ) | ( vDestPixel32 & ~uvEnable );

			//vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			//vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );


			// write frame buffer //



			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				//vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );
				vPixel32 = bitfieldInsert( vPixel32, bitfieldExtract( vDPixelX, 24, 8 ), 24, (FPSM & 1) << 3 );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
				//VRAM4 [ ( vOffset.x >> 2 ) + 0 ] = vPixel32_0;
				//VRAM4 [ ( vOffset.x >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset[0] + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset[0] + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset[0] + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset[0] + 10 ] = vPixel32_0 [ 3 ];
				//VRAM[ vOffset.x + 0 ] = vPixel32_0 [ 0 ];
				//VRAM[ vOffset.x + 2 ] = vPixel32_0 [ 1 ];
				//VRAM[ vOffset.x + 8 ] = vPixel32_0 [ 2 ];
				//VRAM[ vOffset.x + 10 ] = vPixel32_0 [ 3 ];
			}



//#ifdef ENABLE_WRITE_ZBUFFER
			// write z buffer //



			if ( ZMSK == 0 )
			{
				vZPixel32 = ( vZPixel32 & uvEnable ) | ( vZDestPixel32 & ~uvEnable );

				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					//vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );
					vZPixel32 = bitfieldInsert( vZPixel32, bitfieldExtract( vZPixelX, 24, 8 ), 24, (ZPSM & 1) << 3 );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
					//VRAM4 [ ( vOffset.y >> 2 ) + 0 ] = vZPixel32_0;
					//VRAM4 [ ( vOffset.y >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
					//VRAM[ vOffset.y + 0 ] = vZPixel32 [ 0 ];
					//VRAM[ vOffset.y + 2 ] = vZPixel32 [ 1 ];
					//VRAM[ vOffset.y + 8 ] = vZPixel32 [ 2 ];
					//VRAM[ vOffset.y + 10 ] = vZPixel32 [ 3 ];
				}
			}



//#endif


				viR += drdx << group_vxinc_shift;
				viG += dgdx << group_vxinc_shift;
				viB += dbdx << group_vxinc_shift;
				viA += dadx << group_vxinc_shift;

				viU += dudx << group_vxinc_shift;
				viV += dvdx << group_vxinc_shift;
				viF += dfdx << group_vxinc_shift;

				//vfS += dsdx * float( group_vxinc );
				//vfT += dtdx * float( group_vxinc );
				//vfQ += dqdx * float( group_vxinc );
				vfS += vxdsdx;
				vfT += vxdtdx;
				vfQ += vxdqdx;

				// *** todo ***
				//viZ += dzdx * double( group_vxinc );
				viZ += vxdzdx;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//vdx += vdxdy * group_yinc;
		vdx += vdxdy << group_yinc_shift;
		
		//vdr += vdrdy << group_yinc_shift;
		//vdg += vdgdy << group_yinc_shift;
		//vdb += vdbdy << group_yinc_shift;
		//vda += vdady << group_yinc_shift;
		vdrgba += vdrgbady << group_yinc_shift;

		//vdu += vdudy << group_yinc_shift;
		//vdv += vdvdy << group_yinc_shift;
		//vdf += vdfdy << group_yinc_shift;
		vduvf += vduvfdy << group_yinc_shift;

		//vds += vdsdy * float( group_yinc );
		//vdt += vdtdy * float( group_yinc );
		//vdq += vdqdy * float( group_yinc );
		//vdstq += vdstqdy * float( group_yinc );
		vdstq += vyvdstqdy;

		// *** todo ***
		//vdz += vdzdy * double( group_yinc );
		vdz += vyvdzdy;
	}
	
	} // end if ( EndY >= StartY )

#ifdef LOAD_TRIANGLE_TEXTURE_VARS

		}	// end for ( uLoop = 0; uLoop < 60; uLoop += 32 )

#endif
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right


	
#ifdef CALC_TRIANGLE_TEXTURE_VARS

	if ( denominator < 0 )
	{
		vdx.x = vx.y << 12;
		vdx.y = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.y >> 4 ) );
		
		vdr = vr.y << 16;
		vdg = vg.y << 16;
		vdb = vb.y << 16;
		vda = va.y << 16;

		vdu = vu.y << 12;
		vdv = vv.y << 12;

		vdf = vf.y << 16;

		vds = vs.y;
		vdt = vt.y;
		vdq = vq.y;

		vdz = double( vz[1] );

		
		if ( ( vy.z - vy.y ) != 0 )
		{
			// triangle is pointed on the bottom //
			vdxdy.x = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
			
			vdrdy = intdivf2(( vr.z - vr.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdgdy = intdivf2(( vg.z - vg.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdbdy = intdivf2(( vb.z - vb.y ), ( vy.z - vy.y ), 0, 4, 16 );
			vdady = intdivf2(( va.z - va.y ), ( vy.z - vy.y ), 0, 4, 16 );

			vdudy = intdivf2(( vu.z - vu.y ), ( vy.z - vy.y ), 4, 4, 16 );
			vdvdy = intdivf2(( vv.z - vv.y ), ( vy.z - vy.y ), 4, 4, 16 );

			vdfdy = intdivf2(( vf.z - vf.y ), ( vy.z - vy.y ), 0, 4, 16 );

			vdsdy = ( ( vs.z - vs.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
			vdtdy = ( ( vt.z - vt.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;
			vdqdy = ( ( vq.z - vq.y ) / ( float( vy.z - vy.y ) ) ) * 16.0f;

			vdzdy = ( ( double(vz[2]) - double(vz[1]) ) / ( double( vy[2] - vy[1] ) ) ) * 16.0;

		}
		
	}
	else
	{
		vdx.y = vx.y << 12;
		vdx.x = ( vx.x << 12 ) + ( ( vy.y - vy.x ) * ( vdxdy.x >> 4 ) );
		
		vdr = ( vr.x << 16 ) + ( ( vy.y - vy.x ) * ( vdrdy >> 4 ) );
		vdg = ( vg.x << 16 ) + ( ( vy.y - vy.x ) * ( vdgdy >> 4 ) );
		vdb = ( vb.x << 16 ) + ( ( vy.y - vy.x ) * ( vdbdy >> 4 ) );
		vda = ( va.x << 16 ) + ( ( vy.y - vy.x ) * ( vdady >> 4 ) );

		vdu = ( vu.x << 12 ) + ( ( vy.y - vy.x ) * ( vdudy >> 4 ) );
		vdv = ( vv.x << 12 ) + ( ( vy.y - vy.x ) * ( vdvdy >> 4 ) );

		vdf = ( vf.x << 16 ) + ( ( vy.y - vy.x ) * ( vdfdy >> 4 ) );

		//vds = vs.x + ( (float( vy.y - vy.x )/16.0f) * vdsdy );
		//vdt = vt.x + ( (float( vy.y - vy.x )/16.0f) * vdtdy );
		//vdq = vq.x + ( (float( vy.y - vy.x )/16.0f) * vdqdy );
		vds = vs.x + ( (float( vy.y - vy.x ) * (1.0f/16.0f)) * vdsdy );
		vdt = vt.x + ( (float( vy.y - vy.x ) * (1.0f/16.0f)) * vdtdy );
		vdq = vq.x + ( (float( vy.y - vy.x ) * (1.0f/16.0f)) * vdqdy );

		vdz = double(vz[0]) + ( (double( vy.y - vy.x ) * (1.0/16.0)) * vdzdy );

		if ( ( vy.z - vy.y ) != 0 )
		{
			// triangle is pointed on the bottom //
			vdxdy.y = intdivf2(( vx.z - vx.y ), ( vy.z - vy.y ), 4, 4, 16 );
		}
	}


	// left point is included if points are equal
	StartY = ( vy.y + 0xf ) >> 4;
	EndY = ( vy.z - 1 ) >> 4;


	Temp = ( StartY << 4 ) - vy.y;


	if ( StartY < DrawArea_TopLeftY )
	{
		if ( EndY < DrawArea_TopLeftY )
		{
			Temp += ( EndY - StartY + 1 ) << 4;
			StartY = EndY + 1;
		}
		else
		{
			Temp += ( DrawArea_TopLeftY - StartY ) << 4;
			StartY = DrawArea_TopLeftY;
		}
	}
	

	// dxdy is in .16, Temp is in .4, and x is in .16
	//vdx [ 0 ] += ( vdxdy [ 0 ] >> 4 ) * Temp;
	//vdx [ 1 ] += ( vdxdy [ 1 ] >> 4 ) * Temp;
	vdx += ( vdxdy >> 4 ) * Temp;
	
	vdr += ( vdrdy >> 4 ) * Temp;
	vdg += ( vdgdy >> 4 ) * Temp;
	vdb += ( vdbdy >> 4 ) * Temp;
	vda += ( vdady >> 4 ) * Temp;

	vdu += ( vdudy >> 4 ) * Temp;
	vdv += ( vdvdy >> 4 ) * Temp;

	vdf += ( vdfdy >> 4 ) * Temp;

	vds += ( vdsdy ) * ( float( Temp ) * (1.0f/16.0f) );
	vdt += ( vdtdy ) * ( float( Temp ) * (1.0f/16.0f) );
	vdq += ( vdqdy ) * ( float( Temp ) * (1.0f/16.0f) );

	// *** todo *** should be a double
	//vdz += ( vdzdy ) * ( double( Temp )/16.0 );
	vdz += ( vdzdy ) * ( double( Temp ) * (1.0/16.0) );
	
	
	if ( EndY > DrawArea_BottomRightY )
	{
		EndY = DrawArea_BottomRightY;
	}



#ifdef LOAD_TRIANGLE_TEXTURE_VARS

		// second set //

		
		StartY = data [ uIdx + 96 ];
		EndY = data [ uIdx + 97 ];

		vdx.x = data [ uIdx + 98 ];
		vdx.y = data [ uIdx + 99 ];

		vdr = data [ uIdx + 100 ];
		vdg = data [ uIdx + 101 ];
		vdb = data [ uIdx + 102 ];
		vda = data [ uIdx + 103 ];

		vdu = data [ uIdx + 104 ];
		vdv = data [ uIdx + 105 ];
		vdf = data [ uIdx + 106 ];

		vdz2[0] = uint( data [ uIdx + 107 ] );

		vds = intBitsToFloat( data [ uIdx + 108 ] );
		vdt = intBitsToFloat( data [ uIdx + 109 ] );
		vdq = intBitsToFloat( data [ uIdx + 110 ] );

		vdz2[1] = uint( data [ uIdx + 111 ] );

		vdz = packDouble2x32( vdz2 );


		vdxdy.x = data [ uIdx + 112 ];
		vdxdy.y = data [ uIdx + 113 ];

		vdzdy2[0] = uint( data [ uIdx + 114 ] );
		vdzdy2[1] = uint( data [ uIdx + 115 ] );
		vdzdy = packDouble2x32( vdzdy2 );

		vdrdy = data [ uIdx + 116 ];
		vdgdy = data [ uIdx + 117 ];
		vdbdy = data [ uIdx + 118 ];
		vdady = data [ uIdx + 119 ];

		vdudy = data [ uIdx + 120 ];
		vdvdy = data [ uIdx + 121 ];
		vdfdy = data [ uIdx + 122 ];

		vdsdy = intBitsToFloat( data [ uIdx + 124 ] );
		vdtdy = intBitsToFloat( data [ uIdx + 125 ] );
		vdqdy = intBitsToFloat( data [ uIdx + 126 ] );
		

#endif	// end #ifdef LOAD_TRIANGLE_TEXTURE_VARS

	
	if ( EndY >= StartY )
	{


	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;


	
	// offset yid
	vdx += vdxdy * yid;

	vdr += vdrdy * yid;
	vdg += vdgdy * yid;
	vdb += vdbdy * yid;
	vda += vdady * yid;

	vdu += vdudy * yid;
	vdv += vdvdy * yid;

	vdf += vdfdy * yid;

	vds += vdsdy * float( yid );
	vdt += vdtdy * float( yid );
	vdq += vdqdy * float( yid );

	// ***todo***
	vdz += vdzdy * double( yid );
	




	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		// get the y-offset for row
		yoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( DRAWPSM << 7 ) ];
		yoffset32 = ( Line & LUT_YNAND[ DRAWPSM ] ) * ( FrameBufferWidth_Pixels );

		zyoffset32_xor = LUT_YOFFSET [ ( Line & 0x3f ) | ( ZBUFPSM << 7 ) ];
		zyoffset32 = ( Line & LUT_YNAND[ ZBUFPSM ] ) * ( FrameBufferWidth_Pixels );

		// left point is included if points are equal
		StartX = ( vdx.x + 0xffff ) >> 16;
		EndX = ( vdx.y - 1 ) >> 16;


		if ( StartX <= DrawArea_BottomRightX && EndX >= DrawArea_TopLeftX && EndX >= StartX )
		{


			iR = vdr;
			iG = vdg;
			iB = vdb;
			iA = vda;

			iU = vdu;
			iV = vdv;

			iF = vdf;

			fS = vds;
			fT = vdt;
			fQ = vdq;

			// *** todo ***
			iZ = vdz;
			
			
			// get distance from point to pixel
			Temp = ( StartX << 16 ) - vdx.x;
			
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - StartX ) << 16;
				StartX = DrawArea_TopLeftX;
			}


			iR += ( drdx >> 8 ) * ( Temp >> 8 );
			iG += ( dgdx >> 8 ) * ( Temp >> 8 );
			iB += ( dbdx >> 8 ) * ( Temp >> 8 );
			iA += ( dadx >> 8 ) * ( Temp >> 8 );

			iU += ( dudx >> 8 ) * ( Temp >> 8 );
			iV += ( dvdx >> 8 ) * ( Temp >> 8 );

			iF += ( dfdx >> 8 ) * ( Temp >> 8 );

			//fS += dsdx * ( float( Temp )/65536.0f );
			//fT += dtdx * ( float( Temp )/65536.0f );
			//fQ += dqdx * ( float( Temp )/65536.0f );
			fS += dsdx * ( float( Temp ) * (1.0f/65536.0f) );
			fT += dtdx * ( float( Temp ) * (1.0f/65536.0f) );
			fQ += dqdx * ( float( Temp ) * (1.0f/65536.0f) );

			//iZ += dzdx * ( double( Temp )/65536.0 );
			iZ += dzdx * ( double( Temp ) * (1.0/65536.0) );
			

			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = Window_XRight + 1;
				EndX = DrawArea_BottomRightX;
			}


			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( StartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );




			
			viR = iR + ( vxid * drdx );
			viG = iG + ( vxid * dgdx );
			viB = iB + ( vxid * dbdx );
			viA = iA + ( vxid * dadx );

			viU = iU + ( vxid * dudx );
			viV = iV + ( vxid * dvdx );

			viF = iF + ( vxid * dfdx );

			vfS = fS + ( vec4( vxid ) * dsdx );
			vfT = fT + ( vec4( vxid ) * dtdx );
			vfQ = fQ + ( vec4( vxid ) * dqdx );

			viZ = iZ + ( dvec4( vxid ) * dzdx );
			

			
			w = EndX - StartX + 1;

			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = StartX; x_across <= EndX; x_across += c_iVectorSize )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
					
				
			// get the pixels to be drawn
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

			// z value is z0
			//vZPixel32 = ivec4( z0 );
			vZPixel32 = ivec4( viZ );

			// calculate xoffset
			vIdx = ( vx_across + StartX );

			vIdx = ( vIdx & 0x0fff ) | ( DRAWPSM << 12 );
			//vXOffset32 = ivec4( LUT_XOFFSET [ vIdx[0] ], LUT_XOFFSET [ vIdx[1] ], LUT_XOFFSET [ vIdx[2] ], LUT_XOFFSET [ vIdx[3] ] );
			vXOffset32[0] = LUT_XOFFSET [ vIdx[0] ];
			vXOffset32 ^= yoffset32_xor;
			vOffset = vXOffset32 + yoffset32;
			vOffset <<= ( DRAWPSM & 1 ) ^ 1;
			vOffset += FrameBufferStartOffset32;

			vIdx = ( vIdx & 0x0fff ) | ( ZBUFPSM << 12 );
			//vZXOffset32 = ivec4( LUT_XOFFSET [ vIdx[0] ], LUT_XOFFSET [ vIdx[1] ], LUT_XOFFSET [ vIdx[2] ], LUT_XOFFSET [ vIdx[3] ] );
			vZXOffset32[0] = LUT_XOFFSET [ vIdx[0] ];
			vZXOffset32 ^= zyoffset32_xor;
			vZOffset = vZXOffset32 + zyoffset32;
			vZOffset <<= ( ZBUFPSM & 1 ) ^ 1;
			vZOffset += ZBufferStartOffset32;

			// pull the pixels //
#ifdef USE_TRIANGLE_MULTI_PIXEL

			// x-bit pixels //

			vDestPixel32_0 = VRAM4[ ( vOffset[0] >> 2 ) + 0 ];
			vDestPixel32_1 = VRAM4[ ( vOffset[0] >> 2 ) + 2 ];

			// combine
			vDestPixel32.xy = ( vDestPixel32_0.xz & 0xffff ) | ( vDestPixel32_0.yw << 16 );
			vDestPixel32.zw = ( vDestPixel32_1.xz & 0xffff ) | ( vDestPixel32_1.yw << 16 );

			vDPixelX = vDestPixel32;

			// extract
			vDestPixel32 >>= ( ( vOffset[0] & DRAWPSM & 1 ) << 4 );

			if ( ( DRAWPSM & 1 ) == 1 )
			{
				// 16-bit pixels //

				// convert from 16-bit to 32-bit
				vDestPixel32 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
			}

#else

			
			// pull the pixels //
			vDestPixel32_0 = uvec4( VRAM[vOffset[0]], VRAM[vOffset[1]], VRAM[vOffset[2]], VRAM[vOffset[3]] );

			// get upper pixels
			vDestPixel32_1 = uvec4( VRAM[vOffset[0]+1], VRAM[vOffset[1]+1], VRAM[vOffset[2]+1], VRAM[vOffset[3]+1] );

			
			// make 32-bit pixels
			vDestPixel32 = ( vDestPixel32_0 & 0xffff ) | ( vDestPixel32_1 << 16 );

			// if destination pixel is 16-bit, need to convert to 32-bit and include alpha for alpha blending, etc
			vPixel16 = ( ( vDestPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDestPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDestPixel32 << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDestPixel32 << 16 ) & ( 0x80 << 24 ) );
			vDestPixel32 = ( ( DRAWPSM & 1 ) == 0 ) ? vDestPixel32 : vPixel16;

			// save the original pixel from the dest for later (da test)
			vDPixelX = vDestPixel32;
#endif


			// if destination pixel is 24-bit, need to set alpha
			vDestPixel32 = ( vDestPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( (FPSM & 1) << 31 );


#ifdef USE_TRIANGLE_MULTI_ZPIXEL

			// x-bit zpixels //

			vZDestPixel32_0 = VRAM4[ ( vZOffset[0] >> 2 ) + 0 ];
			vZDestPixel32_1 = VRAM4[ ( vZOffset[0] >> 2 ) + 2 ];

			// combine
			vZDestPixel32.xy = ( vZDestPixel32_0.xz & 0xffff ) | ( vZDestPixel32_0.yw << 16 );
			vZDestPixel32.zw = ( vZDestPixel32_1.xz & 0xffff ) | ( vZDestPixel32_1.yw << 16 );

			vZPixelX = vZDestPixel32;

			// extract
			vZDestPixel32 >>= ( ( vZOffset[0] & ZBUFPSM & 1 ) << 4 );

#else

			// pull the z-pixels //
			vZDestPixel32_0 = uvec4( VRAM[vZOffset[0]], VRAM[vZOffset[1]], VRAM[vZOffset[2]], VRAM[vZOffset[3]] );

			// get upper z-pixels
			vZDestPixel32_1 = uvec4( VRAM[vZOffset[0]+1], VRAM[vZOffset[1]+1], VRAM[vZOffset[2]+1], VRAM[vZOffset[3]+1] );

			// make 32-bit z-pixels
			vZDestPixel32 = ( vZDestPixel32_0 & 0xffff ) | ( vZDestPixel32_1 << 16 );

			vZPixelX = vZDestPixel32;
#endif


			// if 24-bit z-buffer, then top pixel is masked
			// if 16-bit z-buffer, then top pixel is zero
			vZDestPixel32 &= ( (-1u) >> ( (ZPSM & 3) << 3 ) );


			// load pixel to draw //


			// set fragment color //

			// ***TODO*** this is a PROBLEM, since iR, iG, iB, iA are signed 32-bit values, so below can easily get wrong colors!
			vrf = viR >> 16;
			vgf = viG >> 16;
			vbf = viB >> 16;
			vaf = viA >> 16;
			
			// clamp fragment color
			// *** NOTE *** need to clamp here since we are using s32 instead of s64 for iR,iG,iB,iA
			vrf &= 0xff;
			vgf &= 0xff;
			vbf &= 0xff;
			vaf &= 0xff;
			

			// get viU, viV //
			if ( FST == 0 )
			{
				vTexCoordX = ivec4(vfS / vfQ);
				vTexCoordY = ivec4(vfT / vfQ);
			}
			else
			{
				vTexCoordX = viU >> 16;
				vTexCoordY = viV >> 16;

			}

			//vTexCoordX = ( FST == 0 ) ? vTexCoordX : ( viU >> 16 );
			//vTexCoordY = ( FST == 0 ) ? vTexCoordY : ( viV >> 16 );


//#ifdef ENABLE_TEXTURE_MAPPING
			// need to start texture coord from left again
			//viU = u0 + ( vxid * dudx );
			
			//TexCoordY = ( viV >> 16 );
			
			//vTexCoordY = ( ( vTexCoordY < TexY_Min ) ? ivec4( TexY_Min ) : vTexCoordY );
			//vTexCoordY = ( ( vTexCoordY > TexY_Max ) ? ivec4( TexY_Max ) : vTexCoordY );
			vTexCoordY = mix( vTexCoordY, ivec4( TexY_Min ), lessThan( vTexCoordY, ivec4( TexY_Min ) ) );
			vTexCoordY = mix( vTexCoordY, ivec4( TexY_Max ), greaterThan( vTexCoordY, ivec4( TexY_Max ) ) );
			vTexCoordY &= TexY_And;
			vTexCoordY |= TexY_Or;

			//iTYOffset = LUT_YOFFSET [ ( TexCoordY & 0x7f ) | ( TEXPSM << 7 ) ];
			//iTYOffset += ( TexCoordY & LUT_YNAND[ TEXPSM ] ) * TextureBufferWidth_Pixels;
			vIdx = ( vTexCoordY & 0x7f ) | ( TEXPSM << 7 );
			vxTYOffset = ivec4( LUT_YOFFSET[vIdx[0]], LUT_YOFFSET[vIdx[1]], LUT_YOFFSET[vIdx[2]], LUT_YOFFSET[vIdx[3]] );
			viTYOffset = ( vTexCoordY & LUT_YNAND[ TEXPSM ] ) * TextureBufferWidth_Pixels;
			//xTYOffset = LUT_YOFFSET [ ( TexCoordY & 0x7f ) | ( TEXPSM << 7 ) ];
			//iTYOffset = ( TexCoordY & LUT_YNAND[ TEXPSM ] ) * TextureBufferWidth_Pixels;

//#endif


//#ifdef ENABLE_TEXTURE_MAPPING
			//vTexCoordX = ( viU >> 16 );


			//vTexCoordX = ( ( vTexCoordX < TexX_Min ) ? TexX_Min : vTexCoordX );
			//vTexCoordX = ( ( vTexCoordX > TexX_Max ) ? TexX_Max : vTexCoordX );
			vTexCoordX = mix( vTexCoordX, ivec4( TexX_Min ), lessThan( vTexCoordX, ivec4( TexX_Min ) ) );
			vTexCoordX = mix( vTexCoordX, ivec4( TexX_Max ), greaterThan( vTexCoordX, ivec4( TexX_Max ) ) );
			vTexCoordX &= TexX_And;
			vTexCoordX |= TexX_Or;


			vIdx = ( vTexCoordX & 0x0fff ) | ( TEXPSM << 12 );
			vTXOffset = ivec4( LUT_XOFFSET[ vIdx[0] ], LUT_XOFFSET[ vIdx[1] ], LUT_XOFFSET[ vIdx[2] ], LUT_XOFFSET[ vIdx[3] ] );


			// need to shift to left once if 32-bit pixels //
			vTOffset = vTXOffset ^ vxTYOffset;
			vTOffset += viTYOffset;



			// iAnd1= 32-bit: 0, 16-bit: 0, 8-bit: 0x1, 4-bit: 0x3
			// iShift1= 32-bit: 0, 16-bit: 0, 8-bit: 3, 4-bit: 2
			// get the amount to shift pixel
			vPixelShift = ( vTOffset & iAnd1 ) << iShift1;

			// if looking up 32-bit pixels, then need to multiply by 2 in x-direction
			vTOffset <<= 1;

			// iShift2= 32-bit: 0, 16-bit: 1, 8-bit: 2, 4-bit: 3
			// get the remainder of the offset (for 32-bit lookup after already shifting left 1)
			vTOffset >>= iShift2;

			vTOffset += TextureBufferStartOffset32;

			// check if 32-bit pixel format or not for texture
			if ( ( TEXPSM & 0x7 ) == 0 )
			{
				// 32-bit texture pixel //

				
				// load 32-bit pixel data
				vTOffset >>= 1;
				vPixel32_0.xy = VRAM2 [ vTOffset[0] ];
				vPixel32_0.zw = VRAM2 [ vTOffset[1] ];
				vPixel32_1.xy = VRAM2 [ vTOffset[2] ];
				vPixel32_1.zw = VRAM2 [ vTOffset[3] ];

				// combine
				vPixel32.xy = ( vPixel32_0.xz & 0xffff ) | ( vPixel32_0.yw << 16 );
				vPixel32.zw = ( vPixel32_1.xz & 0xffff ) | ( vPixel32_1.yw << 16 );
				

				//vPixel32_0 = uvec4( VRAM [ vTOffset[0] ], VRAM [ vTOffset[1] ], VRAM [ vTOffset[2] ], VRAM [ vTOffset[3] ] );
				//vPixel32_1 = uvec4( VRAM [ vTOffset[0]+1 ], VRAM [ vTOffset[1]+1 ], VRAM [ vTOffset[2]+1 ], VRAM [ vTOffset[3]+1 ] );

				// combine pixel
				//vPixel32 = ( vPixel32_0 & 0xffff ) | ( vPixel32_1 << 16 );

				// check if rgb24 format
				if ( ( TPSM & 1 ) == 1 )
				{
					// handle aem for rgb24 //

					// mask pixel
					vPixel32 &= 0x00ffffff;

					// check if zero
					vPixel24 = mix( uvTEXA_0, vZero, equal( vPixel32, vZero ) );

					// pull in texa if aem=0
					vPixel24 = vPixel24 | ( TEXA_0 & ( AEM-1 ) );
					vPixel32 |= vPixel24;
				}
			}
			else
			{
				// either 16-bit or lookup pixel //


				// pull the pixel
				vTOffset += ( iShift3 >> 3 ) & 1;
				vPixel32 = uvec4( VRAM [ vTOffset[0] ], VRAM [ vTOffset[1] ], VRAM [ vTOffset[2] ], VRAM [ vTOffset[3] ] );

				// check if pixel needs lookup
				if ( ( TPSM & 7 ) < 3 )
				{
					// straight 16-bit pixel //


					// handle aem for rgb16 //

					// get alpha0 if aem=1
					vPixel24 = mix( uvTEXA_0, vZero, equal( vPixel32 & 0x7fff, vZero ) );

					// get texa0 value
					vPixel24 = vPixel24 | ( TEXA_0 & ( AEM-1 ) );

					// select alpha
					vPixel24 = mix( uvTEXA_1, vPixel24, equal( vPixel32 & 0x8000, vZero ) );

					// convert 16-bit pixels to 32-bit pixels
					//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
					vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

					// put in the alpha value
					vPixel32 |= vPixel24;
				}
				else
				{
					// lookup pixel //

					// pull the high pixel for now
					//vTOffset += 1;
					//vPixel32_1 = uvec4( VRAM [ vTOffset[0]+1 ], VRAM [ vTOffset[1]+1 ], VRAM [ vTOffset[2]+1 ], VRAM [ vTOffset[3]+1 ] );

					// combine pixel for now
					//vPixel32 = ( vPixel32 & 0xffff ) | ( vPixel32_1 << 16 );

					// iAnd3= 32-bit: -1, 16-bit: 0xffff, 8-bit: 0xff, 4-bit: 0xf
					// iShift3= 32-bit: 0, 16-bit: 0, 8-bit: 0, 4-bit: 0, 8h-bit: 24, 4hh-bit: 28, 4hl-bit: 24
					// shift/mask pixel (need mask value and right shift value for offset)
					vPixel32 = ( ( vPixel32 >> vPixelShift ) >> ( iShift3 & 0xf ) ) & iAnd3;
					vIdx = ivec4( vPixel32 ) + CSA;

					// lookup pixel in CLUT (and load 16-bit chunks)

					vPixel32 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

					if ( CPSM == 0 )
					{
						// 32-bit lookup //

						vIdx = ( vIdx + 256 ) & 0x1ff;
						vPixel32_1 = uvec4( LOCAL_CLUT[ vIdx[0] ], LOCAL_CLUT[ vIdx[1] ], LOCAL_CLUT[ vIdx[2] ], LOCAL_CLUT[ vIdx[3] ] );

						// combine pixel
						//vPixel32 = ( vPixel32 & 0xffff ) | ( vPixel32_1 << 16 );
						vPixel32 = bitfieldInsert( vPixel32, vPixel32_1, 16, 16 );

						// no rgb24 when lookup //
					}
					else
					{
						// 16-bit lookup //

						// handle aem for rgb16 //

						// get alpha0 if aem=1
						vPixel24 = mix( uvTEXA_0, vZero, equal( vPixel32 & 0x7fff, vZero ) );

						// get texa0 value
						vPixel24 = vPixel24 | ( TEXA_0 & ( AEM-1 ) );

						// select alpha
						vPixel24 = mix( uvTEXA_1, vPixel24, equal( vPixel32 & 0x8000, vZero ) );

						// convert 16-bit pixels to 32-bit pixels
						//vPixel32 = ( ( vPixel32 << 3 ) & ( 0xf8 << 0 ) ) | ( ( vPixel32 << 6 ) & ( 0xf8 << 8 ) ) | ( ( vPixel32 << 9 ) & ( 0xf8 << 16 ) );
						vPixel32 = bitfieldInsert( bitfieldInsert( bitfieldInsert( vZero, vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 5, 5 ), 11, 5 ), bitfieldExtract( vPixel32, 10, 5 ), 19, 5 );

						// put in the alpha value
						vPixel32 |= vPixel24;

					}	// end if ( CPSM == 0 )

				}	// end if ( ( TPSM & 7 ) < 3 )

			}	// end if ( ( TEXPSM & 1 ) == 0 )


			// fragment color should already be in vaf, vrf, vgf, vbf
			// split into rgba
			vat = ivec4( vPixel32 >> 24 ) & 0xff;
			vrt = ivec4( vPixel32 >> 16 ) & 0xff;
			vgt = ivec4( vPixel32 >> 8 ) & 0xff;
			vbt = ivec4( vPixel32 >> 0 ) & 0xff;

			// tfx, tcc

			if ( TFX == 1 )
			{
				vav = vat;
				vrv = vrt;
				vgv = vgt;
				vbv = vbt;

				if ( TCC == 0 )
				{
					vav = vaf;
				}
			}
			else
			{

				// handle alpha first

				// do the multiply and add
				vmul = ( vat * vaf ) >> 7;
				vadd = vat + vaf;


				// select multiply/add
				vat = ( TFX == 0 ) ? vmul : vat;
				vat = ( TFX == 2 ) ? vadd : vat;

				// select af,at
				vav = ( TCC == 0 ) ? vaf : vat;

				// COLCLAMP ??
				//vav &= COLCLAMP;

				vav = clamp( vav, 0, 255 );


				// handle the colors next


				//vadd = ( ( TFX & 0x2 ) == 0 ) ? vZero : vaf;
				vadd = vaf & -( ( TFX >> 1 ) & 1 );

				// red
				vmul = ( ( vrt * vrf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vrv = ( TFX == 1 ) ? vrt : vmul;
				vrv = clamp( vmul, 0, 255 );

				// green
				vmul = ( ( vgt * vgf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vgv = ( TFX == 1 ) ? vgt : vmul;
				vgv = clamp( vmul, 0, 255 );

				// blue
				vmul = ( ( vbt * vbf ) >> 7 ) + vadd;
				//vmul &= COLCLAMP;

				//vmul = clamp( vmul, 0, 255 );
				//vbv = ( TFX == 1 ) ? vbt : vmul;
				vbv = clamp( vmul, 0, 255 );

			}

//#endif

	// re-form pixel //
	vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );


	// transparency check
	vTPixel32 = vPixel32;

	if ( FGE == 1 )
	{
	// get f0, rf0 //
	vf0 = viF >> 16;
	vrf0 = 0xff - vf0;

//#ifdef ENABLE_FOGGING
	// should do fogging here
	vrv = ( ( vrv * vf0 ) >> 8 ) + ( ( vrf0 * FCR ) >> 8 );
	vgv = ( ( vgv * vf0 ) >> 8 ) + ( ( vrf0 * FCG ) >> 8 );
	vbv = ( ( vbv * vf0 ) >> 8 ) + ( ( vrf0 * FCB ) >> 8 );

	// COLCLAMP ??
	vrv &= COLCLAMP;
	vgv &= COLCLAMP;
	vbv &= COLCLAMP;

	// fogging clamp (***todo*** COLCLAMP??)
	vrv = clamp ( vrv, 0, 255 );
	vgv = clamp ( vgv, 0, 255 );
	vbv = clamp ( vbv, 0, 255 );

	// re-form pixel //
	//vPixel32_0 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	vPixel32 = ( vav << 24 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );
	}
//#endif



	// if not fogging, then use orginal pixel
	//vPixel32 = ( FGE == 0 ) ? vPixel32 : vPixel32_0;




//#ifdef ENABLE_ALPHA_BLEND

		if ( ABE == 1 )
		{
			// alpha blend //


			// A pixel //

			// select
			//vPixelA = ( ( vPixel32 & (ALPHA_A-1) ) | ( vDestPixel32 & -ALPHA_A ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			//vPixelB = ( ( vPixel32 & (ALPHA_B-1) ) | ( vDestPixel32 & -ALPHA_B ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			//vPixelD = ( ( vPixel32 & (ALPHA_D-1) ) | ( vDestPixel32 & -ALPHA_D ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			//vPixelC = ( ( ( vPixel32 & (ALPHA_C-1) ) | ( vDestPixel32 & -ALPHA_C ) ) & ( ( ALPHA_C >> 1 ) - 1 ) ) | ( uvec4( ALPHA_FIX ) & -(ALPHA_C >> 1) );
			vPixelA = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_A << 5 ) ) & ( ( ALPHA_A >> 1 ) - 1 );
			vPixelB = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_B << 5 ) ) & ( ( ALPHA_B >> 1 ) - 1 );
			vPixelD = bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_D << 5 ) ) & ( ( ALPHA_D >> 1 ) - 1 );
			vPixelC = bitfieldInsert( bitfieldInsert( vPixel32, vDestPixel32, 0, int( ALPHA_C << 5 ) ), uvALPHA_FIX, 0, int( (ALPHA_C >> 1) << 5 ) );


			// perform alpha blend calculation //

			// get alpha
			ivc = ivec4( vPixelC >> 24 ) & 0xff;

			// do r
			iva = ivec4( vPixelA >> 16 ) & 0xff;
			ivb = ivec4( vPixelB >> 16 ) & 0xff;
			ivd = ivec4( vPixelD >> 16 ) & 0xff;

			// calc ( a - b ) * c + d
			vrv = ( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// do g,b
			iva = ivec4( vPixelA >> 8 ) & 0xff;
			ivb = ivec4( vPixelB >> 8 ) & 0xff;
			ivd = ivec4( vPixelD >> 8 ) & 0xff;
			vgv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;
			iva = ivec4( vPixelA >> 0 ) & 0xff;
			ivb = ivec4( vPixelB >> 0 ) & 0xff;
			ivd = ivec4( vPixelD >> 0 ) & 0xff;
			vbv = ivec4( ( ( iva - ivb ) * ivc ) >> 7 ) + ivd;

			// ***todo*** dithering will use the values before clamping //




			// clamp (COLCLAMP??) //
			vrv &= COLCLAMP;
			vgv &= COLCLAMP;
			vbv &= COLCLAMP;

			vrv = clamp ( vrv, 0, 255 );
			vgv = clamp ( vgv, 0, 255 );
			vbv = clamp ( vbv, 0, 255 );

			// re-form pixel (with source alpha??)
			vPixel32_0 = ( vPixel32 & 0xff000000 ) | ( vrv << 16 ) | ( vgv << 8 ) | ( vbv << 0 );


			// if alpha blending disabled, overwrite alpha blended pixel
			//vPixel32_0 = ( ABE == 0 ) ? vPixel32 : vPixel32_0;

			// if PABE is set and msb is set, then don't alpha blend pixel (overwrite?)
			vPixel32 = mix( vPixel32, vPixel32_0, equal( vPixel32 & PABE, ivec4( PABE ) ) );
		}
//#endif



			// select alpha blended pixel if alpha enabled //
			// not needed for rectangle

//#ifdef ENABLE_SRCALPHA_TEST
			// alpha test //

			vTestPixel32 = vPixel32 >> 24;


			// should now be safe for FBA AND FBMSK //
			// set FBA
			vPixel32 |= FBA;

			// FBMSK
			vPixel32 = ( vDestPixel32 & FBMSK ) | ( vPixel32 & ~FBMSK );


			bvATST_LESS = lessThan( vTestPixel32, vAREF );
			bvATST_GREATER = greaterThan( vTestPixel32, vAREF );
			bvATST_EQUAL = equal( vTestPixel32, vAREF );

			// get pixel selection
			ivATSelect = ( ivec4( bvATST_LESS ) & ATST_LESS ) | ( ivec4( bvATST_GREATER ) & ATST_GREATER ) | ( ivec4( bvATST_EQUAL ) & ATST_EQUAL );

			// alpha fail //

			uvAFAIL_PIXEL = ( vPixel32 & AFAIL_FBMASK ) | ( vDestPixel32 & ~AFAIL_FBMASK );
			uvAFAIL_ZPIXEL = ( vZPixel32 & AFAIL_ZBMASK ) | ( vZDestPixel32 & ~AFAIL_ZBMASK );

			// select between afail pixel and pixel
			bvTestMask = notEqual( ivATSelect, vZero );
			vPixel32 = mix( uvAFAIL_PIXEL, vPixel32, bvTestMask );
			vZPixel32 = mix( uvAFAIL_ZPIXEL, vZPixel32, bvTestMask );
//#endif




//#ifdef ENABLE_DSTALPHA_TEST
			// destination alpha test //

			// calc 16-bit pixel
			//vPixel16 = ( ( vDPixelX << 3 ) & ( 0xf8 << 0 ) ) | ( ( vDPixelX << 6 ) & ( 0xf8 << 8 ) ) | ( ( vDPixelX << 9 ) & ( 0xf8 << 16 ) ) | ( ( vDPixelX << 16 ) & ( 0x80 << 24 ) );

			// use 16-bit pixel if 16-bit frame-buffer
			//vDPixelX = ( ( DRAWPSM & 1 ) == 0 ) ? vDPixelX : vPixel16;
			//vDPixelX <<= ( DRAWPSM & 1 ) << 4;

			// da test
			ivDASelect = ivec4( ( vDestPixel32 ^ DATM ) & DATE );
			ivDASelect = ivec4( uvec4( ivDASelect ) >> 31 ) ^ 1;

			// all pixels pass if FPSM is 24-bit
			// (if component is zero, then passes)
			//vDPixelX = ( ( FPSM & 1 ) == 0 ) ? vDPixelX : vZero;
			ivDASelect |= FPSM & 1;

			//ivDASelect = ( ivec4( vDestPixel32 ^ DATM ) | int( DATE ) ) >> 31;
//#endif

//#ifdef ENABLE_DEPTH_TEST
			// depth test //

			bvZTST_LESS = lessThan( vZPixel32, vZDestPixel32 );
			bvZTST_GREATER = greaterThan( vZPixel32, vZDestPixel32 );
			bvZTST_EQUAL = equal( vZPixel32, vZDestPixel32 );
			ivZSelect = ( ivec4( bvZTST_LESS ) & int( ZTST_LESS ) ) | ( ivec4( bvZTST_GREATER ) & int( ZTST_GREATER ) ) | ( ivec4( bvZTST_EQUAL ) & int( ZTST_EQUAL ) );
//#endif




//#ifdef ENABLE_PIXEL_TEST
			// select pixels
			bvTestMask = notEqual( ivZSelect & ivDASelect, vZero );

			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );
//#endif


			// and only the enabled pixels
			vPixel32 = mix( vDestPixel32, vPixel32, bvEnable );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvEnable );

			// also check for transparent pixels in texture (rgba=0??)
			bvTestMask = notEqual( vTPixel32, vZero );
			vPixel32 = mix( vDestPixel32, vPixel32, bvTestMask );
			vZPixel32 = mix( vZDestPixel32, vZPixel32, bvTestMask );


			// write frame buffer //


			if ( ( DRAWPSM & 1 ) == 0 )
			{
				// 32-bit pixels //

				// if storing to 24-bit buffer, combine pixel with destination
				vPixel32 = ( vPixel32 & ( (-1u) >> ( (FPSM & 1) << 3 ) ) ) | ( vDPixelX & ( (-(FPSM & 1)) << 24 ) );

				// split the pixels //
				vPixel32_0.xz = vPixel32.xy & 0xffff;
				vPixel32_0.yw = vPixel32.xy >> 16;
				vPixel32_1.xz = vPixel32.zw & 0xffff;
				vPixel32_1.yw = vPixel32.zw >> 16;

				// store the pixels //
				VRAM4 [ ( vOffset[0] >> 2 ) + 0 ] = vPixel32_0;
				VRAM4 [ ( vOffset[0] >> 2 ) + 2 ] = vPixel32_1;
			}
			else
			{
				// 16-bit pixels

				// convert 32-bit pixels to 16-bit
				//vPixel32_0 = ( ( vPixel32 >> 3 ) & 0x001f ) | ( ( vPixel32 >> 6 ) & 0x03e0 ) | ( ( vPixel32 >> 9 ) & 0x7c00 ) | ( ( vPixel32 >> 16 ) & 0x8000 );
				vPixel32_0 = bitfieldInsert( bitfieldInsert( bitfieldInsert( bitfieldExtract( vPixel32, 3, 5 ), bitfieldExtract( vPixel32, 11, 5 ), 5, 5 ), bitfieldExtract( vPixel32, 19, 5 ), 10, 5 ), bitfieldExtract( vPixel32, 31, 1 ), 15, 1 );

				// store the pixels //
				VRAM[ vOffset[0] + 0 ] = vPixel32_0 [ 0 ];
				VRAM[ vOffset[0] + 2 ] = vPixel32_0 [ 1 ];
				VRAM[ vOffset[0] + 8 ] = vPixel32_0 [ 2 ];
				VRAM[ vOffset[0] + 10 ] = vPixel32_0 [ 3 ];
			}



//#ifdef ENABLE_WRITE_ZBUFFER
			// write z buffer //


#ifdef USE_TRIANGLE_MULTI_ZPIXEL_STORE

			if ( ZMSK == 0 )
			{
				if ( ( ZBUFPSM & 1 ) == 0 )
				{
					// 32-bit pixels //

					// if storing to 24-bit z-buffer, combine top z-pixel with destination
					vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );

					// split the pixels //
					vZPixel32_0.xz = vZPixel32.xy & 0xffff;
					vZPixel32_0.yw = vZPixel32.xy >> 16;
					vZPixel32_1.xz = vZPixel32.zw & 0xffff;
					vZPixel32_1.yw = vZPixel32.zw >> 16;

					// store the pixels //
					VRAM4 [ ( vZOffset[0] >> 2 ) + 0 ] = vZPixel32_0;
					VRAM4 [ ( vZOffset[0] >> 2 ) + 2 ] = vZPixel32_1;
				}
				else
				{
					// 16-bit pixels

					// store the pixels //
					VRAM[ vZOffset[0] + 0 ] = vZPixel32 [ 0 ];
					VRAM[ vZOffset[0] + 2 ] = vZPixel32 [ 1 ];
					VRAM[ vZOffset[0] + 8 ] = vZPixel32 [ 2 ];
					VRAM[ vZOffset[0] + 10 ] = vZPixel32 [ 3 ];
				}
			}


#else

			// have to control stores here to prevent potential pixel overwrites
			if ( ZMSK == 0 )
			{
				// if storing to 24-bit z-buffer, combine top z-pixel with destination
				vZPixel32 = ( vZPixel32 & ( (-1u) >> ( (ZPSM & 1) << 3 ) ) ) | ( vZPixelX & ( (-(ZPSM & 1)) << 24 ) );

				// split the z-pixels //
				vZPixel32_0 = vZPixel32 & 0xffff;
				vZPixel32_1 = vZPixel32 >> 16;

				VRAM[ vZOffset[0] ] = vZPixel32_0 [ 0 ];
				VRAM[ vZOffset[1] ] = vZPixel32_0 [ 1 ];
				VRAM[ vZOffset[2] ] = vZPixel32_0 [ 2 ];
				VRAM[ vZOffset[3] ] = vZPixel32_0 [ 3 ];

				// if a 32-bit z buffer, then store the upper part of depth value
				if ( ( ZBUFPSM & 1 ) == 0 )
				{

					VRAM[ vZOffset[0]+1 ] = vZPixel32_1 [ 0 ];
					VRAM[ vZOffset[1]+1 ] = vZPixel32_1 [ 1 ];
					VRAM[ vZOffset[2]+1 ] = vZPixel32_1 [ 2 ];
					VRAM[ vZOffset[3]+1 ] = vZPixel32_1 [ 3 ];
				}
			}

#endif

//#endif


				//viR += drdx * group_vxinc;
				//viG += dgdx * group_vxinc;
				//viB += dbdx * group_vxinc;
				//viA += dadx * group_vxinc;
				viR += drdx << group_vxinc_shift;
				viG += dgdx << group_vxinc_shift;
				viB += dbdx << group_vxinc_shift;
				viA += dadx << group_vxinc_shift;

				//viU += dudx * group_vxinc;
				//viV += dvdx * group_vxinc;
				//viF += dfdx * group_vxinc;
				viU += dudx << group_vxinc_shift;
				viV += dvdx << group_vxinc_shift;
				viF += dfdx << group_vxinc_shift;

				vfS += dsdx * float( group_vxinc );
				vfT += dtdx * float( group_vxinc );
				vfQ += dqdx * float( group_vxinc );

				// *** todo ***
				viZ += dzdx * double( group_vxinc );
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//vdx += vdxdy * group_yinc;
		vdx += vdxdy << group_yinc_shift;
		
		//vdr += vdrdy * group_yinc;
		//vdg += vdgdy * group_yinc;
		//vdb += vdbdy * group_yinc;
		//vda += vdady * group_yinc;
		vdr += vdrdy << group_yinc_shift;
		vdg += vdgdy << group_yinc_shift;
		vdb += vdbdy << group_yinc_shift;
		vda += vdady << group_yinc_shift;

		//vdu += vdudy * group_yinc;
		//vdv += vdvdy * group_yinc;
		//vdf += vdfdy * group_yinc;
		vdu += vdudy << group_yinc_shift;
		vdv += vdvdy << group_yinc_shift;
		vdf += vdfdy << group_yinc_shift;

		vds += vdsdy * float( group_yinc );
		vdt += vdtdy * float( group_yinc );
		vdq += vdqdy * float( group_yinc );

		// *** todo ***
		vdz += vdzdy * double( group_yinc );
	}
	
	} // end if ( EndY >= StartY )

#endif	// end #ifdef CALC_TRIANGLE_TEXTURE_VARS


	}	// end if ( bDraw == 1 )


#ifdef DRAW_TRIANGLE_TEXTURE_MULTI

		uIndex += 64;

		uIdx += 128;

		Comm = inputdata [ uIndex + ( 15 << 1 ) + 0 ];

		//PRIM = Comm & 0x17;
		//Comm >>= 24;

		Comm &= 0xff000017;

	} while ( ( Comm >= 0x13 ) && ( Comm <= 0x15 ) && ( uIndex < ( COMMAND_LIST_SIZE << 6 ) ) );

	return ( uIndex >> 6 ) - 1;

#else

	return;

#endif

}




void TransferPixelPacketMove ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	



	//uint bgr2;
	uint pix0, pix1;
	uint DestPixel;
	//uint Data;

	
	int CurX, CurY;
	int CurX2, CurY2;

	ivec4 ivCurX, ivCurY;
	ivec4 ivCurX2, ivCurY2;

	int iPtr;
	//int iCount;
	
	//int xxpixel;
	//int xximagepixel;


	int dX;
	int dY;
	int w;
	int h;
	int sX;
	int sY;
	
	//int BS;

	int XferX, XferY;
	int XferWidth, XferHeight;
	int XferDstBufWidth;
	int XferSrcBufWidth;
	//int XferDstX, XferDstY;
	//int XferSrcX, XferSrcY;
	//int Count32;

	int XferDstOffset32;
	int XferSrcOffset32;

	//int XferCount32, XferCountX;

	//uint XferId0, XferIdX;
	int iYOffset_xor, iYOffset_add, iXOffset, iOffset;
	ivec4 ivYOffset_xor, ivYOffset_add, ivXOffset, ivOffset;

	//int xximagepixelstart;
	//int SharedYMax;
	//uint Comm;

	uint BITBLTBUF_0;
	uint BITBLTBUF_1;
	uint DPSM;
	uint SPSM;

	uvec2 pix2;

	uvec4 vPixel;

	//uint uStartIndex;

	int iShift0, iShift1, iShift2;
	int iMask0, iMask1, iMask2;
	int iPixelShift;

	int iCount;
	ivec4 ivIndex;
	ivec4 vIdx;

	uIndex <<= 6;

	
	//if ( xxid == 0 )
	//{

		//Count = 0;

		BITBLTBUF_0 = inputdata [ uIndex + ( 0 << 1 ) + 0 ];
		SPSM = ( BITBLTBUF_0 >> 24 ) & 0x3f;

		BITBLTBUF_1 = inputdata [ uIndex + ( 0 << 1 ) + 1 ];
		DPSM = ( BITBLTBUF_1 >> 24 ) & 0x3f;

		//Count32 = int( inputdata [ uIndex + ( 4 << 1 ) + 0 ] );

		// XferX, XferY
		sX = int( inputdata [ uIndex + ( 5 << 1 ) + 0 ] );
		sY = int( inputdata [ uIndex + ( 6 << 1 ) + 0 ] );

		// XferDstX, XferDstY
		dX = int( inputdata [ uIndex + ( 7 << 1 ) + 0 ] );
		dY = int( inputdata [ uIndex + ( 8 << 1 ) + 0 ] );
		
		// XferWidth, XferHeight
		w = int( inputdata [ uIndex + ( 9 << 1 ) + 0 ] );
		h = int( inputdata [ uIndex + ( 10 << 1 ) + 0 ] );
		
		// XferDstBufWidth
		XferDstBufWidth = int( inputdata [ uIndex + ( 11 << 1 ) + 0 ] );
		XferDstOffset32 = int( inputdata [ uIndex + ( 12 << 1 ) + 0 ] );

		XferSrcBufWidth = int( inputdata [ uIndex + ( 13 << 1 ) + 0 ] );
		XferSrcOffset32 = int( inputdata [ uIndex + ( 14 << 1 ) + 0 ] );

		// 32-bits is stored in 2 16-bit pieces for the shader
		XferDstOffset32 <<= 1;
		XferSrcOffset32 <<= 1;

		iCount = w * h;

	barrier ();

	// *** SOURCE *** //

	if ( ( SPSM & 0xe ) == 0 )
	{
		// 24/32-bit pixels //

#ifdef USE_MULTI_PIXEL_MOVE
		SPSM >>= 1;

		for ( ivIndex = ( xxid << 2 ) + ivec4( 0, 1, 2, 3 ); ivIndex.w < iCount; ivIndex += ( xxinc << 2 ) )
		{
			// get x,y
			ivCurX = ivIndex % w;
			ivCurY = ivIndex / w;

			// get x2,y2
			ivCurX2 = ( sX + ivCurX );
			ivCurY2 = ( sY + ivCurY );

			// wrap coords at 2048
			ivCurX2 &= 0x7ff;
			ivCurY2 &= 0x7ff;

			// wraparound buffer
			ivCurX2 %= XferSrcBufWidth;

			vIdx = ( ivCurY2 & 0x1f ) | int( SPSM << 7 );
			ivYOffset_xor = ivec4( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ], LUT_YOFFSET [ vIdx.z ], LUT_YOFFSET [ vIdx.w ] );
			ivYOffset_add = ( ivCurY2 & ~0x1f ) * XferSrcBufWidth;

			vIdx = ( ivCurX2 ) | int( SPSM << 12 );
			ivXOffset = ivec4( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ], LUT_XOFFSET [ vIdx.z ], LUT_XOFFSET [ vIdx.w ] );
			ivOffset = ivXOffset ^ ivYOffset_xor;
			ivOffset += ivYOffset_add;

			ivOffset <<= 1;

			ivOffset += XferSrcOffset32;


			//vIdx = ( ivCurX + ( ivCurY * w ) );
			sVRAM4 [ ivIndex.x >> 1 ] = uvec4( VRAM2 [ ivOffset.x >> 1 ], VRAM2 [ ivOffset.y >> 1 ] );
			sVRAM4 [ ivIndex.z >> 1 ] = uvec4( VRAM2 [ ivOffset.z >> 1 ], VRAM2 [ ivOffset.w >> 1 ] );

			//sVRAM2 [ vIdx.x ] = VRAM2 [ ivOffset.x >> 1 ];
			//sVRAM2 [ vIdx.y ] = VRAM2 [ ivOffset.y >> 1 ];
			//sVRAM2 [ vIdx.z ] = VRAM2 [ ivOffset.z >> 1 ];
			//sVRAM2 [ vIdx.w ] = VRAM2 [ ivOffset.w >> 1 ];
		}

		if( ivIndex.x < iCount )
		{
			// get x,y
			ivCurX = ivIndex % w;
			ivCurY = ivIndex / w;

			// get x2,y2
			ivCurX2 = ( sX + ivCurX );
			ivCurY2 = ( sY + ivCurY );

			// wrap coords at 2048
			ivCurX2 &= 0x7ff;
			ivCurY2 &= 0x7ff;

			// wraparound buffer
			ivCurX2 %= XferSrcBufWidth;

			vIdx = ( ivCurY2 & 0x1f ) | int( SPSM << 7 );
			//ivYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( SPSM << 7 ) ];
			ivYOffset_xor = ivec4( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ], LUT_YOFFSET [ vIdx.z ], 0 );
			ivYOffset_add = ( ivCurY2 & ~0x1f ) * XferSrcBufWidth;

			vIdx = ( ivCurX2 ) | int( SPSM << 12 );
			//ivXOffset = LUT_XOFFSET [ ( CurX2 ) | ( SPSM << 12 ) ];
			ivXOffset = ivec4( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ], LUT_XOFFSET [ vIdx.z ], 0 );
			ivOffset = ivXOffset ^ ivYOffset_xor;
			ivOffset += ivYOffset_add;

			ivOffset <<= 1;

			ivOffset += XferSrcOffset32;

			//pix2 = VRAM2 [ iOffset >> 1 ];
			//sVRAM2 [ ( CurX + ( CurY * w ) ) ] = pix2;

			//vIdx = ( ivCurX + ( ivCurY * w ) );
			sVRAM2 [ ivIndex.x ] = VRAM2 [ ivOffset.x >> 1 ];

			if ( ivIndex.y < iCount )
			{
				sVRAM2 [ ivIndex.y ] = VRAM2 [ ivOffset.y >> 1 ];
			}

			if ( ivIndex.z < iCount )
			{
				sVRAM2 [ ivIndex.z ] = VRAM2 [ ivOffset.z >> 1 ];
			}
		}

#else
		SPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{

			// use source start //
			
			CurY2 = ( sY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( SPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x1f ) * XferSrcBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				CurX2 = ( sX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound buffer
				CurX2 %= XferSrcBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( SPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				iOffset <<= 1;

				iOffset += XferSrcOffset32;

				//pix0 = ( VRAM [ iOffset + 0 ] & 0xffff ) | ( VRAM[ iOffset + 1 ] << 16 );
				pix2 = VRAM2 [ iOffset >> 1 ];

				sVRAM2 [ ( CurX + ( CurY * w ) ) ] = pix2;
			}

		}	// end for ( CurY = yid; CurY < Height; CurY += yinc )

#endif

	}	// end if ( ( SPSM & 0xf ) == 0 )
	else if ( ( SPSM & 0x3 ) == 0x2 )
	{
		// 16-bit pixels //

		SPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{

			// use source start //
			
			CurY2 = ( sY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x3f ) | ( SPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x3f ) * XferSrcBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				CurX2 = ( sX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound buffer
				CurX2 %= XferSrcBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( SPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				//iOffset <<= 1;

				iOffset += XferSrcOffset32;

				pix0 = VRAM [ iOffset + 0 ];

				sVRAM [ CurX + ( CurY * w ) ] = pix0;
			}

		}	// end for ( CurY = yid; CurY < Height; CurY += yinc )
	}
	else if ( SPSM <= 0x14 )
	{
		// 4/8-bit pixels //

		iMask0 = ( ( SPSM & 0x3 ) == 0x3 ) ? 0x1 : 0x3;
		iShift0 = ( ( SPSM & 0x3 ) == 0x3 ) ? 3 : 2;
		iShift1 = ( ( SPSM & 0x3 ) == 0x3 ) ? 1 : 2;

		SPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{

			// use source start //
			
			CurY2 = ( sY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x3f ) | ( SPSM << 7 ) ];
			//iYOffset_add = ( CurY2 & ~0x3f ) * XferSrcBufWidth;
			iYOffset_add = ( CurY2 & LUT_YNAND[SPSM] ) * XferSrcBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				CurX2 = ( sX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound buffer
				CurX2 %= XferSrcBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( SPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				//iOffset <<= 1;

				// extract the amount to shift pixel
				iPixelShift = ( iOffset & iMask0 ) << iShift0;
				iOffset >>= iShift1;

				iOffset += XferSrcOffset32;

				pix0 = VRAM [ iOffset + 0 ] >> iPixelShift;

				sVRAM [ CurX + ( CurY * w ) ] = pix0;
			}

		}	// end for ( CurY = yid; CurY < Height; CurY += yinc )
	}
	else
	{
		// 4/8-bit in 32-bit pixels //

		iShift0 = 8;
		iShift0 = ( ( ( SPSM >> 2 ) & 0x3 ) == 0x3 ) ? 12 : iShift0;

		SPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{

			// use source start //
			
			CurY2 = ( sY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( SPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x1f ) * XferSrcBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				CurX2 = ( sX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound buffer
				CurX2 %= XferSrcBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( SPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				iOffset <<= 1;

				iOffset += XferSrcOffset32;

				pix0 = VRAM[ iOffset + 1 ];

				sVRAM [ CurX + ( CurY * w ) ] = pix0 >> iShift0;
			}

		}	// end for ( CurY = yid; CurY < Height; CurY += yinc )
	}



	barrier ();


	// *** DESTINATION *** //

	if ( ( DPSM & 0xf ) == 0 )
	{
		// 32-bit pixels //

#ifdef USE_MULTI_PIXEL_MOVE

		DPSM >>= 1;
		for ( ivIndex = ( xxid << 2 ) + ivec4( 0, 1, 2, 3 ); ivIndex.w < iCount; ivIndex += ( xxinc << 2 ) )
		{
			// get x,y
			ivCurX = ivIndex % w;
			ivCurY = ivIndex / w;

			// get x2,y2
			ivCurX2 = ( dX + ivCurX );
			ivCurY2 = ( dY + ivCurY );

			// wrap coords at 2048
			ivCurX2 &= 0x7ff;
			ivCurY2 &= 0x7ff;

			// wraparound buffer
			ivCurX2 %= XferDstBufWidth;

			vIdx = ( ivCurY2 & 0x1f ) | int( DPSM << 7 );
			ivYOffset_xor = ivec4( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ], LUT_YOFFSET [ vIdx.z ], LUT_YOFFSET [ vIdx.w ] );
			ivYOffset_add = ( ivCurY2 & ~0x1f ) * XferDstBufWidth;

			vIdx = ( ivCurX2 ) | int( DPSM << 12 );
			ivXOffset = ivec4( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ], LUT_XOFFSET [ vIdx.z ], LUT_XOFFSET [ vIdx.w ] );
			ivOffset = ivXOffset ^ ivYOffset_xor;
			ivOffset += ivYOffset_add;

			ivOffset <<= 1;

			ivOffset += XferDstOffset32;

			//pix2 = VRAM2 [ iOffset >> 1 ];
			//sVRAM2 [ ( CurX + ( CurY * w ) ) ] = pix2;

			//vIdx = ( ivCurX + ( ivCurY * w ) );

			vPixel = sVRAM4 [ ivIndex.x >> 1 ];
			VRAM2 [ ivOffset.x >> 1 ] = vPixel.xy;
			VRAM2 [ ivOffset.y >> 1 ] = vPixel.zw;
			vPixel = sVRAM4 [ ivIndex.z >> 1 ];
			VRAM2 [ ivOffset.z >> 1 ] = vPixel.xy;
			VRAM2 [ ivOffset.w >> 1 ] = vPixel.zw;

			//VRAM2 [ ivOffset.x >> 1 ] = sVRAM2 [ vIdx.x ];
			//VRAM2 [ ivOffset.y >> 1 ] = sVRAM2 [ vIdx.y ];
			//VRAM2 [ ivOffset.z >> 1 ] = sVRAM2 [ vIdx.z ];
			//VRAM2 [ ivOffset.w >> 1 ] = sVRAM2 [ vIdx.w ];
		}

		if( ivIndex.x < iCount )
		{
			// get x,y
			ivCurX = ivIndex % w;
			ivCurY = ivIndex / w;

			// get x2,y2
			ivCurX2 = ( dX + ivCurX );
			ivCurY2 = ( dY + ivCurY );

			// wrap coords at 2048
			ivCurX2 &= 0x7ff;
			ivCurY2 &= 0x7ff;

			// wraparound buffer
			ivCurX2 %= XferDstBufWidth;

			vIdx = ( ivCurY2 & 0x1f ) | int( DPSM << 7 );
			ivYOffset_xor = ivec4( LUT_YOFFSET [ vIdx.x ], LUT_YOFFSET [ vIdx.y ], LUT_YOFFSET [ vIdx.z ], 0 );
			ivYOffset_add = ( ivCurY2 & ~0x1f ) * XferDstBufWidth;

			vIdx = ( ivCurX2 ) | int( DPSM << 12 );
			ivXOffset = ivec4( LUT_XOFFSET [ vIdx.x ], LUT_XOFFSET [ vIdx.y ], LUT_XOFFSET [ vIdx.z ], 0 );
			ivOffset = ivXOffset ^ ivYOffset_xor;
			ivOffset += ivYOffset_add;

			ivOffset <<= 1;

			ivOffset += XferDstOffset32;

			//pix2 = VRAM2 [ iOffset >> 1 ];
			//sVRAM2 [ ( CurX + ( CurY * w ) ) ] = pix2;

			//vIdx = ( ivCurX + ( ivCurY * w ) );
			VRAM2 [ ivOffset.x >> 1 ] = sVRAM2 [ ivIndex.x ];

			if ( ivIndex.y < iCount )
			{
				VRAM2 [ ivOffset.y >> 1 ] = sVRAM2 [ ivIndex.y ];
			}

			if ( ivIndex.z < iCount )
			{
				VRAM2 [ ivOffset.z >> 1 ] = sVRAM2 [ ivIndex.z ];
			}
		}

#else
		DPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{
			// use destination start //
			
			CurY2 = ( dY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( DPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x1f ) * XferDstBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				//pix0 = sVRAM [ CurX + ( CurY * w ) ];
				pix2 = sVRAM2 [ ( CurX + ( CurY * w ) ) ];

				CurX2 = ( dX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound destination buffer
				CurX2 %= XferDstBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( DPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				iOffset <<= 1;

				iOffset += XferDstOffset32;


				//VRAM [ iOffset + 0 ] = pix0 & 0xffff;
				//VRAM [ iOffset + 1 ] = pix0 >> 16;
				VRAM2 [ iOffset >> 1 ] = pix2;

			}	// end for ( CurX = xid; CurX < w; CurX += xinc )

		}	// end for ( CurY = yid; CurY < h; CurY += yinc )

#endif

	}	// end if ( ( DPSM & 0xf ) == 0 )
	else if ( ( DPSM & 0x3 ) == 1 )
	{
		// 24-bit pixels //

		DPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{
			// use destination start //
			
			CurY2 = ( dY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( DPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x1f ) * XferDstBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				//pix0 = sVRAM [ CurX + ( CurY * w ) ];
				pix2 = sVRAM2 [ ( CurX + ( CurY * w ) ) ];

				CurX2 = ( dX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound destination buffer
				CurX2 %= XferDstBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( DPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				iOffset <<= 1;

				iOffset += XferDstOffset32;


				//VRAM [ iOffset + 0 ] = pix0 & 0xffff;
				//VRAM [ iOffset + 1 ] = ( ( pix0 >> 16 ) & 0x00ff ) | ( VRAM [ iOffset + 1 ] & 0xff00 );
				pix0 = VRAM [ iOffset + 1 ];
				pix2.y = ( pix2.y & 0x00ff ) | ( pix0 & 0xff00 );
				VRAM2 [ iOffset >> 1 ] = pix2;

			}	// end for ( CurX = xid; CurX < w; CurX += xinc )

		}	// end for ( CurY = yid; CurY < h; CurY += yinc )

	}	// end if ( ( DPSM & 0x1 ) == 1 )
	else if ( ( DPSM & 0x3 ) == 0x2 )
	{
		// 16-bit pixels //

		DPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{
			// use destination start //
			
			CurY2 = ( dY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x3f ) | ( DPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x3f ) * XferDstBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{

				//pix0 = ( VRAM [ iOffset ] & 0xffff ) | ( VRAM[ iOffset + 1 ] << 16 );
				pix0 = sVRAM [ CurX + ( CurY * w ) ];

				CurX2 = ( dX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound destination buffer
				CurX2 %= XferDstBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( DPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				//iOffset <<= 1;

				iOffset += XferDstOffset32;


				VRAM [ iOffset + 0 ] = pix0 & 0xffff;
				//VRAM [ iOffset + 1 ] = pix0 >> 16;

			}	// end for ( CurX = xid; CurX < w; CurX += xinc )

		}	// end for ( CurY = yid; CurY < h; CurY += yinc )

	}	// end if ( ( DPSM & 0x3 ) == 0x2 )
	else if ( DPSM <= 0x14 )
	{
		// 4/8-bit pixels //

		iMask0 = ( ( DPSM & 0x3 ) == 0x3 ) ? 0x1 : 0x3;
		iShift0 = ( ( DPSM & 0x3 ) == 0x3 ) ? 3 : 2;
		iMask1 = ( ( DPSM & 0x3 ) == 0x3 ) ? 0xff : 0xf;

		DPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{
			// use destination start //
			
			CurY2 = ( dY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x7f ) | ( DPSM << 7 ) ];
			iYOffset_add = ( CurY2 & LUT_YNAND[DPSM] ) * XferDstBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				pix0 = sVRAM [ CurX + ( CurY * w ) ];

				CurX2 = ( dX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound destination buffer
				CurX2 %= XferDstBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( DPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				// extract the amount to shift pixel
				iPixelShift = ( iOffset & iMask0 ) << iShift0;
				iOffset >>= iShift1;

				//iOffset <<= 1;

				iOffset += XferDstOffset32;

				DestPixel = VRAM [ iOffset + 0 ];
				DestPixel &= ( iMask1 << iPixelShift );

				pix0 = ( pix0 & iMask1 ) << iPixelShift;
				pix0 = pix0 ^ DestPixel;

				//VRAM [ iOffset + 0 ] = pix0 & 0xffff;
				atomicXor ( VRAM [ iOffset + 0 ], pix0 );

				//VRAM [ iOffset + 1 ] = pix0 >> 16;

			}	// end for ( CurX = xid; CurX < w; CurX += xinc )

		}	// end for ( CurY = yid; CurY < h; CurY += yinc )

	}	// end if ( DPSM <= 0x14 )
	else
	{

		iShift0 = 8;
		iShift0 = ( ( ( DPSM >> 2 ) & 0x3 ) == 0x3 ) ? 12 : iShift0;
		iMask0 = ( ( DPSM & 0x3 ) == 0x3 ) ? 0xff : 0xf;
		iMask0 <<= iShift0;

		DPSM >>= 1;
		for ( CurY = yid; CurY < h; CurY += yinc )
		{
			// use destination start //
			
			CurY2 = ( dY + CurY );
			iYOffset_xor = LUT_YOFFSET [ ( CurY2 & 0x1f ) | ( DPSM << 7 ) ];
			iYOffset_add = ( CurY2 & ~0x1f ) * XferDstBufWidth;

			for ( CurX = xid; CurX < w; CurX += xinc )
			{
				pix0 = sVRAM [ CurX + ( CurY * w ) ];

				CurX2 = ( dX + CurX );

				// coords wrap at 2048
				CurY2 &= 0x7ff;
				CurX2 &= 0x7ff;

				// wraparound destination buffer
				CurX2 %= XferDstBufWidth;

				iXOffset = LUT_XOFFSET [ ( CurX2 ) | ( DPSM << 12 ) ];
				iOffset = iXOffset ^ iYOffset_xor;
				iOffset += iYOffset_add;

				iOffset <<= 1;

				iOffset += XferDstOffset32;


				//VRAM [ iOffset + 0 ] = pix0 & 0xffff;
				//AtomicXor ( VRAM [ iOffset + 0 ], pix0 );

				pix0 = ( pix0 << iShift0 );
				VRAM [ iOffset + 1 ] = ( pix0 & iMask0 ) | ( VRAM [ iOffset + 1 ] & ~iMask0 );

			}	// end for ( CurX = xid; CurX < w; CurX += xinc )

		}	// end for ( CurY = yid; CurY < h; CurY += yinc )
	}




	barrier ();


	//}	// end if local_id

	//	uIndex += 16;
	//	Comm = inputdata [ uIndex + 7 ] >> 24;
	//} while ( ( Comm == 0x80 ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

	return;
	//return ( uIndex >> 4 ) - 1;
}







void TransferPixelPacketIn ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	



	uint bgr2;
	uint pix0, pix1;
	uint DestPixel;
	uint Data;

	
	//int iX, iY;
	int CurX, CurY;

	int iPtr;
	int iCount;
	
	int xxpixel;
	int xximagepixel;


	uint GPU_CTRL_Read;
	int dX;
	int dY;
	int w;
	int h;
	int sX;
	int sY;
	
	int BS;

	int XferX, XferY;
	int XferWidth, XferHeight;
	int XferDstBufWidth;
	int XferDstX, XferDstY;
	int Count32;

	int XferDstOffset32;

	int XferCount32, XferCountX;

	uint XferId0, XferIdX;
	int iYOffset, iXOffset, iOffset;

	int xximagepixelstart;
	int SharedYMax;
	uint Comm;

	uint BITBLTBUF_1;
	uint DPSM;

	uint uStartIndex;

	int iShift0, iShift1, iShift2;
	int iMask0, iMask1, iMask2;
	int iPixelShift;

	uIndex <<= 6;

	
	//if ( xxid == 0 )
	//{

		//Count = 0;

		BITBLTBUF_1 = inputdata [ uIndex + ( 0 << 1 ) + 1 ];
		DPSM = ( BITBLTBUF_1 >> 24 ) & 0x3f;

		Count32 = int( inputdata [ uIndex + ( 4 << 1 ) + 0 ] );

		// XferX, XferY
		sX = int( inputdata [ uIndex + ( 5 << 1 ) + 0 ] );
		sY = int( inputdata [ uIndex + ( 6 << 1 ) + 0 ] );

		// XferDstX, XferDstY
		dX = int( inputdata [ uIndex + ( 7 << 1 ) + 0 ] );
		dY = int( inputdata [ uIndex + ( 8 << 1 ) + 0 ] );
		
		// XferWidth, XferHeight
		w = int( inputdata [ uIndex + ( 9 << 1 ) + 0 ] );
		h = int( inputdata [ uIndex + ( 10 << 1 ) + 0 ] );
		
		// XferDstBufWidth
		XferDstBufWidth = int( inputdata [ uIndex + ( 11 << 1 ) + 0 ] );

		XferDstOffset32 = int( inputdata [ uIndex + ( 12 << 1 ) + 0 ] );

		// 32-bits is stored in 2 16-bit pieces for the shader
		XferDstOffset32 <<= 1;

		// get count of pixels
		XferCount32 = int( inputdata [ uIndex + ( 13 << 1 ) + 0 ] );

		// id for the transfer
		XferId0 = int( inputdata [ uIndex + ( 14 << 1 ) + 0 ] );

		// count is per 2 pixels
		//BS <<= 1;
		

		// get start index for pixels in pixel input buffer
		uStartIndex = inputdata [ uIndex + ( 16 << 1 ) + 0 ];



	//}



	barrier ();


	// load iShift0, iShift1, iShift2
	// load iMask0, iMask1, iMask2
	iShift0 = ( ( DPSM & 0x3 ) == 0x3 ) ? 2 : 3;
	iShift1 = ( ( DPSM & 0x3 ) == 0x3 ) ? 3 : 2;
	iShift2 = ( ( DPSM & 0x3 ) == 0x3 ) ? 1 : 2;

	iMask0 = ( ( DPSM & 0x3 ) == 0x3 ) ? 0xff : 0xf;
	iMask1 = ( ( DPSM & 0x3 ) == 0x3 ) ? 0x3 : 0x7;
	iMask2 = iMask1 >> 1;

	if ( ( DPSM & 0xf ) == 0 )
	{
		// 32-bit pixels //

		SharedYMax = Count32;
		XferCountX = XferCount32;
		DPSM >>= 1;
		xximagepixelstart = XferCountX;
		for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
		{
			//pix0 = inputdata [ uIndex + ( ( iCount & ~0x1f ) << 1 ) + 32 + ( iCount & 0x1f ) ];
			pix0 = PixelInput32 [ uStartIndex + iCount ];

			// need the pixel count in the image ( sX + sY * w )
			xximagepixel = iCount + xximagepixelstart;

			CurX = xximagepixel % w;
			CurY = xximagepixel / w;

			// get the offset to the pixel
			CurY += dY;
			CurX += dX;

			// coords wrap at 2048
			CurY &= 0x7ff;
			CurX &= 0x7ff;

			// the x wraps around the buffer
			CurX %= XferDstBufWidth;

			iYOffset = LUT_YOFFSET [ ( CurY & 0x1f ) | ( DPSM << 7 ) ];
			iXOffset = LUT_XOFFSET [ ( CurX & 0xfff ) | ( DPSM << 12 ) ];
			iOffset = iXOffset ^ iYOffset;
			iOffset += ( CurY & ~0x1f ) * XferDstBufWidth;
			iOffset <<= 1;

			iOffset += XferDstOffset32;

			// store 32-bit data
			VRAM [ iOffset + 0 ] = pix0 & 0xffff;
			VRAM [ iOffset + 1 ] = pix0 >> 16;

		}
	}
	else if ( ( DPSM & 0x3 ) == 1 )
	{
		// 24-bit pixels //

		SharedYMax = Count32;
		XferCountX = XferCount32;
		DPSM >>= 1;
		xximagepixelstart = XferCountX;
		for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
		{
			pix0 = PixelInput32 [ uStartIndex + iCount ];

			// need the pixel count in the image ( sX + sY * w )
			xximagepixel = iCount + xximagepixelstart;

			CurX = xximagepixel % w;
			CurY = xximagepixel / w;

			// get the offset to the pixel
			CurY += dY;
			CurX += dX;

			// coords wrap at 2048
			CurY &= 0x7ff;
			CurX &= 0x7ff;

			// the x wraps around the buffer
			CurX %= XferDstBufWidth;

			iYOffset = LUT_YOFFSET [ ( CurY & 0x1f ) | ( DPSM << 7 ) ];
			iXOffset = LUT_XOFFSET [ ( CurX & 0xfff ) | ( DPSM << 12 ) ];
			iOffset = iXOffset ^ iYOffset;
			iOffset += ( CurY & ~0x1f ) * XferDstBufWidth;
			iOffset <<= 1;

			iOffset += XferDstOffset32;

			// store 32-bit data
			VRAM [ iOffset + 0 ] = pix0 & 0xffff;
			VRAM [ iOffset + 1 ] = ( ( pix0 >> 16 ) & 0x00ff ) | ( VRAM [ iOffset + 1 ] & 0xff00 );
		}
	}
	else if ( ( DPSM & 0x3 ) == 0x2 )
	{
		// 16-bit pixels //

		SharedYMax = Count32 << 1;
		XferCountX = XferCount32 << 1;
		DPSM >>= 1;
		xximagepixelstart = XferCountX;
		for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
		{
			//pix0 = inputdata [ uIndex + ( ( iCount & ~0x3f ) << 0 ) + 32 + ( ( iCount >> 1 ) & 0x1f ) ];
			//pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
			pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];
			pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;

			// need the pixel count in the image ( sX + sY * w )
			xximagepixel = iCount + xximagepixelstart;

			CurX = xximagepixel % w;
			CurY = xximagepixel / w;

			// get the offset to the pixel
			CurY += dY;
			CurX += dX;

			// coords wrap at 2048
			CurY &= 0x7ff;
			CurX &= 0x7ff;

			// the x wraps around the buffer
			CurX %= XferDstBufWidth;

			iYOffset = LUT_YOFFSET [ ( CurY & 0x3f ) | ( DPSM << 7 ) ];
			iXOffset = LUT_XOFFSET [ ( CurX & 0xfff ) | ( DPSM << 12 ) ];
			iOffset = iXOffset ^ iYOffset;
			iOffset += ( CurY & ~0x3f ) * XferDstBufWidth;
			//iOffset <<= 1;

			iOffset += XferDstOffset32;

			VRAM [ iOffset ] = pix0;

		}

	}
	else if ( ( DPSM >= 0x13 ) && ( DPSM <= 0x14 ) )
	{

		// iShift0= 8h: 2, 4h: 3 =iShift0
		SharedYMax = Count32 << iShift0;
		XferCountX = XferCount32 << iShift0;

		DPSM >>= 1;
		xximagepixelstart = XferCountX;
		for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
		{
			// iShift0= 8h:2, 4hl/hh:3
			pix0 = PixelInput32 [ uStartIndex + ( iCount >> iShift0 ) ];

			// iMask0= 8h:0xff, 4hl/hh:0xf
			// iMask1= 8h: 0x3, 4hl/hh: 0x7
			// iShift1= 8h: 3, 4hl/hh: 2
			pix0 = ( pix0 >> ( ( iCount & iMask1 ) << iShift1 ) ) & iMask0;

			// need the pixel count in the image ( sX + sY * w )
			xximagepixel = iCount + xximagepixelstart;

			CurX = xximagepixel % w;
			CurY = xximagepixel / w;

			// get the offset to the pixel
			CurY += dY;
			CurX += dX;

			// coords wrap at 2048
			CurY &= 0x7ff;
			CurX &= 0x7ff;

			// the x wraps around the buffer
			CurX %= XferDstBufWidth;


			iYOffset = LUT_YOFFSET [ ( CurY & 0x7f ) | ( DPSM << 7 ) ];
			iXOffset = LUT_XOFFSET [ ( CurX & 0xfff ) | ( DPSM << 12 ) ];
			iOffset = iXOffset ^ iYOffset;

			//iOffset += ( CurY & ~0x1f ) * XferDstBufWidth;
			iOffset += ( CurY & LUT_YNAND[DPSM] ) * XferDstBufWidth;
			//iOffset <<= 1;


			// iMask2= iMask1>>1
			iPixelShift = ( ( iOffset & iMask2 ) << iShift1 );

			// iShift2= 8h: 1, 4h: 2
			iOffset >>= iShift2;


			iOffset += XferDstOffset32;


			DestPixel = VRAM [ iOffset ];

			DestPixel = DestPixel & ( iMask0 << iPixelShift );
			//DestPixel = DestPixel & ~( iMask0 << iPixelShift );

			pix0 = ( pix0 << iPixelShift ) ^ DestPixel;
			//pix0 = ( pix0 << iPixelShift ) | DestPixel;

			// modify just the one pixel
			atomicXor ( VRAM [ iOffset ], pix0 );
			//VRAM [ iOffset ] = pix0;
		}

	}
	else if ( ( DPSM >= 0x1b ) && ( DPSM <= 0x2c ) )
	{
		iShift2 = 8;
		iShift2 = ( ( ( DPSM >> 2 ) & 0x3 ) == 0x3 ) ? 12 : iShift2;
		iMask2 = ~( iMask0 << iShift2 );

		//SharedYMax = Count32 << 1;
		//XferCountX = XferCount32 << 1;
		SharedYMax = Count32 << iShift0;
		XferCountX = XferCount32 << iShift0;
		DPSM >>= 1;
		xximagepixelstart = XferCountX;
		for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
		{
			//pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];
			//pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;

			// iShift0= 8h:2, 4hl/hh:3
			pix0 = PixelInput32 [ uStartIndex + ( iCount >> iShift0 ) ];

			// iMask0= 8h:0xff, 4hl/hh:0xf
			// iMask1= 8h: 0x3, 4hl/hh: 0x7
			// iShift1= 8h: 3, 4hl/hh: 2
			pix0 = ( pix0 >> ( ( iCount & iMask1 ) << iShift1 ) ) & iMask0;

			// need the pixel count in the image ( sX + sY * w )
			xximagepixel = iCount + xximagepixelstart;

			CurX = xximagepixel % w;
			CurY = xximagepixel / w;

			// get the offset to the pixel
			CurY += dY;
			CurX += dX;

			// coords wrap at 2048
			CurY &= 0x7ff;
			CurX &= 0x7ff;

			// the x wraps around the buffer
			CurX %= XferDstBufWidth;

			iYOffset = LUT_YOFFSET [ ( CurY & 0x1f ) | ( DPSM << 7 ) ];
			iXOffset = LUT_XOFFSET [ ( CurX & 0xfff ) | ( DPSM << 12 ) ];
			iOffset = iXOffset ^ iYOffset;
			iOffset += ( CurY & ~0x1f ) * XferDstBufWidth;
			iOffset <<= 1;

			iOffset += XferDstOffset32;

			iOffset += 1;
			DestPixel = VRAM [ iOffset ];

			// iShift2= 8h: 8, 4hl: 8, 4hh: 12
			// iMask2= 8h: 0x00ff, 4hl: 0xf0ff, 4hh: 0x0fff
			pix0 = ( pix0 << iShift2 ) | ( DestPixel & iMask2 );

			VRAM [ iOffset ] = pix0;

		}

	}

	

	barrier ();

	return;
	//return ( ( uIndex >> 4 ) + ( ( SharedYMax + 0xf ) >> 4 ) - 1 );
}



void main ()
{
	uint uIdx;
	uint uCommand;
	uint uIndex;
	//uint uTargetIndex;
	//uint iInputMask;

	uint PRIM, OBJ;


	// sometimes want to arrange things in the x direction only
	uint xxid = gl_LocalInvocationIndex;


	uint xid = gl_GlobalInvocationID.x;
	uint yid = gl_GlobalInvocationID.y;


	group_x = int( gl_WorkGroupID.x );
	group_y = int( gl_WorkGroupID.y );
	group_xcount = int( gl_NumWorkGroups.x );
	group_ycount = int( gl_NumWorkGroups.y );


	group_xshift = findLSB( group_xcount );
	group_yshift = findLSB( group_ycount );

	// get the increments
	//if ( xid + yid == 0 )
	//{
		xinc = int( gl_WorkGroupSize.x );
		yinc = int( gl_WorkGroupSize.y );
		xxinc = int( gl_WorkGroupSize.x ) * int( gl_WorkGroupSize.y );
	//}

	group_xinc = ( xinc << group_xshift );
	group_yinc = ( yinc << group_yshift );

	group_xinc_shift = findLSB( group_xinc );
	group_yinc_shift = findLSB( group_yinc );

	group_xmask = group_xinc - 1;
	group_ymask = group_yinc - 1;

	// want to use vector computations -> 4 components per vector
	// will put the vectors in the x-direction
	group_vxinc = group_xinc << 2;
	group_vxmask = group_vxinc - 1;

	group_vxinc_shift = findLSB( group_vxinc );

	CBPX2 = cCBPX2;
	for ( uIndex = xxid; uIndex < 512; uIndex += xxinc )
	{
		LOCAL_CLUT [ uIndex ] = cLOCAL_CLUT [ uIndex ];
	}


	//for ( uIndex = xxid; i < 32; i += xxinc )
	//{
	//	LUT_YNAND [ i ] = cLUT_YNAND [ i ];
	//}


	barrier ();

//#ifdef ENABLE_DRAW_PRECOMPUTE

	precompute_data ();

	barrier ();
	//groupMemoryBarrier();
	//memoryBarrierBuffer();
	//memoryBarrierShared();
	//memoryBarrier();
	//memoryBarrierImage();

//#endif


	// for now, set next index to zero
	uIndex = 0;


//#ifdef ENABLE_DRAW_MAIN_LOOP

	//while ( uIndex < COMMAND_LIST_SIZE )
	for ( uIndex = 0; uIndex < COMMAND_LIST_SIZE; uIndex++ )
	{

		// get the next command
		PRIM = inputdata [ ( uIndex << 6 ) + ( 15 << 1 ) + 0 ];
		uCommand = PRIM >> 24;

		
//#ifdef ENABLE_DRAW_INNER_LOOP

		if ( uCommand == 0x00 )
		{
			// check prim
			OBJ = PRIM & 0x7;

			if ( OBJ < 1 )
			{
				// point (1x1 sprite)
			}
			else if ( OBJ < 3 )
			{
				// line //
			}
			else if ( OBJ < 6 )
			{
				// triangle //

				// check if texture mapped
				if ( ( PRIM & 0x10 ) == 0 )
				{
					// NOT-texture //

//#ifdef ENABLE_DRAW_TRIANGLE_COLOR

#ifdef DRAW_TRIANGLE_COLOR_MULTI
					uIndex = Draw_Triangle_Color ( uIndex );
#else
					Draw_Triangle_Color ( uIndex );
#endif

//#endif
				}
				else
				{
					// texture //

//#ifdef ENABLE_DRAW_TRIANGLE_TEXTURE

#ifdef DRAW_TRIANGLE_TEXTURE_MULTI
					uIndex = Draw_Triangle_Texture ( uIndex );
#else
					Draw_Triangle_Texture ( uIndex );
#endif

//#endif
				}
			}
			else if ( OBJ < 7 )
			{
				// sprite //

				// check if texture mapped
				if ( ( PRIM & 0x10 ) == 0 )
				{
//#ifdef ENABLE_DRAW_RECTANGLE

#ifdef DRAW_RECTANGLE_MULTI
					uIndex = Draw_Rectangle ( uIndex );
#else
					Draw_Rectangle ( uIndex );
#endif

//#endif
				}
				else
				{
					// sprite //
//#ifdef ENABLE_DRAW_SPRITE

#ifdef DRAW_SPRITE_MULTI
					uIndex = Draw_Sprite ( uIndex );
#else
					Draw_Sprite ( uIndex );
#endif

//#endif
				}
			}
			//else
			//{
			//	// error ?? //
			//}
		}
		else if ( uCommand == 0xf0 )
		{
//#ifdef ENABLE_DRAW_WRITE_CLUT

			// write CLUT //
			WriteInternalCLUT ( uIndex );

//#endif
		}
		else if ( uCommand == 0xf1 )
		{
//#ifdef ENABLE_DRAW_PIXEL_MOVE

			// move //
			TransferPixelPacketMove ( uIndex );

//#endif
		}
		else if ( uCommand == 0xf8 )
		{
//#ifdef ENABLE_DRAW_PIXEL_INPUT

			// import //
			//uIndex = TransferPixelPacketIn ( uIndex );
			TransferPixelPacketIn ( uIndex );

//#endif
		}
		else if ( uCommand == 0xfe )
		{
//#ifdef ENABLE_DRAW_SCREEN

			draw_screen ( uIndex );

//#endif
		}
		else
		{
			// done //
			break;

		}

//#endif	// end #ifdef ENABLE_DRAW_INNER_LOOP
		
		//barrier ();
		
		//uIndex++;
	}

//#endif	// end #ifdef ENABLE_DRAW_MAIN_LOOP


	barrier ();	

//#ifdef ENABLE_DRAW_INVALIDATE2

	// invalidate all the entries
	for ( uIdx = xxid; uIdx < uIndex; uIdx += xxinc )
	{
		inputdata [ ( uIdx << 6 ) + ( 15 << 1 ) + 0 ] = -1;
	}

	cCBPX2 = CBPX2;
	for ( uIndex = xxid; uIndex < 512; uIndex += xxinc )
	{
		cLOCAL_CLUT [ uIndex ] = LOCAL_CLUT [ uIndex ];
	}

//#endif

	return;

}

)"